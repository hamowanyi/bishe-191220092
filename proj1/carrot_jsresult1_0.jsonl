{"code":"function createInstance(defaultConfig) {\r\n  var context = new Axios(defaultConfig);\r\n  var instance = bind(Axios.prototype.request, context);\r\n  utils.extend(instance, Axios.prototype, context);\r\n  utils.extend(instance, context);\r\n  return instance;\r\n}\r\n\r\n\/*This method is used to","code-length":75,"reference":"Create an instance of Axios","result":"Create a new instance of the Axios class.","score":[0.2336,0.5955]}
{"code":"function CancelToken(executor) {\r\n  if (typeof executor !== 'function') {\r\n    throw new TypeError('executor must be a function.');\r\n  }\r\n  var resolvePromise;\r\n  this.promise = new Promise(function promiseExecutor(resolve) {\r\n    resolvePromise = resolve;\r\n  });\r\n  var token = this;\r\n  executor(function cancel(message) {\r\n    if (token.reason) {\r\n      return;\r\n    }\r\n    token.reason = new Cancel(message);\r\n    resolvePromise(token.reason);\r\n  });\r\n}\r\n\r\n\/*This method is used to","code-length":124,"reference":"A `CancelToken` is an object that can be used to request cancellation of an operation.","result":"Create a new Promise object.","score":[0,0.0357]}
{"code":"function isArrayBufferView(val) {\r\n  var result;\r\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\r\n    result = ArrayBuffer.isView(val);\r\n  } else {\r\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\r\n  }\r\n  return result;\r\n}\r\n\r\n\/*This method is used to","code-length":87,"reference":"Determine if a value is a view on an ArrayBuffer","result":"Convert a string to a number.","score":[0.1179,0.1042]}
{"code":"function isStandardBrowserEnv() {\r\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\r\n                                           navigator.product === 'NativeScript' ||\r\n                                           navigator.product === 'NS')) {\r\n    return false;\r\n  }\r\n  return (\r\n    typeof window !== 'undefined' &&\r\n    typeof document !== 'undefined'\r\n  );\r\n}\r\n\r\n\/*This method is used to","code-length":95,"reference":"Determine if we're running in a standard browser environment","result":"Get the current page .","score":[0,0.0]}
{"code":"function forEach(obj, fn) {\r\n  if (obj === null || typeof obj === 'undefined') {\r\n    return;\r\n  }\r\n  if (typeof obj !== 'object') {\r\n        obj = [obj];\r\n  }\r\n  if (isArray(obj)) {\r\n    for (var i = 0, l = obj.length; i < l; i++) {\r\n      fn.call(null, obj[i], i, obj);\r\n    }\r\n  } else {\r\n    for (var key in obj) {\r\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        fn.call(null, obj[key], key, obj);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\/*This method is used to","code-length":158,"reference":"Iterate over an Array or an Object invoking a function for each item.","result":"Convert a property value to a string .","score":[0.0743,0.04]}
{"code":"function extend(a, b, thisArg) {\r\n  forEach(b, function assignValue(val, key) {\r\n    if (thisArg && typeof val === 'function') {\r\n      a[key] = bind(val, thisArg);\r\n    } else {\r\n      a[key] = val;\r\n    }\r\n  });\r\n  return a;\r\n}\r\n\r\n\/*This method is used to","code-length":85,"reference":"Extends object a by mutably adding to it the properties of object b.","result":"Wrap the function in a function that is calledbefore* the function is called.","score":[0.0973,0.0769]}
{"code":"function writePackageManifest (packageName) {\r\n  const packagePath = require.resolve(packageName + '\/package.json')\r\n  let { name, main, author, license, types, typings } = require(packagePath)\r\n  if (!main) {\r\n    main = 'index.js'\r\n  }\r\n  let typesFile = types || typings\r\n  if (typesFile) {\r\n    typesFile = require.resolve(join(packageName, typesFile))\r\n  }\r\n  const compiledPackagePath = join(__dirname, `dist\/compiled\/${packageName}`)\r\n  const potentialLicensePath = join(dirname(packagePath), '.\/LICENSE')\r\n  if (existsSync(potentialLicensePath)) {\r\n    this._.files.push({\r\n      dir: compiledPackagePath,\r\n      base: 'LICENSE',\r\n      data: readFileSync(potentialLicensePath, 'utf8')\r\n    })\r\n  }\r\n  this._.files.push({\r\n    dir: compiledPackagePath,\r\n    base: 'package.json',\r\n    data:\r\n      JSON.stringify(\r\n        Object.assign(\r\n          {},\r\n          { name, main: `${basename(main, '.' + extname(main))}` },\r\n          author ? { author } : undefined,\r\n          license ? { license } : undefined,\r\n          typesFile\r\n            ? {\r\n              types: relative(compiledPackagePath, typesFile)\r\n            }\r\n            : undefined\r\n        )\r\n      ) + '\\n'\r\n  })\r\n}\r\n\r\n\/*This method is used to","code-length":307,"reference":"This function writes a minimal `package.json` file for a compiled package. It defines `name`, `main`, `author`, and `license`. It also defines `types`. n.b. types intended for development usage only.","result":"Generate the package.","score":[0.0001,0.0189]}
{"code":"function processMessage (e) {\r\n  const obj = JSON.parse(e.data)\r\n  switch (obj.action) {\r\n    case 'building': {\r\n      console.log(\r\n        '[HMR] bundle ' + (obj.name ? \"'\" + obj.name + \"' \" : '') +\r\n        'rebuilding'\r\n      )\r\n      break\r\n    }\r\n    case 'built':\r\n    case 'sync': {\r\n      clearOutdatedErrors()\r\n      if (obj.hash) {\r\n        handleAvailableHash(obj.hash)\r\n      }\r\n      if (obj.warnings.length > 0) {\r\n        handleWarnings(obj.warnings)\r\n      }\r\n      if (obj.errors.length > 0) {\r\n        if (obj.action === 'sync') {\r\n          hadRuntimeError = true\r\n        }\r\n        handleErrors(obj.errors)\r\n        break\r\n      }\r\n      handleSuccess()\r\n      break\r\n    }\r\n    default: {\r\n      if (customHmrEventHandler) {\r\n        customHmrEventHandler(obj)\r\n        break\r\n      }\r\n      break\r\n    }\r\n  }\r\n}\r\n\r\n\/*This method is used to","code-length":225,"reference":"Handle messages from the server.","result":"Handle the case where the event handler is not yet implemented.","score":[0.1164,0.1786]}
{"code":"async function tryApplyUpdates (onHotUpdateSuccess) {\r\n  if (!module.hot) {\r\n    console.error('HotModuleReplacementPlugin is not in Webpack configuration.')\r\n    return\r\n  }\r\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\r\n    return\r\n  }\r\n  function handleApplyUpdates (err, updatedModules) {\r\n    if (err || hadRuntimeError) {\r\n      if (err) {\r\n        console.warn('Error while applying updates, reloading page', err)\r\n      }\r\n      if (hadRuntimeError) {\r\n        console.warn('Had runtime error previously, reloading page')\r\n      }\r\n      window.location.reload()\r\n      return\r\n    }\r\n    if (typeof onHotUpdateSuccess === 'function') {\r\n      onHotUpdateSuccess()\r\n    }\r\n    if (isUpdateAvailable()) {\r\n      tryApplyUpdates()\r\n    }\r\n  }\r\n( {\r\n      ignoreUnaccepted: true\r\n    })\r\n    if (updatedModules) {\r\n      handleApplyUpdates(null, updatedModules)\r\n    }\r\n  } catch (err) {\r\n    handleApplyUpdates(err, null)\r\n  }\r\n}\r\n\r\n\/*This method is used to","code-length":237,"reference":"Attempt to update code on the fly, fall back to a hard reload.","result":"Handle the case where the hot module is not available .","score":[0.0816,0.0391]}
{"code":"async function tryApplyUpdates () {\r\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\r\n    return\r\n  }\r\n  try {\r\n    const res = await fetch(`${hotUpdatePath}${curHash}.hot-update.json`)\r\n    const data = await res.json()\r\n    const curPage = page === '\/' ? 'index' : page\r\n    const pageUpdated = Object.keys(data.c)\r\n      .some(mod => {\r\n        return (\r\n          mod.indexOf(`pages${curPage.substr(0, 1) === '\/' ? curPage : `\/${curPage}`}`) !== -1 ||\r\n          mod.indexOf(`pages${curPage.substr(0, 1) === '\/' ? curPage : `\/${curPage}`}`.replace(\/\\\r\n        )\r\n      })\r\n    if (pageUpdated) {\r\n      document.location.reload(true)\r\n    } else {\r\n      curHash = mostRecentHash\r\n    }\r\n  } catch (err) {\r\n    console.error('Error occurred checking for update', err)\r\n    document.location.reload(true)\r\n  }\r\n}\r\n\r\n\/*This method is used to","code-length":242,"reference":"This function reads code updates on the fly and hard reloads the page when it has changed.","result":"Update the hot-update.","score":[0.0038,0.0641]}
{"code":"function formatMessage (message, isError) {\r\n  let lines = message.split('\\n')\r\nt(line))\r\n  lines = lines.map(line => {\r\n    const parsingError = \/Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$\/.exec(\r\n      line\r\n    )\r\n    if (!parsingError) {\r\n      return line\r\n    }\r\n    const [, errorLine, errorColumn, errorMessage] = parsingError\r\n    return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`\r\n  })\r\n  message = lines.join('\\n')\r\n  message = message.replace(\r\n    \/SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n\/g,\r\n    `${friendlySyntaxErrorLabel} $3 ($1:$2)\\n`\r\n  )\r\n  message = message.replace(\/Line (\\d+):\\d+:\/g, 'Line $1:')\r\n  message = message.replace(\r\n    \/^.*export '(.+?)' was not found in '(.+?)'.*$\/gm,\r\n    `Attempted import error: '$1' is not exported from '$2'.`\r\n  )\r\n  message = message.replace(\r\n    \/^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$\/gm,\r\n    `Attempted import error: '$2' does not contain a default export (imported as '$1').`\r\n  )\r\n  message = message.replace(\r\n    \/^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$\/gm,\r\n    `Attempted import error: '$1' is not exported from '$3' (imported as '$2').`\r\n  )\r\n  lines = message.split('\\n')\r\n  if (lines.length > 2 && lines[1].trim() === '') {\r\n    lines.splice(1, 1)\r\n  }\r\n  lines[0] = lines[0].replace(\/^(.*) \\d+:\\d+-\\d+$\/, '$1')\r\n  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {\r\n    lines = [\r\n      lines[0],\r\n      lines[1]\r\n        .replace('Error: ', '')\r\n        .replace('Module not found: Cannot find file:', 'Cannot find file:')\r\n    ]\r\n  }\r\n  message = lines.join('\\n')\r\nebpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)\/gm,\r\n    ''\r\n  )\r\n  message = message.replace(\/^\\s*at\\s<anonymous>(\\n|$)\/gm, '')\r\n  lines = message.split('\\n')\r\n  lines = lines.filter(\r\n    (line, index, arr) =>\r\n      index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim()\r\n  )\r\n  message = lines.join('\\n')\r\n  return message.trim()\r\n}\r\n\r\n\/*This method is used to","code-length":646,"reference":"Cleans up webpack error messages. eslint-disable-next-line no-unused-vars","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"function UDecimalPad(num, precision) {\r\n    var value = UDecimalString(num);\r\n    assert.equal(\"number\", typeof precision === 'undefined' ? 'undefined' : (0, _typeof3.default)(precision), \"precision\");\r\n    var part = value.split(\".\");\r\n    if (precision === 0 && part.length === 1) {\r\n        return part[0];\r\n    }\r\n    if (part.length === 1) {\r\n        return part[0] + '.' + \"0\".repeat(precision);\r\n    } else {\r\n        var pad = precision - part[1].length;\r\n        assert(pad >= 0, 'decimal \\'' + value + '\\' exceeds precision ' + precision);\r\n        return part[0] + '.' + part[1] + \"0\".repeat(pad);\r\n    }\r\n}\r\n\r\n\/*This method is used to","code-length":181,"reference":"Ensure a fixed number of decimal places.","result":"Convert a number to a string .","score":[0.1921,0.1429]}
{"code":"function parseSegment(buffer, offset) {\r\n    let typeKey = buffer[offset];\r\n    if (typeKey <= 20) {\r\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: No value for uint8\");\r\n        return { typeKey: typeKey, value: buffer[offset + 1], bufferLength: 2 };\r\n    }\r\n    if (typeKey <= 40) {\r\n        if (buffer[offset + 2] == undefined) throw new Error(\"ParseError: Incomplete value for uint16\");\r\n        return { typeKey: typeKey, value: buffer.readUInt16BE(offset + 1), bufferLength: 3 };\r\n    }\r\n    else if (typeKey <= 90) {\r\n        if (buffer[offset + 4] == undefined) throw new Error(\"ParseError: Incomplete value for uint32\");\r\n        return { typeKey: typeKey, value: buffer.readUInt32BE(offset + 1), bufferLength: 5 };\r\n    }\r\n    else if (typeKey <= 155) {\r\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for string\");\r\n        let len = buffer.readUInt8(offset + 1);\r\n        if (buffer[offset + 1 + len] == undefined) throw new Error(\"ParseError: Incomplete value for string\");\r\n        let value = buffer.toString(\"utf8\", offset + 2, offset + 2 + len);\r\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\r\n    }\r\n    else if (typeKey <= 165) {\r\n        if (buffer[offset + 16] == undefined) throw new Error(\"ParseError: Incomplete value for uuid\");\r\n        let len = 16;\r\n        let value = new Buffer(len);\r\n        buffer.copy(value, 0, offset + 1, offset + 1 + len);\r\n        return { typeKey: typeKey, value: value, bufferLength: 1 + len };\r\n    }\r\n    else if (typeKey <= 180) {\r\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for byte string\");\r\n        let len = buffer.readUInt8(offset + 1);\r\n        if (buffer[offset + len + 1] == undefined) throw new Error(\"ParseError: Incomplete value for byte string\");\r\n        let value = new Buffer(len);\r\n        buffer.copy(value, 0, offset + 2, offset + 2 + len);\r\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\r\n    }\r\n    else {\r\n        throw new Error(\"typeKey not supported\");\r\n    }\r\n}\r\n\r\n\/*This method is used to","code-length":563,"reference":"Parse a segment and convert it into json.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"function parseSegments(buffer) {\r\n    if (buffer.length == 0) throw new Error(\"bad segments stream\");\r\n    let pointer = 0;\r\n    let segments = [ ];\r\n    while (pointer < buffer.length) {\r\n        let seg = parseSegment(buffer, pointer);\r\n        segments.push(seg);\r\n        pointer += seg.bufferLength;\r\n        delete seg.bufferLength;\r\n    }\r\n    if (pointer != buffer.length) {\r\n        throw new Error(\"Bad \/ incomplete segments\");\r\n    }\r\n    return segments;\r\n}\r\n\r\n\/*This method is used to","code-length":119,"reference":"Parse a buffer to a array of segments","result":"Parse a single segment of a file .","score":[0.2336,0.465]}
{"code":"function parseQRCode(text, options) {\r\n    if (text.length < 3 || text.length > 2000) throw new Error(\"Invalid length of EvtLink\");\r\n    let textSplited = text.split(\"_\");\r\n    if (textSplited.length > 2) return null;\r\n    let rawText;\r\n    if (textSplited[0].startsWith(qrPrefix)) {\r\n        rawText = textSplited[0].substr(qrPrefix.length);\r\n    }\r\n    else {\r\n        rawText = textSplited[0];\r\n    }\r\n        let segmentsBytes = EvtLink.dec2b(rawText);\r\n    if (segmentsBytes.length < 2) throw new Error(\"no flag in segment\");\r\n    let flag = segmentsBytes.readInt16BE(0);\r\n        if ((flag & 1) == 0) {\r\n        throw new Error(\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\");\r\n    }\r\n    let segmentsBytesRaw = new Buffer(segmentsBytes.length - 2);\r\n    segmentsBytes.copy(segmentsBytesRaw, 0, 2, segmentsBytes.length);\r\n    let publicKeys = [ ];\r\n    let signatures = [ ];\r\n    if (textSplited[1]) {\r\n        let buf = EvtLink.dec2b(textSplited[1]);\r\n        let i = 0;\r\n        if (buf.length % 65 !== 0) {\r\n            throw new Error(\"length of signature is invalid\");\r\n        }\r\n        while (i * 65 < buf.length) {\r\n            let current = new Buffer(65);\r\n            buf.copy(current, 0, i * 65, i * 65 + 65);\r\n            let signature = ecc.Signature.fromBuffer(current);\r\n            signatures.push(signature.toString());\r\n            if (!options || options.recoverPublicKeys) {\r\n                publicKeys.push(signature.recover(segmentsBytes).toString());\r\n            }\r\n            ++i;\r\n        }\r\n    }\r\n    return { flag, segments: parseSegments(segmentsBytesRaw), publicKeys, signatures };\r\n}\r\n\r\n\/*This method is used to","code-length":453,"reference":"Parse a everiToken's QRCode Text","result":"Parse the EvtLink and return the corresponding public keys .","score":[0.1086,0.0909]}
{"code":"async function __calcKeyProvider(keyProvider) {\r\n    if (!keyProvider) { return []; }\r\n    if (keyProvider.apply && keyProvider.call) {\r\n        keyProvider = keyProvider();\r\n    }\r\n    keyProvider = await Promise.resolve(keyProvider);\r\n    if (!Array.isArray(keyProvider)) {\r\n        keyProvider = [ keyProvider ];\r\n    }\r\n    for (let key of keyProvider) {\r\n        if (!EvtKey.isValidPrivateKey(key)) {\r\n            throw new Error(\"Invalid private key\");\r\n        }\r\n    }\r\n    return keyProvider;\r\n}\r\n\r\n\/*This method is used to","code-length":132,"reference":"Calculate the value of keyProvider","result":"Generate the key pair for the given key .","score":[0.1219,0.0926]}
{"code":"function random32ByteBuffer({cpuEntropyBits = 0, safe = true} = {}) {\r\n    assert.equal(typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\");\r\n    assert.equal(typeof safe, \"boolean\", \"boolean\");\r\n    if(safe) {\r\n        assert(entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\");\r\n    }\r\n    const hash_array = [];\r\n    hash_array.push(randomBytes(32));\r\n    hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\r\n    hash_array.push(externalEntropyArray);\r\n    hash_array.push(browserEntropy());\r\n    return hash.sha256(Buffer.concat(hash_array));\r\n}\r\n\r\n\/*This method is used to","code-length":169,"reference":"Additional forms of entropy are used.","result":"Generate a random number of bytes from a given string .","score":[0.0979,0.0769]}
{"code":"function addEntropy(...ints) {\r\n    assert.equal(externalEntropyArray.length, 101, \"externalEntropyArray\");\r\n    entropyCount += ints.length;\r\n    for(const i of ints) {\r\n        const pos = entropyPos++ % 101;\r\n        const i2 = externalEntropyArray[pos] += i;\r\n        if(i2 > 9007199254740991)\r\n            externalEntropyArray[pos] = 0;\r\n    }\r\n}\r\n\r\n\/*This method is used to","code-length":102,"reference":"Adds entropy.","result":"Compute the entropy of a given integer .","score":[0,0.0]}
{"code":"function cpuEntropy(cpuEntropyBits = 128) {\r\n    let collected = [];\r\n    let lastCount = null;\r\n    let lowEntropySamples = 0;\r\n    while(collected.length < cpuEntropyBits) {\r\n        const count = floatingPointCount();\r\n        if(lastCount != null) {\r\n            const delta = count - lastCount;\r\n            if(Math.abs(delta) < 1) {\r\n                lowEntropySamples++;\r\n                continue;\r\n            }\r\n            const bits = Math.floor(log2(Math.abs(delta)) + 1);\r\n            if(bits < 4) {\r\n                if(bits < 2) {\r\n                    lowEntropySamples++;\r\n                }\r\n                continue;\r\n            }\r\n            collected.push(delta);\r\n        }\r\n        lastCount = count;\r\n    }\r\n    if(lowEntropySamples > 10) {\r\n        const pct = Number(lowEntropySamples \/ cpuEntropyBits * 100).toFixed(2);\r\n        console.warn(`WARN: ${pct}% low CPU entropy re-sampled`);\r\n    }\r\n    return collected;\r\n}\r\n\r\n\/*This method is used to","code-length":227,"reference":"This runs in just under 1 second and ensures a minimum of cpuEntropyBitsbits of entropy are gathered.","result":"Compute the average CPU entropy of a givenlist of integers* using the *cpuEntropyBits* argument.","score":[0.0863,0.1198]}
{"code":"function cryptoJsDecrypt(message, key, iv) {\r\n    assert(message, \"Missing cipher text\");\r\n    message = toBinaryBuffer(message);\r\n    const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\r\n    message = Buffer.concat([decipher.update(message), decipher.final()]);\r\n    return message;\r\n}\r\n\r\n\/*This method is used to","code-length":89,"reference":"This method does not use a checksum, the returned data must be validated some other way.","result":"Encrypt and decrypt messages.","score":[0,0.0]}
{"code":"function initialize() {\r\n    if(initialized) {\r\n        return;\r\n    }\r\n    unitTest();\r\n    keyUtils.addEntropy(...keyUtils.cpuEntropy());\r\n    assert(keyUtils.entropyCount() >= 128, \"insufficient entropy\");\r\n    initialized = true;\r\n}\r\n\r\n\/*This method is used to","code-length":65,"reference":"Run self-checking code and gather CPU entropy.","result":"Test the keyUtils.","score":[0,0.0758]}
{"code":"function montConvert(x) {\r\n  var r = new BigInteger()\r\n  x.abs()\r\n    .dlShiftTo(this.m.t, r)\r\n  r.divRemTo(this.m, null, r)\r\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)\r\n  return r\r\n}\r\n\r\n\/*This method is used to","code-length":98,"reference":"xR mod m","result":"Convert a BigInteger to a Python int .","score":[0,0.0]}
{"code":"function verify(data, pubkey, encoding = \"utf8\") {\r\n        if (typeof data === \"string\") {\r\n            data = Buffer.from(data, encoding);\r\n        }\r\n        assert(Buffer.isBuffer(data), \"data is a required String or Buffer\");\r\n        data = hash.sha256(data);\r\n        return verifyHash(data, pubkey);\r\n    }\r\n\r\n\/*This method is used to","code-length":85,"reference":"Verify signed data.","result":"Verify the signature of a given string .","score":[0.1389,0.1429]}
{"code":"function recover(data, encoding = \"utf8\") {\r\n        if (typeof data === \"string\") {\r\n            data = Buffer.from(data, encoding);\r\n        }\r\n        assert(Buffer.isBuffer(data), \"data is a required String or Buffer\");\r\n        data = hash.sha256(data);\r\n        return recoverHash(data);\r\n    }\r\n\r\n\/*This method is used to","code-length":81,"reference":"Recover the public key used to create this signature using full data.","result":"Recover the data of a given type .","score":[0.1191,0.1616]}
{"code":"function invokeWith(msg) {\r\n\t\r\n\tprint('Finding comments in ' + msg.getRequestHeader().getURI().toString()); \r\n\tvar body = msg.getResponseBody().toString()\r\n\t\r\n\tif (body.indexOf('<!--') > 0) {\r\n\t\tvar o = body.indexOf('<!--');\r\n\t\twhile (o > 0) {\r\n\t\t\tvar e = body.indexOf('-->', o);\r\n\t\t\tprint(\"\\t\" + body.substr(o,e-o+3)) \r\n\t\t\to = body.indexOf('<!--', e);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\/*This method is used to","code-length":136,"reference":"Targeted scripts can only be invoked by you, the user, eg via a right-click option on the Sites or History tabs","result":"Find the end of a comment .","score":[0.026,0.051]}
{"code":"function FormGroup(props) {\r\n  const { children, className, grouped, inline, unstackable, widths } = props\r\n  const classes = cx(\r\n    useKeyOnly(grouped, 'grouped'),\r\n    useKeyOnly(inline, 'inline'),\r\n    useKeyOnly(unstackable, 'unstackable'),\r\n    useWidthProp(widths, null, true),\r\n    'fields',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(FormGroup, props)\r\n  const ElementType = getElementType(FormGroup, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":155,"reference":"A set of fields can appear grouped together.","result":"Create a new form group.","score":[0,0.0649]}
{"code":"function Loader(props) {\r\n  const {\r\n    active,\r\n    children,\r\n    className,\r\n    content,\r\n    disabled,\r\n    indeterminate,\r\n    inline,\r\n    inverted,\r\n    size,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    size,\r\n    useKeyOnly(active, 'active'),\r\n    useKeyOnly(disabled, 'disabled'),\r\n    useKeyOnly(indeterminate, 'indeterminate'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(children || content, 'text'),\r\n    useKeyOrValueAndKey(inline, 'inline'),\r\n    'loader',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Loader, props)\r\n  const ElementType = getElementType(Loader, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":211,"reference":"A loader alerts a user to wait for an activity to complete.","result":"Create a new element type.","score":[0.0593,0.0442]}
{"code":"function ItemContent(props) {\r\n  const { children, className, content, description, extra, header, meta, verticalAlign } = props\r\n  const classes = cx(useVerticalAlignProp(verticalAlign), 'content', className)\r\n  const rest = getUnhandledProps(ItemContent, props)\r\n  const ElementType = getElementType(ItemContent, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {ItemHeader.create(header, { autoGenerateKey: false })}\r\n      {ItemMeta.create(meta, { autoGenerateKey: false })}\r\n      {ItemDescription.create(description, { autoGenerateKey: false })}\r\n      {ItemExtra.create(extra, { autoGenerateKey: false })}\r\n      {content}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":228,"reference":"An item can contain content.","result":"Generate the code for the generated code.","score":[0,0.0]}
{"code":"function Table(props) {\r\n  const {\r\n    attached,\r\n    basic,\r\n    celled,\r\n    children,\r\n    className,\r\n    collapsing,\r\n    color,\r\n    columns,\r\n    compact,\r\n    definition,\r\n    fixed,\r\n    footerRow,\r\n    headerRow,\r\n    headerRows,\r\n    inverted,\r\n    padded,\r\n    renderBodyRow,\r\n    selectable,\r\n    singleLine,\r\n    size,\r\n    sortable,\r\n    stackable,\r\n    striped,\r\n    structured,\r\n    tableData,\r\n    textAlign,\r\n    unstackable,\r\n    verticalAlign,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    color,\r\n    size,\r\n    useKeyOnly(celled, 'celled'),\r\n    useKeyOnly(collapsing, 'collapsing'),\r\n    useKeyOnly(definition, 'definition'),\r\n    useKeyOnly(fixed, 'fixed'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(selectable, 'selectable'),\r\n    useKeyOnly(singleLine, 'single line'),\r\n    useKeyOnly(sortable, 'sortable'),\r\n    useKeyOnly(stackable, 'stackable'),\r\n    useKeyOnly(striped, 'striped'),\r\n    useKeyOnly(structured, 'structured'),\r\n    useKeyOnly(unstackable, 'unstackable'),\r\n    useKeyOrValueAndKey(attached, 'attached'),\r\n    useKeyOrValueAndKey(basic, 'basic'),\r\n    useKeyOrValueAndKey(compact, 'compact'),\r\n    useKeyOrValueAndKey(padded, 'padded'),\r\n    useTextAlignProp(textAlign),\r\n    useVerticalAlignProp(verticalAlign),\r\n    useWidthProp(columns, 'column'),\r\n    'table',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Table, props)\r\n  const ElementType = getElementType(Table, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const hasHeaderRows = headerRow || headerRows\r\n  const headerShorthandOptions = { defaultProps: { cellAs: 'th' } }\r\n  const headerElement = hasHeaderRows && (\r\n    <TableHeader>\r\n      {TableRow.create(headerRow, headerShorthandOptions)}\r\n      {_.map(headerRows, (data) => TableRow.create(data, headerShorthandOptions))}\r\n    <\/TableHeader>\r\n  )\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {headerElement}\r\n      <TableBody>\r\n        {renderBodyRow &&\r\n          _.map(tableData, (data, index) => TableRow.create(renderBodyRow(data, index)))}\r\n      <\/TableBody>\r\n      {footerRow && <TableFooter>{TableRow.create(footerRow)}<\/TableFooter>}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":629,"reference":"A table displays a collections of data grouped into rows.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"function Rail(props) {\r\n  const {\r\n    attached,\r\n    children,\r\n    className,\r\n    close,\r\n    content,\r\n    dividing,\r\n    internal,\r\n    position,\r\n    size,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    position,\r\n    size,\r\n    useKeyOnly(attached, 'attached'),\r\n    useKeyOnly(dividing, 'dividing'),\r\n    useKeyOnly(internal, 'internal'),\r\n    useKeyOrValueAndKey(close, 'close'),\r\n    'rail',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Rail, props)\r\n  const ElementType = getElementType(Rail, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":194,"reference":"A rail is used to show accompanying content outside the boundaries of the main view of a site.","result":"Create a new element type.","score":[0.0178,0.0299]}
{"code":"function ButtonGroup(props) {\r\n  const {\r\n    attached,\r\n    basic,\r\n    buttons,\r\n    children,\r\n    className,\r\n    color,\r\n    compact,\r\n    content,\r\n    floated,\r\n    fluid,\r\n    icon,\r\n    inverted,\r\n    labeled,\r\n    negative,\r\n    positive,\r\n    primary,\r\n    secondary,\r\n    size,\r\n    toggle,\r\n    vertical,\r\n    widths,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    color,\r\n    size,\r\n    useKeyOnly(basic, 'basic'),\r\n    useKeyOnly(compact, 'compact'),\r\n    useKeyOnly(fluid, 'fluid'),\r\n    useKeyOnly(icon, 'icon'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(labeled, 'labeled'),\r\n    useKeyOnly(negative, 'negative'),\r\n    useKeyOnly(positive, 'positive'),\r\n    useKeyOnly(primary, 'primary'),\r\n    useKeyOnly(secondary, 'secondary'),\r\n    useKeyOnly(toggle, 'toggle'),\r\n    useKeyOnly(vertical, 'vertical'),\r\n    useKeyOrValueAndKey(attached, 'attached'),\r\n    useValueAndKey(floated, 'floated'),\r\n    useWidthProp(widths),\r\n    'buttons',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(ButtonGroup, props)\r\n  const ElementType = getElementType(ButtonGroup, props)\r\n  if (_.isNil(buttons)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {childrenUtils.isNil(children) ? content : children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {_.map(buttons, button => Button.create(button))}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":391,"reference":"Buttons can be grouped.","result":"Create a button group with a single child.","score":[0,0.1136]}
{"code":"function GridRow(props) {\r\n  const {\r\n    centered,\r\n    children,\r\n    className,\r\n    color,\r\n    columns,\r\n    divided,\r\n    only,\r\n    reversed,\r\n    stretched,\r\n    textAlign,\r\n    verticalAlign,\r\n  } = props\r\n  const classes = cx(\r\n    color,\r\n    useKeyOnly(centered, 'centered'),\r\n    useKeyOnly(divided, 'divided'),\r\n    useKeyOnly(stretched, 'stretched'),\r\n    useMultipleProp(only, 'only'),\r\n    useMultipleProp(reversed, 'reversed'),\r\n    useTextAlignProp(textAlign),\r\n    useVerticalAlignProp(verticalAlign),\r\n    useWidthProp(columns, 'column', true),\r\n    'row',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(GridRow, props)\r\n  const ElementType = getElementType(GridRow, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":224,"reference":"A row sub-component for Grid.","result":"Create a grid of cells.","score":[0,0.1]}
{"code":"function FormField(props) {\r\n  const {\r\n    children,\r\n    className,\r\n    content,\r\n    control,\r\n    disabled,\r\n    error,\r\n    inline,\r\n    label,\r\n    required,\r\n    type,\r\n    width,\r\n  } = props\r\n  const classes = cx(\r\n    useKeyOnly(disabled, 'disabled'),\r\n    useKeyOnly(error, 'error'),\r\n    useKeyOnly(inline, 'inline'),\r\n    useKeyOnly(required, 'required'),\r\n    useWidthProp(width, 'wide'),\r\n    'field',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(FormField, props)\r\n  const ElementType = getElementType(FormField, props)\r\n  if (_.isNil(control)) {\r\n    if (_.isNil(label)) {\r\n      return (\r\n        <ElementType {...rest} className={classes}>\r\n          {childrenUtils.isNil(children) ? content : children}\r\n        <\/ElementType>\r\n      )\r\n    }\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {createHTMLLabel(label, { autoGenerateKey: false })}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const controlProps = { ...rest, content, children, disabled, required, type }\r\n  if (control === 'input' && (type === 'checkbox' || type === 'radio')) {\r\n    return (\r\n      <ElementType className={classes}>\r\n        <label>\r\n          {createElement(control, controlProps)} {label}\r\n        <\/label>\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (control === Checkbox || control === Radio) {\r\n    return (\r\n      <ElementType className={classes}>\r\n        {createElement(control, { ...controlProps, label })}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType className={classes}>\r\n      {createHTMLLabel(label, {\r\n        defaultProps: { htmlFor: _.get(controlProps, 'id') },\r\n        autoGenerateKey: false,\r\n      })}\r\n      {createElement(control, controlProps)}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":458,"reference":"A field is a form element containing a label and an input.","result":"Generate the DOM tree for the given element.","score":[0,0.0]}
{"code":"function CardContent(props) {\r\n  const { children, className, content, description, extra, header, meta, textAlign } = props\r\n  const classes = cx(useKeyOnly(extra, 'extra'), useTextAlignProp(textAlign), 'content', className)\r\n  const rest = getUnhandledProps(CardContent, props)\r\n  const ElementType = getElementType(CardContent, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (!childrenUtils.isNil(content)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {content}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {createShorthand(CardHeader, val => ({ content: val }), header, { autoGenerateKey: false })}\r\n      {createShorthand(CardMeta, val => ({ content: val }), meta, { autoGenerateKey: false })}\r\n      {createShorthand(CardDescription, val => ({ content: val }), description, {\r\n        autoGenerateKey: false,\r\n      })}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":290,"reference":"A card can contain blocks of content or extra content meant to be formatted separately from the main content.","result":"Generate the content of a card.","score":[0.0291,0.113]}
{"code":"function Item(props) {\r\n  const { children, className, content, description, extra, header, image, meta } = props\r\n  const classes = cx('item', className)\r\n  const rest = getUnhandledProps(Item, props)\r\n  const ElementType = getElementType(Item, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {ItemImage.create(image, { autoGenerateKey: false })}\r\n      <ItemContent\r\n        content={content}\r\n        description={description}\r\n        extra={extra}\r\n        header={header}\r\n        meta={meta}\r\n      \/>\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":191,"reference":"An item view presents large collections of site content for display.","result":"Generate the item content.","score":[0.0555,0.0485]}
{"code":"function CommentAvatar(props) {\r\n  const { className, src } = props\r\n  const classes = cx('avatar', className)\r\n  const rest = getUnhandledProps(CommentAvatar, props)\r\n  const [imageProps, rootProps] = partitionHTMLProps(rest, { htmlProps: htmlImageProps })\r\n  const ElementType = getElementType(CommentAvatar, props)\r\n  return (\r\n    <ElementType {...rootProps} className={classes}>\r\n      {createHTMLImage(src, { autoGenerateKey: false, defaultProps: imageProps })}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":138,"reference":"A comment can contain an image or avatar.","result":"Generate the comment avatar for the given class.","score":[0.1389,0.0625]}
{"code":"function StatisticLabel(props) {\r\n  const { children, className, content } = props\r\n  const classes = cx('label', className)\r\n  const rest = getUnhandledProps(StatisticLabel, props)\r\n  const ElementType = getElementType(StatisticLabel, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":112,"reference":"A statistic can contain a label to help provide context for the presented value.","result":"Generate the code for the generated code.","score":[0.084,0.141]}
{"code":"function FeedMeta(props) {\r\n  const { children, className, content, like } = props\r\n  const classes = cx('meta', className)\r\n  const rest = getUnhandledProps(FeedMeta, props)\r\n  const ElementType = getElementType(FeedMeta, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {createShorthand(FeedLike, val => ({ content: val }), like, { autoGenerateKey: false })}\r\n      {content}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":168,"reference":"A feed can contain a meta.","result":"Generate the content of a feed.","score":[0.193,0.0833]}
{"code":"function Container(props) {\r\n  const { children, className, content, fluid, text, textAlign } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(text, 'text'),\r\n    useKeyOnly(fluid, 'fluid'),\r\n    useTextAlignProp(textAlign),\r\n    'container',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Container, props)\r\n  const ElementType = getElementType(Container, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":151,"reference":"A container limits content to a maximum width.","result":"Generate the code for the generated code.","score":[0,0.0]}
{"code":"function StepGroup(props) {\r\n  const {\r\n    attached,\r\n    children,\r\n    className,\r\n    content,\r\n    fluid,\r\n    items,\r\n    ordered,\r\n    size,\r\n    stackable,\r\n    unstackable,\r\n    vertical,\r\n    widths,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    size,\r\n    useKeyOnly(fluid, 'fluid'),\r\n    useKeyOnly(ordered, 'ordered'),\r\n    useKeyOnly(unstackable, 'unstackable'),\r\n    useKeyOnly(vertical, 'vertical'),\r\n    useKeyOrValueAndKey(attached, 'attached'),\r\n    useValueAndKey(stackable, 'stackable'),\r\n    useWidthProp(widths),\r\n    'steps',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(StepGroup, props)\r\n  const ElementType = getElementType(StepGroup, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (!childrenUtils.isNil(content)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {content}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {_.map(items, item => Step.create(item))}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":319,"reference":"A set of steps.","result":"Create a new step group.","score":[0,0.122]}
{"code":"function Divider(props) {\r\n  const {\r\n    children,\r\n    className,\r\n    clearing,\r\n    content,\r\n    fitted,\r\n    hidden,\r\n    horizontal,\r\n    inverted,\r\n    section,\r\n    vertical,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(clearing, 'clearing'),\r\n    useKeyOnly(fitted, 'fitted'),\r\n    useKeyOnly(hidden, 'hidden'),\r\n    useKeyOnly(horizontal, 'horizontal'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(section, 'section'),\r\n    useKeyOnly(vertical, 'vertical'),\r\n    'divider',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Divider, props)\r\n  const ElementType = getElementType(Divider, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":218,"reference":"A divider visually segments content into groups.","result":"Create a new element type.","score":[0,0.0735]}
{"code":"function Header(props) {\r\n  const {\r\n    attached,\r\n    block,\r\n    children,\r\n    className,\r\n    color,\r\n    content,\r\n    disabled,\r\n    dividing,\r\n    floated,\r\n    icon,\r\n    image,\r\n    inverted,\r\n    size,\r\n    sub,\r\n    subheader,\r\n    textAlign,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    color,\r\n    size,\r\n    useKeyOnly(block, 'block'),\r\n    useKeyOnly(disabled, 'disabled'),\r\n    useKeyOnly(dividing, 'dividing'),\r\n    useValueAndKey(floated, 'floated'),\r\n    useKeyOnly(icon === true, 'icon'),\r\n    useKeyOnly(image === true, 'image'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(sub, 'sub'),\r\n    useKeyOrValueAndKey(attached, 'attached'),\r\n    useTextAlignProp(textAlign),\r\n    'header',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Header, props)\r\n  const ElementType = getElementType(Header, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const iconElement = Icon.create(icon, { autoGenerateKey: false })\r\n  const imageElement = Image.create(image, { autoGenerateKey: false })\r\n  const subheaderElement = HeaderSubheader.create(subheader, { autoGenerateKey: false })\r\n  if (iconElement || imageElement) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {iconElement || imageElement}\r\n        {(content || subheaderElement) && (\r\n          <HeaderContent>\r\n            {content}\r\n            {subheaderElement}\r\n          <\/HeaderContent>\r\n        )}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {content}\r\n      {subheaderElement}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":454,"reference":"A header provides a short summary of content","result":"Generate the header for a class.","score":[0.1645,0.1282]}
{"code":"function Grid(props) {\r\n  const {\r\n    celled,\r\n    centered,\r\n    children,\r\n    className,\r\n    columns,\r\n    container,\r\n    divided,\r\n    doubling,\r\n    inverted,\r\n    padded,\r\n    relaxed,\r\n    reversed,\r\n    stackable,\r\n    stretched,\r\n    textAlign,\r\n    verticalAlign,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(centered, 'centered'),\r\n    useKeyOnly(container, 'container'),\r\n    useKeyOnly(doubling, 'doubling'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(stackable, 'stackable'),\r\n    useKeyOnly(stretched, 'stretched'),\r\n    useKeyOrValueAndKey(celled, 'celled'),\r\n    useKeyOrValueAndKey(divided, 'divided'),\r\n    useKeyOrValueAndKey(padded, 'padded'),\r\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\r\n    useMultipleProp(reversed, 'reversed'),\r\n    useTextAlignProp(textAlign),\r\n    useVerticalAlignProp(verticalAlign),\r\n    useWidthProp(columns, 'column', true),\r\n    'grid',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Grid, props)\r\n  const ElementType = getElementType(Grid, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":323,"reference":"A grid is used to harmonize negative space in a layout.","result":"Create a grid of properties.","score":[0.0861,0.0962]}
{"code":"function Breadcrumb(props) {\r\n  const { children, className, divider, icon, sections, size } = props\r\n  const classes = cx('ui', size, 'breadcrumb', className)\r\n  const rest = getUnhandledProps(Breadcrumb, props)\r\n  const ElementType = getElementType(Breadcrumb, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const childElements = []\r\n  _.each(sections, (section, index) => {\r\n    const breadcrumbElement = BreadcrumbSection.create(section)\r\n    childElements.push(breadcrumbElement)\r\n    if (index !== sections.length - 1) {\r\n      const key = `${breadcrumbElement.key}_divider` || JSON.stringify(section)\r\n      childElements.push(BreadcrumbDivider.create({ content: divider, icon, key }))\r\n    }\r\n  })\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childElements}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":269,"reference":"A breadcrumb is used to show hierarchy between content.","result":"Create a breadcrumb for a given class.","score":[0.1214,0.1136]}
{"code":"function CardDescription(props) {\r\n  const { children, className, content, textAlign } = props\r\n  const classes = cx(useTextAlignProp(textAlign), 'description', className)\r\n  const rest = getUnhandledProps(CardDescription, props)\r\n  const ElementType = getElementType(CardDescription, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":122,"reference":"A card can contain a description with one or more paragraphs.","result":"Generate the CardDescriptions.","score":[0,0.0]}
{"code":"function ItemGroup(props) {\r\n  const { children, className, content, divided, items, link, relaxed, unstackable } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(divided, 'divided'),\r\n    useKeyOnly(link, 'link'),\r\n    useKeyOnly(unstackable, 'unstackable'),\r\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\r\n    'items',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(ItemGroup, props)\r\n  const ElementType = getElementType(ItemGroup, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (!childrenUtils.isNil(content)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {content}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const itemsJSX = _.map(items, (item) => {\r\n    const { childKey, ...itemProps } = item\r\n    const finalKey =\r\n      childKey ||\r\n      [itemProps.content, itemProps.description, itemProps.header, itemProps.meta].join('-')\r\n    return <Item {...itemProps} key={finalKey} \/>\r\n  })\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {itemsJSX}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":336,"reference":"A group of items.","result":"Generate the code for the generated code.","score":[0,0.0]}
{"code":"function GridColumn(props) {\r\n  const {\r\n    children,\r\n    className,\r\n    computer,\r\n    color,\r\n    floated,\r\n    largeScreen,\r\n    mobile,\r\n    only,\r\n    stretched,\r\n    tablet,\r\n    textAlign,\r\n    verticalAlign,\r\n    widescreen,\r\n    width,\r\n  } = props\r\n  const classes = cx(\r\n    color,\r\n    useKeyOnly(stretched, 'stretched'),\r\n    useMultipleProp(only, 'only'),\r\n    useTextAlignProp(textAlign),\r\n    useValueAndKey(floated, 'floated'),\r\n    useVerticalAlignProp(verticalAlign),\r\n    useWidthProp(computer, 'wide computer'),\r\n    useWidthProp(largeScreen, 'wide large screen'),\r\n    useWidthProp(mobile, 'wide mobile'),\r\n    useWidthProp(tablet, 'wide tablet'),\r\n    useWidthProp(widescreen, 'wide widescreen'),\r\n    useWidthProp(width, 'wide'),\r\n    'column',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(GridColumn, props)\r\n  const ElementType = getElementType(GridColumn, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":275,"reference":"A column sub-component for Grid.","result":"Create a grid of cells.","score":[0,0.1]}
{"code":"function ItemImage(props) {\r\n  const { size } = props\r\n  const rest = getUnhandledProps(ItemImage, props)\r\n  return <Image {...rest} size={size} ui={!!size} wrapped \/>\r\n}\r\n\r\n\/*This method is used to","code-length":58,"reference":"An item can contain an image.","result":"Create a new image with the given properties.","score":[0,0.0]}
{"code":"function CardGroup(props) {\r\n  const {\r\n    centered,\r\n    children,\r\n    className,\r\n    content,\r\n    doubling,\r\n    items,\r\n    itemsPerRow,\r\n    stackable,\r\n    textAlign,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(centered, 'centered'),\r\n    useKeyOnly(doubling, 'doubling'),\r\n    useKeyOnly(stackable, 'stackable'),\r\n    useTextAlignProp(textAlign),\r\n    useWidthProp(itemsPerRow),\r\n    'cards',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(CardGroup, props)\r\n  const ElementType = getElementType(CardGroup, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (!childrenUtils.isNil(content)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {content}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const itemsJSX = _.map(items, (item) => {\r\n    const key = item.key || [item.header, item.description].join('-')\r\n    return <Card key={key} {...item} \/>\r\n  })\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {itemsJSX}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":328,"reference":"A group of cards.","result":"Generate the card group.","score":[0,0.0]}
{"code":"function TableRow(props) {\r\n  const {\r\n    active,\r\n    cellAs,\r\n    cells,\r\n    children,\r\n    className,\r\n    disabled,\r\n    error,\r\n    negative,\r\n    positive,\r\n    textAlign,\r\n    verticalAlign,\r\n    warning,\r\n  } = props\r\n  const classes = cx(\r\n    useKeyOnly(active, 'active'),\r\n    useKeyOnly(disabled, 'disabled'),\r\n    useKeyOnly(error, 'error'),\r\n    useKeyOnly(negative, 'negative'),\r\n    useKeyOnly(positive, 'positive'),\r\n    useKeyOnly(warning, 'warning'),\r\n    useTextAlignProp(textAlign),\r\n    useVerticalAlignProp(verticalAlign),\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(TableRow, props)\r\n  const ElementType = getElementType(TableRow, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {_.map(cells, cell => TableCell.create(cell, { defaultProps: { as: cellAs } }))}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":278,"reference":"A table can have rows.","result":"Create a table cell that is not yet created.","score":[0.1219,0.3472]}
{"code":"function createInstance(defaultConfig) {\r\n  var context = new Axios(defaultConfig);\r\n  var instance = bind(Axios.prototype.request, context);\r\n  utils.extend(instance, Axios.prototype, context);\r\n  utils.extend(instance, context);\r\n  return instance;\r\n}\r\n\r\n\/*This method is used to","code-length":75,"reference":"Create an instance of Axios","result":"Create a new instance of the Axios class.","score":[0.2336,0.5955]}
{"code":"function CancelToken(executor) {\r\n  if (typeof executor !== 'function') {\r\n    throw new TypeError('executor must be a function.');\r\n  }\r\n  var resolvePromise;\r\n  this.promise = new Promise(function promiseExecutor(resolve) {\r\n    resolvePromise = resolve;\r\n  });\r\n  var token = this;\r\n  executor(function cancel(message) {\r\n    if (token.reason) {\r\n      return;\r\n    }\r\n    token.reason = new Cancel(message);\r\n    resolvePromise(token.reason);\r\n  });\r\n}\r\n\r\n\/*This method is used to","code-length":124,"reference":"A `CancelToken` is an object that can be used to request cancellation of an operation.","result":"Create a new Promise object.","score":[0,0.0357]}
{"code":"function isArrayBufferView(val) {\r\n  var result;\r\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\r\n    result = ArrayBuffer.isView(val);\r\n  } else {\r\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\r\n  }\r\n  return result;\r\n}\r\n\r\n\/*This method is used to","code-length":87,"reference":"Determine if a value is a view on an ArrayBuffer","result":"Convert a string to a number.","score":[0.1179,0.1042]}
{"code":"function isStandardBrowserEnv() {\r\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\r\n                                           navigator.product === 'NativeScript' ||\r\n                                           navigator.product === 'NS')) {\r\n    return false;\r\n  }\r\n  return (\r\n    typeof window !== 'undefined' &&\r\n    typeof document !== 'undefined'\r\n  );\r\n}\r\n\r\n\/*This method is used to","code-length":95,"reference":"Determine if we're running in a standard browser environment","result":"Get the current page .","score":[0,0.0]}
{"code":"function forEach(obj, fn) {\r\n  if (obj === null || typeof obj === 'undefined') {\r\n    return;\r\n  }\r\n  if (typeof obj !== 'object') {\r\n        obj = [obj];\r\n  }\r\n  if (isArray(obj)) {\r\n    for (var i = 0, l = obj.length; i < l; i++) {\r\n      fn.call(null, obj[i], i, obj);\r\n    }\r\n  } else {\r\n    for (var key in obj) {\r\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        fn.call(null, obj[key], key, obj);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\/*This method is used to","code-length":158,"reference":"Iterate over an Array or an Object invoking a function for each item.","result":"Convert a property value to a string .","score":[0.0743,0.04]}
{"code":"function extend(a, b, thisArg) {\r\n  forEach(b, function assignValue(val, key) {\r\n    if (thisArg && typeof val === 'function') {\r\n      a[key] = bind(val, thisArg);\r\n    } else {\r\n      a[key] = val;\r\n    }\r\n  });\r\n  return a;\r\n}\r\n\r\n\/*This method is used to","code-length":85,"reference":"Extends object a by mutably adding to it the properties of object b.","result":"Wrap the function in a function that is calledbefore* the function is called.","score":[0.0973,0.0769]}
{"code":"function writePackageManifest (packageName) {\r\n  const packagePath = require.resolve(packageName + '\/package.json')\r\n  let { name, main, author, license, types, typings } = require(packagePath)\r\n  if (!main) {\r\n    main = 'index.js'\r\n  }\r\n  let typesFile = types || typings\r\n  if (typesFile) {\r\n    typesFile = require.resolve(join(packageName, typesFile))\r\n  }\r\n  const compiledPackagePath = join(__dirname, `dist\/compiled\/${packageName}`)\r\n  const potentialLicensePath = join(dirname(packagePath), '.\/LICENSE')\r\n  if (existsSync(potentialLicensePath)) {\r\n    this._.files.push({\r\n      dir: compiledPackagePath,\r\n      base: 'LICENSE',\r\n      data: readFileSync(potentialLicensePath, 'utf8')\r\n    })\r\n  }\r\n  this._.files.push({\r\n    dir: compiledPackagePath,\r\n    base: 'package.json',\r\n    data:\r\n      JSON.stringify(\r\n        Object.assign(\r\n          {},\r\n          { name, main: `${basename(main, '.' + extname(main))}` },\r\n          author ? { author } : undefined,\r\n          license ? { license } : undefined,\r\n          typesFile\r\n            ? {\r\n              types: relative(compiledPackagePath, typesFile)\r\n            }\r\n            : undefined\r\n        )\r\n      ) + '\\n'\r\n  })\r\n}\r\n\r\n\/*This method is used to","code-length":307,"reference":"This function writes a minimal `package.json` file for a compiled package. It defines `name`, `main`, `author`, and `license`. It also defines `types`. n.b. types intended for development usage only.","result":"Generate the package.","score":[0.0001,0.0189]}
{"code":"function processMessage (e) {\r\n  const obj = JSON.parse(e.data)\r\n  switch (obj.action) {\r\n    case 'building': {\r\n      console.log(\r\n        '[HMR] bundle ' + (obj.name ? \"'\" + obj.name + \"' \" : '') +\r\n        'rebuilding'\r\n      )\r\n      break\r\n    }\r\n    case 'built':\r\n    case 'sync': {\r\n      clearOutdatedErrors()\r\n      if (obj.hash) {\r\n        handleAvailableHash(obj.hash)\r\n      }\r\n      if (obj.warnings.length > 0) {\r\n        handleWarnings(obj.warnings)\r\n      }\r\n      if (obj.errors.length > 0) {\r\n        if (obj.action === 'sync') {\r\n          hadRuntimeError = true\r\n        }\r\n        handleErrors(obj.errors)\r\n        break\r\n      }\r\n      handleSuccess()\r\n      break\r\n    }\r\n    default: {\r\n      if (customHmrEventHandler) {\r\n        customHmrEventHandler(obj)\r\n        break\r\n      }\r\n      break\r\n    }\r\n  }\r\n}\r\n\r\n\/*This method is used to","code-length":225,"reference":"Handle messages from the server.","result":"Handle the case where the event handler is not yet implemented.","score":[0.1164,0.1786]}
{"code":"async function tryApplyUpdates (onHotUpdateSuccess) {\r\n  if (!module.hot) {\r\n    console.error('HotModuleReplacementPlugin is not in Webpack configuration.')\r\n    return\r\n  }\r\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\r\n    return\r\n  }\r\n  function handleApplyUpdates (err, updatedModules) {\r\n    if (err || hadRuntimeError) {\r\n      if (err) {\r\n        console.warn('Error while applying updates, reloading page', err)\r\n      }\r\n      if (hadRuntimeError) {\r\n        console.warn('Had runtime error previously, reloading page')\r\n      }\r\n      window.location.reload()\r\n      return\r\n    }\r\n    if (typeof onHotUpdateSuccess === 'function') {\r\n      onHotUpdateSuccess()\r\n    }\r\n    if (isUpdateAvailable()) {\r\n      tryApplyUpdates()\r\n    }\r\n  }\r\n( {\r\n      ignoreUnaccepted: true\r\n    })\r\n    if (updatedModules) {\r\n      handleApplyUpdates(null, updatedModules)\r\n    }\r\n  } catch (err) {\r\n    handleApplyUpdates(err, null)\r\n  }\r\n}\r\n\r\n\/*This method is used to","code-length":237,"reference":"Attempt to update code on the fly, fall back to a hard reload.","result":"Handle the case where the hot module is not available .","score":[0.0816,0.0391]}
{"code":"async function tryApplyUpdates () {\r\n  if (!isUpdateAvailable() || !canApplyUpdates()) {\r\n    return\r\n  }\r\n  try {\r\n    const res = await fetch(`${hotUpdatePath}${curHash}.hot-update.json`)\r\n    const data = await res.json()\r\n    const curPage = page === '\/' ? 'index' : page\r\n    const pageUpdated = Object.keys(data.c)\r\n      .some(mod => {\r\n        return (\r\n          mod.indexOf(`pages${curPage.substr(0, 1) === '\/' ? curPage : `\/${curPage}`}`) !== -1 ||\r\n          mod.indexOf(`pages${curPage.substr(0, 1) === '\/' ? curPage : `\/${curPage}`}`.replace(\/\\\r\n        )\r\n      })\r\n    if (pageUpdated) {\r\n      document.location.reload(true)\r\n    } else {\r\n      curHash = mostRecentHash\r\n    }\r\n  } catch (err) {\r\n    console.error('Error occurred checking for update', err)\r\n    document.location.reload(true)\r\n  }\r\n}\r\n\r\n\/*This method is used to","code-length":242,"reference":"This function reads code updates on the fly and hard reloads the page when it has changed.","result":"Update the hot-update.","score":[0.0038,0.0641]}
{"code":"function formatMessage (message, isError) {\r\n  let lines = message.split('\\n')\r\nt(line))\r\n  lines = lines.map(line => {\r\n    const parsingError = \/Line (\\d+):(?:(\\d+):)?\\s*Parsing error: (.+)$\/.exec(\r\n      line\r\n    )\r\n    if (!parsingError) {\r\n      return line\r\n    }\r\n    const [, errorLine, errorColumn, errorMessage] = parsingError\r\n    return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`\r\n  })\r\n  message = lines.join('\\n')\r\n  message = message.replace(\r\n    \/SyntaxError\\s+\\((\\d+):(\\d+)\\)\\s*(.+?)\\n\/g,\r\n    `${friendlySyntaxErrorLabel} $3 ($1:$2)\\n`\r\n  )\r\n  message = message.replace(\/Line (\\d+):\\d+:\/g, 'Line $1:')\r\n  message = message.replace(\r\n    \/^.*export '(.+?)' was not found in '(.+?)'.*$\/gm,\r\n    `Attempted import error: '$1' is not exported from '$2'.`\r\n  )\r\n  message = message.replace(\r\n    \/^.*export 'default' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$\/gm,\r\n    `Attempted import error: '$2' does not contain a default export (imported as '$1').`\r\n  )\r\n  message = message.replace(\r\n    \/^.*export '(.+?)' \\(imported as '(.+?)'\\) was not found in '(.+?)'.*$\/gm,\r\n    `Attempted import error: '$1' is not exported from '$3' (imported as '$2').`\r\n  )\r\n  lines = message.split('\\n')\r\n  if (lines.length > 2 && lines[1].trim() === '') {\r\n    lines.splice(1, 1)\r\n  }\r\n  lines[0] = lines[0].replace(\/^(.*) \\d+:\\d+-\\d+$\/, '$1')\r\n  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {\r\n    lines = [\r\n      lines[0],\r\n      lines[1]\r\n        .replace('Error: ', '')\r\n        .replace('Module not found: Cannot find file:', 'Cannot find file:')\r\n    ]\r\n  }\r\n  message = lines.join('\\n')\r\nebpack:).)*:\\d+:\\d+[\\s)]*(\\n|$)\/gm,\r\n    ''\r\n  )\r\n  message = message.replace(\/^\\s*at\\s<anonymous>(\\n|$)\/gm, '')\r\n  lines = message.split('\\n')\r\n  lines = lines.filter(\r\n    (line, index, arr) =>\r\n      index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim()\r\n  )\r\n  message = lines.join('\\n')\r\n  return message.trim()\r\n}\r\n\r\n\/*This method is used to","code-length":646,"reference":"Cleans up webpack error messages. eslint-disable-next-line no-unused-vars","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"function UDecimalPad(num, precision) {\r\n    var value = UDecimalString(num);\r\n    assert.equal(\"number\", typeof precision === 'undefined' ? 'undefined' : (0, _typeof3.default)(precision), \"precision\");\r\n    var part = value.split(\".\");\r\n    if (precision === 0 && part.length === 1) {\r\n        return part[0];\r\n    }\r\n    if (part.length === 1) {\r\n        return part[0] + '.' + \"0\".repeat(precision);\r\n    } else {\r\n        var pad = precision - part[1].length;\r\n        assert(pad >= 0, 'decimal \\'' + value + '\\' exceeds precision ' + precision);\r\n        return part[0] + '.' + part[1] + \"0\".repeat(pad);\r\n    }\r\n}\r\n\r\n\/*This method is used to","code-length":181,"reference":"Ensure a fixed number of decimal places.","result":"Convert a number to a string .","score":[0.1921,0.1429]}
{"code":"function parseSegment(buffer, offset) {\r\n    let typeKey = buffer[offset];\r\n    if (typeKey <= 20) {\r\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: No value for uint8\");\r\n        return { typeKey: typeKey, value: buffer[offset + 1], bufferLength: 2 };\r\n    }\r\n    if (typeKey <= 40) {\r\n        if (buffer[offset + 2] == undefined) throw new Error(\"ParseError: Incomplete value for uint16\");\r\n        return { typeKey: typeKey, value: buffer.readUInt16BE(offset + 1), bufferLength: 3 };\r\n    }\r\n    else if (typeKey <= 90) {\r\n        if (buffer[offset + 4] == undefined) throw new Error(\"ParseError: Incomplete value for uint32\");\r\n        return { typeKey: typeKey, value: buffer.readUInt32BE(offset + 1), bufferLength: 5 };\r\n    }\r\n    else if (typeKey <= 155) {\r\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for string\");\r\n        let len = buffer.readUInt8(offset + 1);\r\n        if (buffer[offset + 1 + len] == undefined) throw new Error(\"ParseError: Incomplete value for string\");\r\n        let value = buffer.toString(\"utf8\", offset + 2, offset + 2 + len);\r\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\r\n    }\r\n    else if (typeKey <= 165) {\r\n        if (buffer[offset + 16] == undefined) throw new Error(\"ParseError: Incomplete value for uuid\");\r\n        let len = 16;\r\n        let value = new Buffer(len);\r\n        buffer.copy(value, 0, offset + 1, offset + 1 + len);\r\n        return { typeKey: typeKey, value: value, bufferLength: 1 + len };\r\n    }\r\n    else if (typeKey <= 180) {\r\n        if (buffer[offset + 1] == undefined) throw new Error(\"ParseError: Incomplete length value for byte string\");\r\n        let len = buffer.readUInt8(offset + 1);\r\n        if (buffer[offset + len + 1] == undefined) throw new Error(\"ParseError: Incomplete value for byte string\");\r\n        let value = new Buffer(len);\r\n        buffer.copy(value, 0, offset + 2, offset + 2 + len);\r\n        return { typeKey: typeKey, value: value, bufferLength: 2 + len };\r\n    }\r\n    else {\r\n        throw new Error(\"typeKey not supported\");\r\n    }\r\n}\r\n\r\n\/*This method is used to","code-length":563,"reference":"Parse a segment and convert it into json.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"function parseSegments(buffer) {\r\n    if (buffer.length == 0) throw new Error(\"bad segments stream\");\r\n    let pointer = 0;\r\n    let segments = [ ];\r\n    while (pointer < buffer.length) {\r\n        let seg = parseSegment(buffer, pointer);\r\n        segments.push(seg);\r\n        pointer += seg.bufferLength;\r\n        delete seg.bufferLength;\r\n    }\r\n    if (pointer != buffer.length) {\r\n        throw new Error(\"Bad \/ incomplete segments\");\r\n    }\r\n    return segments;\r\n}\r\n\r\n\/*This method is used to","code-length":119,"reference":"Parse a buffer to a array of segments","result":"Parse a single segment of a file .","score":[0.2336,0.465]}
{"code":"function parseQRCode(text, options) {\r\n    if (text.length < 3 || text.length > 2000) throw new Error(\"Invalid length of EvtLink\");\r\n    let textSplited = text.split(\"_\");\r\n    if (textSplited.length > 2) return null;\r\n    let rawText;\r\n    if (textSplited[0].startsWith(qrPrefix)) {\r\n        rawText = textSplited[0].substr(qrPrefix.length);\r\n    }\r\n    else {\r\n        rawText = textSplited[0];\r\n    }\r\n        let segmentsBytes = EvtLink.dec2b(rawText);\r\n    if (segmentsBytes.length < 2) throw new Error(\"no flag in segment\");\r\n    let flag = segmentsBytes.readInt16BE(0);\r\n        if ((flag & 1) == 0) {\r\n        throw new Error(\"The EvtLink is invalid or its version is newer than version 1 and is not supported by evtjs yet\");\r\n    }\r\n    let segmentsBytesRaw = new Buffer(segmentsBytes.length - 2);\r\n    segmentsBytes.copy(segmentsBytesRaw, 0, 2, segmentsBytes.length);\r\n    let publicKeys = [ ];\r\n    let signatures = [ ];\r\n    if (textSplited[1]) {\r\n        let buf = EvtLink.dec2b(textSplited[1]);\r\n        let i = 0;\r\n        if (buf.length % 65 !== 0) {\r\n            throw new Error(\"length of signature is invalid\");\r\n        }\r\n        while (i * 65 < buf.length) {\r\n            let current = new Buffer(65);\r\n            buf.copy(current, 0, i * 65, i * 65 + 65);\r\n            let signature = ecc.Signature.fromBuffer(current);\r\n            signatures.push(signature.toString());\r\n            if (!options || options.recoverPublicKeys) {\r\n                publicKeys.push(signature.recover(segmentsBytes).toString());\r\n            }\r\n            ++i;\r\n        }\r\n    }\r\n    return { flag, segments: parseSegments(segmentsBytesRaw), publicKeys, signatures };\r\n}\r\n\r\n\/*This method is used to","code-length":453,"reference":"Parse a everiToken's QRCode Text","result":"Parse the EvtLink and return the corresponding public keys .","score":[0.1086,0.0909]}
{"code":"async function __calcKeyProvider(keyProvider) {\r\n    if (!keyProvider) { return []; }\r\n    if (keyProvider.apply && keyProvider.call) {\r\n        keyProvider = keyProvider();\r\n    }\r\n    keyProvider = await Promise.resolve(keyProvider);\r\n    if (!Array.isArray(keyProvider)) {\r\n        keyProvider = [ keyProvider ];\r\n    }\r\n    for (let key of keyProvider) {\r\n        if (!EvtKey.isValidPrivateKey(key)) {\r\n            throw new Error(\"Invalid private key\");\r\n        }\r\n    }\r\n    return keyProvider;\r\n}\r\n\r\n\/*This method is used to","code-length":132,"reference":"Calculate the value of keyProvider","result":"Generate the key pair for the given key .","score":[0.1219,0.0926]}
{"code":"function random32ByteBuffer({cpuEntropyBits = 0, safe = true} = {}) {\r\n    assert.equal(typeof cpuEntropyBits, \"number\", \"cpuEntropyBits\");\r\n    assert.equal(typeof safe, \"boolean\", \"boolean\");\r\n    if(safe) {\r\n        assert(entropyCount >= 128, \"Call initialize() to add entropy (current: \" + entropyCount + \")\");\r\n    }\r\n    const hash_array = [];\r\n    hash_array.push(randomBytes(32));\r\n    hash_array.push(Buffer.from(cpuEntropy(cpuEntropyBits)));\r\n    hash_array.push(externalEntropyArray);\r\n    hash_array.push(browserEntropy());\r\n    return hash.sha256(Buffer.concat(hash_array));\r\n}\r\n\r\n\/*This method is used to","code-length":169,"reference":"Additional forms of entropy are used.","result":"Generate a random number of bytes from a given string .","score":[0.0979,0.0769]}
{"code":"function addEntropy(...ints) {\r\n    assert.equal(externalEntropyArray.length, 101, \"externalEntropyArray\");\r\n    entropyCount += ints.length;\r\n    for(const i of ints) {\r\n        const pos = entropyPos++ % 101;\r\n        const i2 = externalEntropyArray[pos] += i;\r\n        if(i2 > 9007199254740991)\r\n            externalEntropyArray[pos] = 0;\r\n    }\r\n}\r\n\r\n\/*This method is used to","code-length":102,"reference":"Adds entropy.","result":"Compute the entropy of a given integer .","score":[0,0.0]}
{"code":"function cpuEntropy(cpuEntropyBits = 128) {\r\n    let collected = [];\r\n    let lastCount = null;\r\n    let lowEntropySamples = 0;\r\n    while(collected.length < cpuEntropyBits) {\r\n        const count = floatingPointCount();\r\n        if(lastCount != null) {\r\n            const delta = count - lastCount;\r\n            if(Math.abs(delta) < 1) {\r\n                lowEntropySamples++;\r\n                continue;\r\n            }\r\n            const bits = Math.floor(log2(Math.abs(delta)) + 1);\r\n            if(bits < 4) {\r\n                if(bits < 2) {\r\n                    lowEntropySamples++;\r\n                }\r\n                continue;\r\n            }\r\n            collected.push(delta);\r\n        }\r\n        lastCount = count;\r\n    }\r\n    if(lowEntropySamples > 10) {\r\n        const pct = Number(lowEntropySamples \/ cpuEntropyBits * 100).toFixed(2);\r\n        console.warn(`WARN: ${pct}% low CPU entropy re-sampled`);\r\n    }\r\n    return collected;\r\n}\r\n\r\n\/*This method is used to","code-length":227,"reference":"This runs in just under 1 second and ensures a minimum of cpuEntropyBitsbits of entropy are gathered.","result":"Compute the average CPU entropy of a givenlist of integers* using the *cpuEntropyBits* argument.","score":[0.0863,0.1198]}
{"code":"function cryptoJsDecrypt(message, key, iv) {\r\n    assert(message, \"Missing cipher text\");\r\n    message = toBinaryBuffer(message);\r\n    const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\r\n    message = Buffer.concat([decipher.update(message), decipher.final()]);\r\n    return message;\r\n}\r\n\r\n\/*This method is used to","code-length":89,"reference":"This method does not use a checksum, the returned data must be validated some other way.","result":"Encrypt and decrypt messages.","score":[0,0.0]}
{"code":"function initialize() {\r\n    if(initialized) {\r\n        return;\r\n    }\r\n    unitTest();\r\n    keyUtils.addEntropy(...keyUtils.cpuEntropy());\r\n    assert(keyUtils.entropyCount() >= 128, \"insufficient entropy\");\r\n    initialized = true;\r\n}\r\n\r\n\/*This method is used to","code-length":65,"reference":"Run self-checking code and gather CPU entropy.","result":"Test the keyUtils.","score":[0,0.0758]}
{"code":"function montConvert(x) {\r\n  var r = new BigInteger()\r\n  x.abs()\r\n    .dlShiftTo(this.m.t, r)\r\n  r.divRemTo(this.m, null, r)\r\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)\r\n  return r\r\n}\r\n\r\n\/*This method is used to","code-length":98,"reference":"xR mod m","result":"Convert a BigInteger to a Python int .","score":[0,0.0]}
{"code":"function verify(data, pubkey, encoding = \"utf8\") {\r\n        if (typeof data === \"string\") {\r\n            data = Buffer.from(data, encoding);\r\n        }\r\n        assert(Buffer.isBuffer(data), \"data is a required String or Buffer\");\r\n        data = hash.sha256(data);\r\n        return verifyHash(data, pubkey);\r\n    }\r\n\r\n\/*This method is used to","code-length":85,"reference":"Verify signed data.","result":"Verify the signature of a given string .","score":[0.1389,0.1429]}
{"code":"function recover(data, encoding = \"utf8\") {\r\n        if (typeof data === \"string\") {\r\n            data = Buffer.from(data, encoding);\r\n        }\r\n        assert(Buffer.isBuffer(data), \"data is a required String or Buffer\");\r\n        data = hash.sha256(data);\r\n        return recoverHash(data);\r\n    }\r\n\r\n\/*This method is used to","code-length":81,"reference":"Recover the public key used to create this signature using full data.","result":"Recover the data of a given type .","score":[0.1191,0.1616]}
{"code":"function invokeWith(msg) {\r\n\t\r\n\tprint('Finding comments in ' + msg.getRequestHeader().getURI().toString()); \r\n\tvar body = msg.getResponseBody().toString()\r\n\t\r\n\tif (body.indexOf('<!--') > 0) {\r\n\t\tvar o = body.indexOf('<!--');\r\n\t\twhile (o > 0) {\r\n\t\t\tvar e = body.indexOf('-->', o);\r\n\t\t\tprint(\"\\t\" + body.substr(o,e-o+3)) \r\n\t\t\to = body.indexOf('<!--', e);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\/*This method is used to","code-length":136,"reference":"Targeted scripts can only be invoked by you, the user, eg via a right-click option on the Sites or History tabs","result":"Find the end of a comment .","score":[0.026,0.051]}
{"code":"function FormGroup(props) {\r\n  const { children, className, grouped, inline, unstackable, widths } = props\r\n  const classes = cx(\r\n    useKeyOnly(grouped, 'grouped'),\r\n    useKeyOnly(inline, 'inline'),\r\n    useKeyOnly(unstackable, 'unstackable'),\r\n    useWidthProp(widths, null, true),\r\n    'fields',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(FormGroup, props)\r\n  const ElementType = getElementType(FormGroup, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":155,"reference":"A set of fields can appear grouped together.","result":"Create a new form group.","score":[0,0.0649]}
{"code":"function Loader(props) {\r\n  const {\r\n    active,\r\n    children,\r\n    className,\r\n    content,\r\n    disabled,\r\n    indeterminate,\r\n    inline,\r\n    inverted,\r\n    size,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    size,\r\n    useKeyOnly(active, 'active'),\r\n    useKeyOnly(disabled, 'disabled'),\r\n    useKeyOnly(indeterminate, 'indeterminate'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(children || content, 'text'),\r\n    useKeyOrValueAndKey(inline, 'inline'),\r\n    'loader',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Loader, props)\r\n  const ElementType = getElementType(Loader, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":211,"reference":"A loader alerts a user to wait for an activity to complete.","result":"Create a new element type.","score":[0.0593,0.0442]}
{"code":"function ItemContent(props) {\r\n  const { children, className, content, description, extra, header, meta, verticalAlign } = props\r\n  const classes = cx(useVerticalAlignProp(verticalAlign), 'content', className)\r\n  const rest = getUnhandledProps(ItemContent, props)\r\n  const ElementType = getElementType(ItemContent, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {ItemHeader.create(header, { autoGenerateKey: false })}\r\n      {ItemMeta.create(meta, { autoGenerateKey: false })}\r\n      {ItemDescription.create(description, { autoGenerateKey: false })}\r\n      {ItemExtra.create(extra, { autoGenerateKey: false })}\r\n      {content}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":228,"reference":"An item can contain content.","result":"Generate the code for the generated code.","score":[0,0.0]}
{"code":"function Table(props) {\r\n  const {\r\n    attached,\r\n    basic,\r\n    celled,\r\n    children,\r\n    className,\r\n    collapsing,\r\n    color,\r\n    columns,\r\n    compact,\r\n    definition,\r\n    fixed,\r\n    footerRow,\r\n    headerRow,\r\n    headerRows,\r\n    inverted,\r\n    padded,\r\n    renderBodyRow,\r\n    selectable,\r\n    singleLine,\r\n    size,\r\n    sortable,\r\n    stackable,\r\n    striped,\r\n    structured,\r\n    tableData,\r\n    textAlign,\r\n    unstackable,\r\n    verticalAlign,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    color,\r\n    size,\r\n    useKeyOnly(celled, 'celled'),\r\n    useKeyOnly(collapsing, 'collapsing'),\r\n    useKeyOnly(definition, 'definition'),\r\n    useKeyOnly(fixed, 'fixed'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(selectable, 'selectable'),\r\n    useKeyOnly(singleLine, 'single line'),\r\n    useKeyOnly(sortable, 'sortable'),\r\n    useKeyOnly(stackable, 'stackable'),\r\n    useKeyOnly(striped, 'striped'),\r\n    useKeyOnly(structured, 'structured'),\r\n    useKeyOnly(unstackable, 'unstackable'),\r\n    useKeyOrValueAndKey(attached, 'attached'),\r\n    useKeyOrValueAndKey(basic, 'basic'),\r\n    useKeyOrValueAndKey(compact, 'compact'),\r\n    useKeyOrValueAndKey(padded, 'padded'),\r\n    useTextAlignProp(textAlign),\r\n    useVerticalAlignProp(verticalAlign),\r\n    useWidthProp(columns, 'column'),\r\n    'table',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Table, props)\r\n  const ElementType = getElementType(Table, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const hasHeaderRows = headerRow || headerRows\r\n  const headerShorthandOptions = { defaultProps: { cellAs: 'th' } }\r\n  const headerElement = hasHeaderRows && (\r\n    <TableHeader>\r\n      {TableRow.create(headerRow, headerShorthandOptions)}\r\n      {_.map(headerRows, (data) => TableRow.create(data, headerShorthandOptions))}\r\n    <\/TableHeader>\r\n  )\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {headerElement}\r\n      <TableBody>\r\n        {renderBodyRow &&\r\n          _.map(tableData, (data, index) => TableRow.create(renderBodyRow(data, index)))}\r\n      <\/TableBody>\r\n      {footerRow && <TableFooter>{TableRow.create(footerRow)}<\/TableFooter>}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":629,"reference":"A table displays a collections of data grouped into rows.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"function Rail(props) {\r\n  const {\r\n    attached,\r\n    children,\r\n    className,\r\n    close,\r\n    content,\r\n    dividing,\r\n    internal,\r\n    position,\r\n    size,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    position,\r\n    size,\r\n    useKeyOnly(attached, 'attached'),\r\n    useKeyOnly(dividing, 'dividing'),\r\n    useKeyOnly(internal, 'internal'),\r\n    useKeyOrValueAndKey(close, 'close'),\r\n    'rail',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Rail, props)\r\n  const ElementType = getElementType(Rail, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":194,"reference":"A rail is used to show accompanying content outside the boundaries of the main view of a site.","result":"Create a new element type.","score":[0.0178,0.0299]}
{"code":"function ButtonGroup(props) {\r\n  const {\r\n    attached,\r\n    basic,\r\n    buttons,\r\n    children,\r\n    className,\r\n    color,\r\n    compact,\r\n    content,\r\n    floated,\r\n    fluid,\r\n    icon,\r\n    inverted,\r\n    labeled,\r\n    negative,\r\n    positive,\r\n    primary,\r\n    secondary,\r\n    size,\r\n    toggle,\r\n    vertical,\r\n    widths,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    color,\r\n    size,\r\n    useKeyOnly(basic, 'basic'),\r\n    useKeyOnly(compact, 'compact'),\r\n    useKeyOnly(fluid, 'fluid'),\r\n    useKeyOnly(icon, 'icon'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(labeled, 'labeled'),\r\n    useKeyOnly(negative, 'negative'),\r\n    useKeyOnly(positive, 'positive'),\r\n    useKeyOnly(primary, 'primary'),\r\n    useKeyOnly(secondary, 'secondary'),\r\n    useKeyOnly(toggle, 'toggle'),\r\n    useKeyOnly(vertical, 'vertical'),\r\n    useKeyOrValueAndKey(attached, 'attached'),\r\n    useValueAndKey(floated, 'floated'),\r\n    useWidthProp(widths),\r\n    'buttons',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(ButtonGroup, props)\r\n  const ElementType = getElementType(ButtonGroup, props)\r\n  if (_.isNil(buttons)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {childrenUtils.isNil(children) ? content : children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {_.map(buttons, button => Button.create(button))}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":391,"reference":"Buttons can be grouped.","result":"Create a button group with a single child.","score":[0,0.1136]}
{"code":"function GridRow(props) {\r\n  const {\r\n    centered,\r\n    children,\r\n    className,\r\n    color,\r\n    columns,\r\n    divided,\r\n    only,\r\n    reversed,\r\n    stretched,\r\n    textAlign,\r\n    verticalAlign,\r\n  } = props\r\n  const classes = cx(\r\n    color,\r\n    useKeyOnly(centered, 'centered'),\r\n    useKeyOnly(divided, 'divided'),\r\n    useKeyOnly(stretched, 'stretched'),\r\n    useMultipleProp(only, 'only'),\r\n    useMultipleProp(reversed, 'reversed'),\r\n    useTextAlignProp(textAlign),\r\n    useVerticalAlignProp(verticalAlign),\r\n    useWidthProp(columns, 'column', true),\r\n    'row',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(GridRow, props)\r\n  const ElementType = getElementType(GridRow, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":224,"reference":"A row sub-component for Grid.","result":"Create a grid of cells.","score":[0,0.1]}
{"code":"function FormField(props) {\r\n  const {\r\n    children,\r\n    className,\r\n    content,\r\n    control,\r\n    disabled,\r\n    error,\r\n    inline,\r\n    label,\r\n    required,\r\n    type,\r\n    width,\r\n  } = props\r\n  const classes = cx(\r\n    useKeyOnly(disabled, 'disabled'),\r\n    useKeyOnly(error, 'error'),\r\n    useKeyOnly(inline, 'inline'),\r\n    useKeyOnly(required, 'required'),\r\n    useWidthProp(width, 'wide'),\r\n    'field',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(FormField, props)\r\n  const ElementType = getElementType(FormField, props)\r\n  if (_.isNil(control)) {\r\n    if (_.isNil(label)) {\r\n      return (\r\n        <ElementType {...rest} className={classes}>\r\n          {childrenUtils.isNil(children) ? content : children}\r\n        <\/ElementType>\r\n      )\r\n    }\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {createHTMLLabel(label, { autoGenerateKey: false })}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const controlProps = { ...rest, content, children, disabled, required, type }\r\n  if (control === 'input' && (type === 'checkbox' || type === 'radio')) {\r\n    return (\r\n      <ElementType className={classes}>\r\n        <label>\r\n          {createElement(control, controlProps)} {label}\r\n        <\/label>\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (control === Checkbox || control === Radio) {\r\n    return (\r\n      <ElementType className={classes}>\r\n        {createElement(control, { ...controlProps, label })}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType className={classes}>\r\n      {createHTMLLabel(label, {\r\n        defaultProps: { htmlFor: _.get(controlProps, 'id') },\r\n        autoGenerateKey: false,\r\n      })}\r\n      {createElement(control, controlProps)}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":458,"reference":"A field is a form element containing a label and an input.","result":"Generate the DOM tree for the given element.","score":[0,0.0]}
{"code":"function CardContent(props) {\r\n  const { children, className, content, description, extra, header, meta, textAlign } = props\r\n  const classes = cx(useKeyOnly(extra, 'extra'), useTextAlignProp(textAlign), 'content', className)\r\n  const rest = getUnhandledProps(CardContent, props)\r\n  const ElementType = getElementType(CardContent, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (!childrenUtils.isNil(content)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {content}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {createShorthand(CardHeader, val => ({ content: val }), header, { autoGenerateKey: false })}\r\n      {createShorthand(CardMeta, val => ({ content: val }), meta, { autoGenerateKey: false })}\r\n      {createShorthand(CardDescription, val => ({ content: val }), description, {\r\n        autoGenerateKey: false,\r\n      })}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":290,"reference":"A card can contain blocks of content or extra content meant to be formatted separately from the main content.","result":"Generate the content of a card.","score":[0.0291,0.113]}
{"code":"function Item(props) {\r\n  const { children, className, content, description, extra, header, image, meta } = props\r\n  const classes = cx('item', className)\r\n  const rest = getUnhandledProps(Item, props)\r\n  const ElementType = getElementType(Item, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {ItemImage.create(image, { autoGenerateKey: false })}\r\n      <ItemContent\r\n        content={content}\r\n        description={description}\r\n        extra={extra}\r\n        header={header}\r\n        meta={meta}\r\n      \/>\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":191,"reference":"An item view presents large collections of site content for display.","result":"Generate the item content.","score":[0.0555,0.0485]}
{"code":"function CommentAvatar(props) {\r\n  const { className, src } = props\r\n  const classes = cx('avatar', className)\r\n  const rest = getUnhandledProps(CommentAvatar, props)\r\n  const [imageProps, rootProps] = partitionHTMLProps(rest, { htmlProps: htmlImageProps })\r\n  const ElementType = getElementType(CommentAvatar, props)\r\n  return (\r\n    <ElementType {...rootProps} className={classes}>\r\n      {createHTMLImage(src, { autoGenerateKey: false, defaultProps: imageProps })}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":138,"reference":"A comment can contain an image or avatar.","result":"Generate the comment avatar for the given class.","score":[0.1389,0.0625]}
{"code":"function StatisticLabel(props) {\r\n  const { children, className, content } = props\r\n  const classes = cx('label', className)\r\n  const rest = getUnhandledProps(StatisticLabel, props)\r\n  const ElementType = getElementType(StatisticLabel, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":112,"reference":"A statistic can contain a label to help provide context for the presented value.","result":"Generate the code for the generated code.","score":[0.084,0.141]}
{"code":"function FeedMeta(props) {\r\n  const { children, className, content, like } = props\r\n  const classes = cx('meta', className)\r\n  const rest = getUnhandledProps(FeedMeta, props)\r\n  const ElementType = getElementType(FeedMeta, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {createShorthand(FeedLike, val => ({ content: val }), like, { autoGenerateKey: false })}\r\n      {content}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":168,"reference":"A feed can contain a meta.","result":"Generate the content of a feed.","score":[0.193,0.0833]}
{"code":"function Container(props) {\r\n  const { children, className, content, fluid, text, textAlign } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(text, 'text'),\r\n    useKeyOnly(fluid, 'fluid'),\r\n    useTextAlignProp(textAlign),\r\n    'container',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Container, props)\r\n  const ElementType = getElementType(Container, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":151,"reference":"A container limits content to a maximum width.","result":"Generate the code for the generated code.","score":[0,0.0]}
{"code":"function StepGroup(props) {\r\n  const {\r\n    attached,\r\n    children,\r\n    className,\r\n    content,\r\n    fluid,\r\n    items,\r\n    ordered,\r\n    size,\r\n    stackable,\r\n    unstackable,\r\n    vertical,\r\n    widths,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    size,\r\n    useKeyOnly(fluid, 'fluid'),\r\n    useKeyOnly(ordered, 'ordered'),\r\n    useKeyOnly(unstackable, 'unstackable'),\r\n    useKeyOnly(vertical, 'vertical'),\r\n    useKeyOrValueAndKey(attached, 'attached'),\r\n    useValueAndKey(stackable, 'stackable'),\r\n    useWidthProp(widths),\r\n    'steps',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(StepGroup, props)\r\n  const ElementType = getElementType(StepGroup, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (!childrenUtils.isNil(content)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {content}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {_.map(items, item => Step.create(item))}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":319,"reference":"A set of steps.","result":"Create a new step group.","score":[0,0.122]}
{"code":"function Divider(props) {\r\n  const {\r\n    children,\r\n    className,\r\n    clearing,\r\n    content,\r\n    fitted,\r\n    hidden,\r\n    horizontal,\r\n    inverted,\r\n    section,\r\n    vertical,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(clearing, 'clearing'),\r\n    useKeyOnly(fitted, 'fitted'),\r\n    useKeyOnly(hidden, 'hidden'),\r\n    useKeyOnly(horizontal, 'horizontal'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(section, 'section'),\r\n    useKeyOnly(vertical, 'vertical'),\r\n    'divider',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Divider, props)\r\n  const ElementType = getElementType(Divider, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":218,"reference":"A divider visually segments content into groups.","result":"Create a new element type.","score":[0,0.0735]}
{"code":"function Header(props) {\r\n  const {\r\n    attached,\r\n    block,\r\n    children,\r\n    className,\r\n    color,\r\n    content,\r\n    disabled,\r\n    dividing,\r\n    floated,\r\n    icon,\r\n    image,\r\n    inverted,\r\n    size,\r\n    sub,\r\n    subheader,\r\n    textAlign,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    color,\r\n    size,\r\n    useKeyOnly(block, 'block'),\r\n    useKeyOnly(disabled, 'disabled'),\r\n    useKeyOnly(dividing, 'dividing'),\r\n    useValueAndKey(floated, 'floated'),\r\n    useKeyOnly(icon === true, 'icon'),\r\n    useKeyOnly(image === true, 'image'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(sub, 'sub'),\r\n    useKeyOrValueAndKey(attached, 'attached'),\r\n    useTextAlignProp(textAlign),\r\n    'header',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Header, props)\r\n  const ElementType = getElementType(Header, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const iconElement = Icon.create(icon, { autoGenerateKey: false })\r\n  const imageElement = Image.create(image, { autoGenerateKey: false })\r\n  const subheaderElement = HeaderSubheader.create(subheader, { autoGenerateKey: false })\r\n  if (iconElement || imageElement) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {iconElement || imageElement}\r\n        {(content || subheaderElement) && (\r\n          <HeaderContent>\r\n            {content}\r\n            {subheaderElement}\r\n          <\/HeaderContent>\r\n        )}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {content}\r\n      {subheaderElement}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":454,"reference":"A header provides a short summary of content","result":"Generate the header for a class.","score":[0.1645,0.1282]}
{"code":"function Grid(props) {\r\n  const {\r\n    celled,\r\n    centered,\r\n    children,\r\n    className,\r\n    columns,\r\n    container,\r\n    divided,\r\n    doubling,\r\n    inverted,\r\n    padded,\r\n    relaxed,\r\n    reversed,\r\n    stackable,\r\n    stretched,\r\n    textAlign,\r\n    verticalAlign,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(centered, 'centered'),\r\n    useKeyOnly(container, 'container'),\r\n    useKeyOnly(doubling, 'doubling'),\r\n    useKeyOnly(inverted, 'inverted'),\r\n    useKeyOnly(stackable, 'stackable'),\r\n    useKeyOnly(stretched, 'stretched'),\r\n    useKeyOrValueAndKey(celled, 'celled'),\r\n    useKeyOrValueAndKey(divided, 'divided'),\r\n    useKeyOrValueAndKey(padded, 'padded'),\r\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\r\n    useMultipleProp(reversed, 'reversed'),\r\n    useTextAlignProp(textAlign),\r\n    useVerticalAlignProp(verticalAlign),\r\n    useWidthProp(columns, 'column', true),\r\n    'grid',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(Grid, props)\r\n  const ElementType = getElementType(Grid, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":323,"reference":"A grid is used to harmonize negative space in a layout.","result":"Create a grid of properties.","score":[0.0861,0.0962]}
{"code":"function Breadcrumb(props) {\r\n  const { children, className, divider, icon, sections, size } = props\r\n  const classes = cx('ui', size, 'breadcrumb', className)\r\n  const rest = getUnhandledProps(Breadcrumb, props)\r\n  const ElementType = getElementType(Breadcrumb, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const childElements = []\r\n  _.each(sections, (section, index) => {\r\n    const breadcrumbElement = BreadcrumbSection.create(section)\r\n    childElements.push(breadcrumbElement)\r\n    if (index !== sections.length - 1) {\r\n      const key = `${breadcrumbElement.key}_divider` || JSON.stringify(section)\r\n      childElements.push(BreadcrumbDivider.create({ content: divider, icon, key }))\r\n    }\r\n  })\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childElements}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":269,"reference":"A breadcrumb is used to show hierarchy between content.","result":"Create a breadcrumb for a given class.","score":[0.1214,0.1136]}
{"code":"function CardDescription(props) {\r\n  const { children, className, content, textAlign } = props\r\n  const classes = cx(useTextAlignProp(textAlign), 'description', className)\r\n  const rest = getUnhandledProps(CardDescription, props)\r\n  const ElementType = getElementType(CardDescription, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {childrenUtils.isNil(children) ? content : children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":122,"reference":"A card can contain a description with one or more paragraphs.","result":"Generate the CardDescriptions.","score":[0,0.0]}
{"code":"function ItemGroup(props) {\r\n  const { children, className, content, divided, items, link, relaxed, unstackable } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(divided, 'divided'),\r\n    useKeyOnly(link, 'link'),\r\n    useKeyOnly(unstackable, 'unstackable'),\r\n    useKeyOrValueAndKey(relaxed, 'relaxed'),\r\n    'items',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(ItemGroup, props)\r\n  const ElementType = getElementType(ItemGroup, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (!childrenUtils.isNil(content)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {content}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const itemsJSX = _.map(items, (item) => {\r\n    const { childKey, ...itemProps } = item\r\n    const finalKey =\r\n      childKey ||\r\n      [itemProps.content, itemProps.description, itemProps.header, itemProps.meta].join('-')\r\n    return <Item {...itemProps} key={finalKey} \/>\r\n  })\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {itemsJSX}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":336,"reference":"A group of items.","result":"Generate the code for the generated code.","score":[0,0.0]}
{"code":"function GridColumn(props) {\r\n  const {\r\n    children,\r\n    className,\r\n    computer,\r\n    color,\r\n    floated,\r\n    largeScreen,\r\n    mobile,\r\n    only,\r\n    stretched,\r\n    tablet,\r\n    textAlign,\r\n    verticalAlign,\r\n    widescreen,\r\n    width,\r\n  } = props\r\n  const classes = cx(\r\n    color,\r\n    useKeyOnly(stretched, 'stretched'),\r\n    useMultipleProp(only, 'only'),\r\n    useTextAlignProp(textAlign),\r\n    useValueAndKey(floated, 'floated'),\r\n    useVerticalAlignProp(verticalAlign),\r\n    useWidthProp(computer, 'wide computer'),\r\n    useWidthProp(largeScreen, 'wide large screen'),\r\n    useWidthProp(mobile, 'wide mobile'),\r\n    useWidthProp(tablet, 'wide tablet'),\r\n    useWidthProp(widescreen, 'wide widescreen'),\r\n    useWidthProp(width, 'wide'),\r\n    'column',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(GridColumn, props)\r\n  const ElementType = getElementType(GridColumn, props)\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {children}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":275,"reference":"A column sub-component for Grid.","result":"Create a grid of cells.","score":[0,0.1]}
{"code":"function ItemImage(props) {\r\n  const { size } = props\r\n  const rest = getUnhandledProps(ItemImage, props)\r\n  return <Image {...rest} size={size} ui={!!size} wrapped \/>\r\n}\r\n\r\n\/*This method is used to","code-length":58,"reference":"An item can contain an image.","result":"Create a new image with the given properties.","score":[0,0.0]}
{"code":"function CardGroup(props) {\r\n  const {\r\n    centered,\r\n    children,\r\n    className,\r\n    content,\r\n    doubling,\r\n    items,\r\n    itemsPerRow,\r\n    stackable,\r\n    textAlign,\r\n  } = props\r\n  const classes = cx(\r\n    'ui',\r\n    useKeyOnly(centered, 'centered'),\r\n    useKeyOnly(doubling, 'doubling'),\r\n    useKeyOnly(stackable, 'stackable'),\r\n    useTextAlignProp(textAlign),\r\n    useWidthProp(itemsPerRow),\r\n    'cards',\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(CardGroup, props)\r\n  const ElementType = getElementType(CardGroup, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  if (!childrenUtils.isNil(content)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {content}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  const itemsJSX = _.map(items, (item) => {\r\n    const key = item.key || [item.header, item.description].join('-')\r\n    return <Card key={key} {...item} \/>\r\n  })\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {itemsJSX}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":328,"reference":"A group of cards.","result":"Generate the card group.","score":[0,0.0]}
{"code":"function TableRow(props) {\r\n  const {\r\n    active,\r\n    cellAs,\r\n    cells,\r\n    children,\r\n    className,\r\n    disabled,\r\n    error,\r\n    negative,\r\n    positive,\r\n    textAlign,\r\n    verticalAlign,\r\n    warning,\r\n  } = props\r\n  const classes = cx(\r\n    useKeyOnly(active, 'active'),\r\n    useKeyOnly(disabled, 'disabled'),\r\n    useKeyOnly(error, 'error'),\r\n    useKeyOnly(negative, 'negative'),\r\n    useKeyOnly(positive, 'positive'),\r\n    useKeyOnly(warning, 'warning'),\r\n    useTextAlignProp(textAlign),\r\n    useVerticalAlignProp(verticalAlign),\r\n    className,\r\n  )\r\n  const rest = getUnhandledProps(TableRow, props)\r\n  const ElementType = getElementType(TableRow, props)\r\n  if (!childrenUtils.isNil(children)) {\r\n    return (\r\n      <ElementType {...rest} className={classes}>\r\n        {children}\r\n      <\/ElementType>\r\n    )\r\n  }\r\n  return (\r\n    <ElementType {...rest} className={classes}>\r\n      {_.map(cells, cell => TableCell.create(cell, { defaultProps: { as: cellAs } }))}\r\n    <\/ElementType>\r\n  )\r\n}\r\n\r\n\/*This method is used to","code-length":278,"reference":"A table can have rows.","result":"Create a table cell that is not yet created.","score":[0.1219,0.3472]}
