{"code":"func NewSTM(c *v3.Client, apply func(STM) error, so ...stmOption) (*v3.TxnResponse, error) {\r\n\topts := &stmOptions{ctx: c.Ctx()}\r\n\tfor _, f := range so {\r\n\t\tf(opts)\r\n\t}\r\n\tif len(opts.prefetch) != 0 {\r\n\t\tf := apply\r\n\t\tapply = func(s STM) error {\r\n\t\t\ts.Get(opts.prefetch...)\r\n\t\t\treturn f(s)\r\n\t\t}\r\n\t}\r\n\treturn runSTM(mkSTM(c, opts), apply)\r\n}\r\n\r\n\/*This method is used to","code-length":147,"reference":"\/\/ NewSTM initiates a new STM instance, using serializable snapshot isolation by default.","result":"Create a new STM object.","score":[0.0999,0.2413]}
{"code":"func (rs readSet) first() int64 {\r\n\tret := int64(math.MaxInt64 - 1)\r\n\tfor _, resp := range rs {\r\n\t\tif rev := resp.Header.Revision; rev < ret {\r\n\t\t\tret = rev\r\n\t\t}\r\n\t}\r\n\treturn ret\r\n}\r\n\r\n\/*This method is used to","code-length":76,"reference":"\/\/ first returns the store revision from the first fetch","result":"Read the file .","score":[0.0713,0.0532]}
{"code":"func (ws writeSet) cmps(rev int64) []v3.Cmp {\r\n\tcmps := make([]v3.Cmp, 0, len(ws))\r\n\tfor key := range ws {\r\n\t\tcmps = append(cmps, v3.Compare(v3.ModRevision(key), \"<\", rev))\r\n\t}\r\n\treturn cmps\r\n}\r\n\r\n\/*This method is used to","code-length":92,"reference":"\/\/ cmps returns a cmp list testing no writes have happened past rev","result":"Generate the v3.","score":[0,0.0]}
{"code":"func NewSTMRepeatable(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\r\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(RepeatableReads))\r\n}\r\n\r\n\/*This method is used to","code-length":71,"reference":"\/\/ NewSTMRepeatable is deprecated.","result":"Implement the new STM class.","score":[0,0.0]}
{"code":"func NewSTMSerializable(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\r\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(Serializable))\r\n}\r\n\r\n\/*This method is used to","code-length":70,"reference":"\/\/ NewSTMSerializable is deprecated.","result":"Create a new STM with the given parameters.","score":[0,0.0]}
{"code":"func NewSTMReadCommitted(ctx context.Context, c *v3.Client, apply func(STM) error) (*v3.TxnResponse, error) {\r\n\treturn NewSTM(c, apply, WithAbortContext(ctx), WithIsolation(ReadCommitted))\r\n}\r\n\r\n\/*This method is used to","code-length":72,"reference":"\/\/ NewSTMReadCommitted is deprecated.","result":"Send a message to the client.","score":[0,0.0]}
{"code":"func NewCertPool(CAFiles []string) (*x509.CertPool, error) {\r\n\tcertPool := x509.NewCertPool()\r\n\tfor _, CAFile := range CAFiles {\r\n\t\tpemByte, err := ioutil.ReadFile(CAFile)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tfor {\r\n\t\t\tvar block *pem.Block\r\n\t\t\tblock, pemByte = pem.Decode(pemByte)\r\n\t\t\tif block == nil {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tcert, err := x509.ParseCertificate(block.Bytes)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn nil, err\r\n\t\t\t}\r\n\t\t\tcertPool.AddCert(cert)\r\n\t\t}\r\n\t}\r\n\treturn certPool, nil\r\n}\r\n\r\n\/*This method is used to","code-length":182,"reference":"\/\/ NewCertPool creates x509 certPool with provided CA files.","result":"Convert a certificate to a certificate chain .","score":[0,0.0]}
{"code":"func NewCert(certfile, keyfile string, parseFunc func([]byte, []byte) (tls.Certificate, error)) (*tls.Certificate, error) {\r\n\tcert, err := ioutil.ReadFile(certfile)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\tkey, err := ioutil.ReadFile(keyfile)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\tif parseFunc == nil {\r\n\t\tparseFunc = tls.X509KeyPair\r\n\t}\r\n\ttlsCert, err := parseFunc(cert, key)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\treturn &tlsCert, nil\r\n}\r\n\r\n\/*This method is used to","code-length":165,"reference":"\/\/ NewCert generates TLS cert by using the given cert,key and parse function.","result":"Parse a certificate and return a tuple of the PEM-encoded certificate and the private key.","score":[0.0836,0.1136]}
{"code":"func (p *peer) Pause() {\r\n\tp.mu.Lock()\r\n\tdefer p.mu.Unlock()\r\n\tp.paused = true\r\n\tp.msgAppReader.pause()\r\n\tp.msgAppV2Reader.pause()\r\n}\r\n\r\n\/*This method is used to","code-length":68,"reference":"Pause pauses the peer.","result":"Send a message to the server.","score":[0.193,0.119]}
{"code":"func (p *peer) Resume() {\r\n\tp.mu.Lock()\r\n\tdefer p.mu.Unlock()\r\n\tp.paused = false\r\n\tp.msgAppReader.resume()\r\n\tp.msgAppV2Reader.resume()\r\n}\r\n\r\n\/*This method is used to","code-length":68,"reference":"\/\/ Resume resumes a paused peer.","result":"Send a message to the server.","score":[0.193,0.0833]}
{"code":"func (p *peer) pick(m raftpb.Message) (writec chan<- raftpb.Message, picked string) {\r\n\tvar ok bool\r\n\t\r\n\t\r\n\tif isMsgSnap(m) {\r\n\t\treturn p.pipeline.msgc, pipelineMsg\r\n\t} else if writec, ok = p.msgAppV2Writer.writec(); ok && isMsgApp(m) {\r\n\t\treturn writec, streamAppV2\r\n\t} else if writec, ok = p.writer.writec(); ok {\r\n\t\treturn writec, streamMsg\r\n\t}\r\n\treturn p.pipeline.msgc, pipelineMsg\r\n}\r\n\r\n\/*This method is used to","code-length":152,"reference":"pick picks a chan for sending the given message.","result":"Send a message to the stream.","score":[0.1392,0.1724]}
{"code":"func (s *snapshotSender) post(req *http.Request) (err error) {\r\n\tctx, cancel := context.WithCancel(context.Background())\r\n\treq = req.WithContext(ctx)\r\n\tdefer cancel()\r\n\ttype responseAndError struct {\r\n\t\tresp *http.Response\r\n\t\tbody []byte\r\n\t\terr  error\r\n\t}\r\n\tresult := make(chan responseAndError, 1)\r\n\tgo func() {\r\n\t\tresp, err := s.tr.pipelineRt.RoundTrip(req)\r\n\t\tif err != nil {\r\n\t\t\tresult <- responseAndError{resp, nil, err}\r\n\t\t\treturn\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\ttime.AfterFunc(snapResponseReadTimeout, func() { httputil.GracefulClose(resp) })\r\n\t\tbody, err := ioutil.ReadAll(resp.Body)\r\n\t\tresult <- responseAndError{resp, body, err}\r\n\t}()\r\n\tselect {\r\n\tcase <-s.stopc:\r\n\t\treturn errStopped\r\n\tcase r := <-result:\r\n\t\tif r.err != nil {\r\n\t\t\treturn r.err\r\n\t\t}\r\n\t\treturn checkPostResponse(r.resp, r.body, req, s.to)\r\n\t}\r\n}\r\n\r\n\/*This method is used to","code-length":287,"reference":"post posts the given request.","result":"Send a POST request to the server.","score":[0.1615,0.2885]}
{"code":"func newTxnResp(rt *pb.TxnRequest, txnPath []bool) (txnResp *pb.TxnResponse, txnCount int) {\r\n\treqs := rt.Success\r\n\tif !txnPath[0] {\r\n\t\treqs = rt.Failure\r\n\t}\r\n\tresps := make([]*pb.ResponseOp, len(reqs))\r\n\ttxnResp = &pb.TxnResponse{\r\n\t\tResponses: resps,\r\n\t\tSucceeded: txnPath[0],\r\n\t\tHeader:    &pb.ResponseHeader{},\r\n\t}\r\n\tfor i, req := range reqs {\r\n\t\tswitch tv := req.Request.(type) {\r\n\t\tcase *pb.RequestOp_RequestRange:\r\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseRange{}}\r\n\t\tcase *pb.RequestOp_RequestPut:\r\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponsePut{}}\r\n\t\tcase *pb.RequestOp_RequestDeleteRange:\r\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseDeleteRange{}}\r\n\t\tcase *pb.RequestOp_RequestTxn:\r\n\t\t\tresp, txns := newTxnResp(tv.RequestTxn, txnPath[1:])\r\n\t\t\tresps[i] = &pb.ResponseOp{Response: &pb.ResponseOp_ResponseTxn{ResponseTxn: resp}}\r\n\t\t\ttxnPath = txnPath[1+txns:]\r\n\t\t\ttxnCount += txns + 1\r\n\t\tdefault:\r\n\t\t}\r\n\t}\r\n\treturn txnResp, txnCount\r\n}\r\n\r\n\/*This method is used to","code-length":378,"reference":"\/\/ newTxnResp allocates a txn response for a txn request given a path.","result":"Create a new transaction.","score":[0.0337,0.0413]}
{"code":"func applyCompare(rv mvcc.ReadView, c *pb.Compare) bool {\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\trr, err := rv.Range(c.Key, mkGteRange(c.RangeEnd), mvcc.RangeOptions{})\r\n\tif err != nil {\r\n\t\treturn false\r\n\t}\r\n\tif len(rr.KVs) == 0 {\r\n\t\tif c.Target == pb.Compare_VALUE {\r\n\t\t\t\r\n\t\t\t\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn compareKV(c, mvccpb.KeyValue{})\r\n\t}\r\n\tfor _, kv := range rr.KVs {\r\n\t\tif !compareKV(c, kv) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\n\r\n\/*This method is used to","code-length":173,"reference":"applyCompare applies the compare request.","result":"Compare two VCs.","score":[0,0.1042]}
{"code":"func OpCompact(rev int64, opts ...CompactOption) CompactOp {\r\n\tret := CompactOp{revision: rev}\r\n\tret.applyCompactOpts(opts)\r\n\treturn ret\r\n}\r\n\r\n\/*This method is used to","code-length":57,"reference":"\/\/ OpCompact wraps slice CompactOption to create a CompactOp.","result":"Implement the CompactOp class .","score":[0,0.0]}
{"code":"func NewPriorityQueue(client *v3.Client, key string) *PriorityQueue {\r\n\treturn &PriorityQueue{client, context.TODO(), key + \"\/\"}\r\n}\r\n\r\n\/*This method is used to","code-length":47,"reference":"\/\/ NewPriorityQueue creates an etcd priority queue.","result":"Send a message to a client.","score":[0,0.0]}
{"code":"func (q *PriorityQueue) Enqueue(val string, pr uint16) error {\r\n\tprefix := fmt.Sprintf(\"%s%05d\", q.key, pr)\r\n\t_, err := newSequentialKV(q.client, prefix, val)\r\n\treturn err\r\n}\r\n\r\n\/*This method is used to","code-length":72,"reference":"\/\/ Enqueue puts a value into a queue with a given priority.","result":"Send a message to the KV server.","score":[0.0791,0.0435]}
{"code":"func NewLeaderStats(id string) *LeaderStats {\r\n\treturn &LeaderStats{\r\n\t\tleaderStats: leaderStats{\r\n\t\t\tLeader:    id,\r\n\t\t\tFollowers: make(map[string]*FollowerStats),\r\n\t\t},\r\n\t}\r\n}\r\n\r\n\/*This method is used to","code-length":71,"reference":"\/\/ NewLeaderStats generates a new LeaderStats with the given id as leader","result":"Get the leader stats for a given player.","score":[0.1191,0.1724]}
{"code":"func (fs *FollowerStats) Succ(d time.Duration) {\r\n\tfs.Lock()\r\n\tdefer fs.Unlock()\r\n\ttotal := float64(fs.Counts.Success) * fs.Latency.Average\r\n\ttotalSquare := float64(fs.Counts.Success) * fs.Latency.averageSquare\r\n\tfs.Counts.Success++\r\n\tfs.Latency.Current = float64(d) \/ (1000000.0)\r\n\tif fs.Latency.Current > fs.Latency.Maximum {\r\n\t\tfs.Latency.Maximum = fs.Latency.Current\r\n\t}\r\n\tif fs.Latency.Current < fs.Latency.Minimum {\r\n\t\tfs.Latency.Minimum = fs.Latency.Current\r\n\t}\r\n\tfs.Latency.Average = (total + fs.Latency.Current) \/ float64(fs.Counts.Success)\r\n\tfs.Latency.averageSquare = (totalSquare + fs.Latency.Current*fs.Latency.Current) \/ float64(fs.Counts.Success)\r\n\t\r\n\tfs.Latency.StandardDeviation = math.Sqrt(fs.Latency.averageSquare - fs.Latency.Average*fs.Latency.Average)\r\n}\r\n\r\n\/*This method is used to","code-length":288,"reference":"\/\/ Succ updates the FollowerStats with a successful send","result":"Calculate the average latency of a given function.","score":[0.1458,0.1124]}
{"code":"func (fs *FollowerStats) Fail() {\r\n\tfs.Lock()\r\n\tdefer fs.Unlock()\r\n\tfs.Counts.Fail++\r\n}\r\n\r\n\/*This method is used to","code-length":45,"reference":"\/\/ Fail updates the FollowerStats with an unsuccessful send","result":"Test the FollowerStats class.","score":[0.1294,0.2206]}
{"code":"func (wbs *watchBroadcasts) delete(w *watcher) int {\r\n\twbs.mu.Lock()\r\n\tdefer wbs.mu.Unlock()\r\n\twb, ok := wbs.watchers[w]\r\n\tif !ok {\r\n\t\tpanic(\"deleting missing watcher from broadcasts\")\r\n\t}\r\n\tdelete(wbs.watchers, w)\r\n\twb.delete(w)\r\n\tif wb.empty() {\r\n\t\tdelete(wbs.bcasts, wb)\r\n\t\twb.stop()\r\n\t}\r\n\treturn len(wbs.bcasts)\r\n}\r\n\r\n\/*This method is used to","code-length":149,"reference":"\/\/ delete removes a watcher and returns the number of remaining watchers.","result":"Delete a broadcast.","score":[0.0203,0.0901]}
{"code":"func startStreamWriter(lg *zap.Logger, local, id types.ID, status *peerStatus, fs *stats.FollowerStats, r Raft) *streamWriter {\r\n\tw := &streamWriter{\r\n\t\tlg: lg,\r\n\t\tlocalID: local,\r\n\t\tpeerID:  id,\r\n\t\tstatus: status,\r\n\t\tfs:     fs,\r\n\t\tr:      r,\r\n\t\tmsgc:   make(chan raftpb.Message, streamBufSize),\r\n\t\tconnc:  make(chan *outgoingConn),\r\n\t\tstopc:  make(chan struct{}),\r\n\t\tdone:   make(chan struct{}),\r\n\t}\r\n\tgo w.run()\r\n\treturn w\r\n}\r\n\r\n\/*This method is used to","code-length":169,"reference":"startStreamWriter creates a streamWrite and starts a long running go-routine that accepts messages and writes to the attached outgoing connection.","result":"Send a message to a stream.","score":[0.0246,0.1075]}
{"code":"func checkStreamSupport(v *semver.Version, t streamType) bool {\r\n\tnv := &semver.Version{Major: v.Major, Minor: v.Minor}\r\n\tfor _, s := range supportedStream[nv.String()] {\r\n\t\tif s == t {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}\r\n\r\n\/*This method is used to","code-length":88,"reference":"checkStreamSupport checks whether the stream type is supported in the given version.","result":"Check if a given stream is supported by the current platform .","score":[0.1585,0.3553]}
{"code":"func (pr *Progress) maybeUpdate(n uint64) bool {\r\n\tvar updated bool\r\n\tif pr.Match < n {\r\n\t\tpr.Match = n\r\n\t\tupdated = true\r\n\t\tpr.resume()\r\n\t}\r\n\tif pr.Next < n+1 {\r\n\t\tpr.Next = n + 1\r\n\t}\r\n\treturn updated\r\n}\r\n\r\n\/*This method is used to","code-length":88,"reference":"maybeUpdate returns false if the given n index comes from an outdated message.","result":"Update the progress bar .","score":[0.0485,0.041]}
{"code":"func (pr *Progress) IsPaused() bool {\r\n\tswitch pr.State {\r\n\tcase ProgressStateProbe:\r\n\t\treturn pr.Paused\r\n\tcase ProgressStateReplicate:\r\n\t\treturn pr.ins.full()\r\n\tcase ProgressStateSnapshot:\r\n\t\treturn true\r\n\tdefault:\r\n\t\tpanic(\"unexpected state\")\r\n\t}\r\n}\r\n\r\n\/*This method is used to","code-length":87,"reference":"IsPaused returns whether sending log entries to this node has been paused.","result":"Determine if the current state is a Panic or not .","score":[0,0.0]}
{"code":"func (pr *Progress) needSnapshotAbort() bool {\r\n\treturn pr.State == ProgressStateSnapshot && pr.Match >= pr.PendingSnapshot\r\n}\r\n\r\n\/*This method is used to","code-length":42,"reference":"needSnapshotAbort returns true if snapshot progress's Match is equal or higher than the pendingSnapshot.","result":"Check if the given file is a valid snapshot .","score":[0.1029,0.2206]}
{"code":"func (in *inflights) add(inflight uint64) {\r\n\tif in.full() {\r\n\t\tpanic(\"cannot add into a full inflights\")\r\n\t}\r\n\tnext := in.start + in.count\r\n\tsize := in.size\r\n\tif next >= size {\r\n\t\tnext -= size\r\n\t}\r\n\tif next >= len(in.buffer) {\r\n\t\tin.growBuf()\r\n\t}\r\n\tin.buffer[next] = inflight\r\n\tin.count++\r\n}\r\n\r\n\/*This method is used to","code-length":122,"reference":"\/\/ add adds an inflight into inflights","result":"Add a new inflight to the buffer .","score":[0.1389,0.1408]}
{"code":"func (in *inflights) growBuf() {\r\n\tnewSize := len(in.buffer) * 2\r\n\tif newSize == 0 {\r\n\t\tnewSize = 1\r\n\t} else if newSize > in.size {\r\n\t\tnewSize = in.size\r\n\t}\r\n\tnewBuffer := make([]uint64, newSize)\r\n\tcopy(newBuffer, in.buffer)\r\n\tin.buffer = newBuffer\r\n}\r\n\r\n\/*This method is used to","code-length":105,"reference":"grow the inflight buffer by doubling up to inflights.size. We grow on demand instead of preallocating to inflights.size to handle systems which have thousands of Raft groups per process.","result":"Copy the buffer into the buffer .","score":[0.0083,0.0373]}
{"code":"func (in *inflights) freeTo(to uint64) {\r\n\tif in.count == 0 || to < in.buffer[in.start] {\r\n\t\t\r\n\t\treturn\r\n\t}\r\n\tidx := in.start\r\n\tvar i int\r\n\tfor i = 0; i < in.count; i++ {\r\n\t\tif to < in.buffer[idx] {\r\n\t\t\tbreak\r\n\t\t}\r\n\t\t\r\n\t\tsize := in.size\r\n\t\tif idx++; idx >= size {\r\n\t\t\tidx -= size\r\n\t\t}\r\n\t}\r\n\t\r\n\tin.count -= i\r\n\tin.start = idx\r\n\tif in.count == 0 {\r\n\t\t\r\n\t\t\r\n\t\tin.start = 0\r\n\t}\r\n}\r\n\r\n\/*This method is used to","code-length":163,"reference":"\/\/ freeTo frees the inflights smaller or equal to the given `to` flight.","result":"Convert a binary string to a number.","score":[0.0685,0.0403]}
{"code":"func (s *Snapshotter) SaveDBFrom(r io.Reader, id uint64) (int64, error) {\r\n\tstart := time.Now()\r\n\tf, err := ioutil.TempFile(s.dir, \"tmp\")\r\n\tif err != nil {\r\n\t\treturn 0, err\r\n\t}\r\n\tvar n int64\r\n\tn, err = io.Copy(f, r)\r\n\tif err == nil {\r\n\t\tfsyncStart := time.Now()\r\n\t\terr = fileutil.Fsync(f)\r\n\t\tsnapDBFsyncSec.Observe(time.Since(fsyncStart).Seconds())\r\n\t}\r\n\tf.Close()\r\n\tif err != nil {\r\n\t\tos.Remove(f.Name())\r\n\t\treturn n, err\r\n\t}\r\n\tfn := s.dbFilePath(id)\r\n\tif fileutil.Exist(fn) {\r\n\t\tos.Remove(f.Name())\r\n\t\treturn n, nil\r\n\t}\r\n\terr = os.Rename(f.Name(), fn)\r\n\tif err != nil {\r\n\t\tos.Remove(f.Name())\r\n\t\treturn n, err\r\n\t}\r\n\tif s.lg != nil {\r\n\t\ts.lg.Info(\r\n\t\t\t\"saved database snapshot to disk\",\r\n\t\t\tzap.String(\"path\", fn),\r\n\t\t\tzap.Int64(\"bytes\", n),\r\n\t\t\tzap.String(\"size\", humanize.Bytes(uint64(n))),\r\n\t\t)\r\n\t} else {\r\n\t\tplog.Infof(\"saved database snapshot to disk [total bytes: %d]\", n)\r\n\t}\r\n\tsnapDBSaveSec.Observe(time.Since(start).Seconds())\r\n\treturn n, nil\r\n}\r\n\r\n\/*This method is used to","code-length":390,"reference":"SaveDBFrom saves snapshot of the database from the given reader.","result":"Save the database snapshot to disk.","score":[0.1551,0.2083]}
{"code":"func (s *Snapshotter) DBFilePath(id uint64) (string, error) {\r\n\tif _, err := fileutil.ReadDir(s.dir); err != nil {\r\n\t\treturn \"\", err\r\n\t}\r\n\tfn := s.dbFilePath(id)\r\n\tif fileutil.Exist(fn) {\r\n\t\treturn fn, nil\r\n\t}\r\n\tif s.lg != nil {\r\n\t\ts.lg.Warn(\r\n\t\t\t\"failed to find [SNAPSHOT-INDEX].snap.db\",\r\n\t\t\tzap.Uint64(\"snapshot-index\", id),\r\n\t\t\tzap.String(\"snapshot-file-path\", fn),\r\n\t\t\tzap.Error(ErrNoDBSnapshot),\r\n\t\t)\r\n\t}\r\n\treturn \"\", ErrNoDBSnapshot\r\n}\r\n\r\n\/*This method is used to","code-length":175,"reference":"DBFilePath returns the file path for the snapshot of the database with given id.","result":"Get the snapshot file path for a given snapshot .","score":[0.1915,0.3758]}
{"code":"func (us *UniqueStringsValue) Set(s string) error {\r\n\tus.Values = make(map[string]struct{})\r\n\tfor _, v := range strings.Split(s, \",\") {\r\n\t\tus.Values[v] = struct{}{}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n\/*This method is used to","code-length":76,"reference":"Set parses a command line set of strings, separated by comma.","result":"Convert a string to a number.","score":[0.0839,0.0476]}
{"code":"func NewUniqueStringsValue(s string) (us *UniqueStringsValue) {\r\n\tus = &UniqueStringsValue{Values: make(map[string]struct{})}\r\n\tif s == \"\" {\r\n\t\treturn us\r\n\t}\r\n\tif err := us.Set(s); err != nil {\r\n\t\tplog.Panicf(\"new UniqueStringsValue should never fail: %v\", err)\r\n\t}\r\n\treturn us\r\n}\r\n\r\n\/*This method is used to","code-length":107,"reference":"NewUniqueStringsValue implements string slice as \"flag.","result":"Convert a string to a number.","score":[0.193,0.0833]}
{"code":"func UniqueStringsFromFlag(fs *flag.FlagSet, flagName string) []string {\r\n\treturn (*fs.Lookup(flagName).Value.(*UniqueStringsValue)).stringSlice()\r\n}\r\n\r\n\/*This method is used to","code-length":52,"reference":"\/\/ UniqueStringsFromFlag returns a string slice from the flag.","result":"Convert a flag value to a string.","score":[0.1214,0.0568]}
{"code":"func UniqueStringsMapFromFlag(fs *flag.FlagSet, flagName string) map[string]struct{} {\r\n\treturn (*fs.Lookup(flagName).Value.(*UniqueStringsValue)).Values\r\n}\r\n\r\n\/*This method is used to","code-length":55,"reference":"\/\/ UniqueStringsMapFromFlag returns a map of strings from the flag.","result":"Map flags to their string values.","score":[0,0.1042]}
{"code":"func Percentiles(nums []float64) (pcs []float64, data []float64) {\r\n\treturn pctls, percentiles(nums)\r\n}\r\n\r\n\/*This method is used to","code-length":47,"reference":"\/\/ Percentiles returns percentile distribution of float64 slice.","result":"Compute the percentiles of a list of numbers.","score":[0.1389,0.125]}
{"code":"func (c *ServerConfig) VerifyBootstrap() error {\r\n\tif err := c.hasLocalMember(); err != nil {\r\n\t\treturn err\r\n\t}\r\n\tif err := c.advertiseMatchesCluster(); err != nil {\r\n\t\treturn err\r\n\t}\r\n\tif checkDuplicateURL(c.InitialPeerURLsMap) {\r\n\t\treturn fmt.Errorf(\"initial cluster %s has duplicate url\", c.InitialPeerURLsMap)\r\n\t}\r\n\tif c.InitialPeerURLsMap.String() == \"\" && c.DiscoveryURL == \"\" {\r\n\t\treturn fmt.Errorf(\"initial cluster unset and no discovery URL found\")\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n\/*This method is used to","code-length":160,"reference":"VerifyBootstrap sanity-checks the initial config for bootstrap case and returns an error for things that should never happen.","result":"Verify the bootstrap process is running on the cluster .","score":[0.058,0.0581]}
{"code":"func (c *ServerConfig) VerifyJoinExisting() error {\r\n\t\r\n\t\r\n\tif err := c.hasLocalMember(); err != nil {\r\n\t\treturn err\r\n\t}\r\n\tif checkDuplicateURL(c.InitialPeerURLsMap) {\r\n\t\treturn fmt.Errorf(\"initial cluster %s has duplicate url\", c.InitialPeerURLsMap)\r\n\t}\r\n\tif c.DiscoveryURL != \"\" {\r\n\t\treturn fmt.Errorf(\"discovery URL should not be set when joining existing initial cluster\")\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n\/*This method is used to","code-length":129,"reference":"VerifyJoinExisting sanity-checks the initial config for join existing cluster case and returns an error for things that should never happen.","result":"Join a cluster.","score":[0,0.0273]}
{"code":"func (c *ServerConfig) hasLocalMember() error {\r\n\tif urls := c.InitialPeerURLsMap[c.Name]; urls == nil {\r\n\t\treturn fmt.Errorf(\"couldn't find local name %q in the initial cluster configuration\", c.Name)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n\/*This method is used to","code-length":78,"reference":"\/\/ hasLocalMember checks that the cluster at least contains the local server.","result":"Get the current cluster configuration.","score":[0.0705,0.0885]}
{"code":"func (c *ServerConfig) advertiseMatchesCluster() error {\r\n\turls, apurls := c.InitialPeerURLsMap[c.Name], c.PeerURLs.StringSlice()\r\n\turls.Sort()\r\n\tsort.Strings(apurls)\r\n\tctx, cancel := context.WithTimeout(context.TODO(), 30*time.Second)\r\n\tdefer cancel()\r\n\tok, err := netutil.URLStringsEqual(ctx, c.Logger, apurls, urls.StringSlice())\r\n\tif ok {\r\n\t\treturn nil\r\n\t}\r\n\tinitMap, apMap := make(map[string]struct{}), make(map[string]struct{})\r\n\tfor _, url := range c.PeerURLs {\r\n\t\tapMap[url.String()] = struct{}{}\r\n\t}\r\n\tfor _, url := range c.InitialPeerURLsMap[c.Name] {\r\n\t\tinitMap[url.String()] = struct{}{}\r\n\t}\r\n\tmissing := []string{}\r\n\tfor url := range initMap {\r\n\t\tif _, ok := apMap[url]; !ok {\r\n\t\t\tmissing = append(missing, url)\r\n\t\t}\r\n\t}\r\n\tif len(missing) > 0 {\r\n\t\tfor i := range missing {\r\n\t\t\tmissing[i] = c.Name + \"=\" + missing[i]\r\n\t\t}\r\n\t\tmstr := strings.Join(missing, \",\")\r\n\t\tapStr := strings.Join(apurls, \",\")\r\n\t\treturn fmt.Errorf(\"--initial-cluster has %s but missing from --initial-advertise-peer-urls=%s (%v)\", mstr, apStr, err)\r\n\t}\r\n\tfor url := range apMap {\r\n\t\tif _, ok := initMap[url]; !ok {\r\n\t\t\tmissing = append(missing, url)\r\n\t\t}\r\n\t}\r\n\tif len(missing) > 0 {\r\n\t\tmstr := strings.Join(missing, \",\")\r\n\t\tumap := types.URLsMap(map[string]types.URLs{c.Name: c.PeerURLs})\r\n\t\treturn fmt.Errorf(\"--initial-advertise-peer-urls has %s but missing from --initial-cluster=%s\", mstr, umap.String())\r\n\t}\r\n\t\r\n\tapStr := strings.Join(apurls, \",\")\r\n\tumap := types.URLsMap(map[string]types.URLs{c.Name: c.PeerURLs})\r\n\treturn fmt.Errorf(\"failed to resolve %s to match --initial-cluster=%s (%v)\", apStr, umap.String(), err)\r\n}\r\n\r\n\/*This method is used to","code-length":587,"reference":"\/\/ advertiseMatchesCluster confirms peer URLs match those in the cluster peer list.","result":"Code too long,keep in 512.","score":[0.0593,0.0442]}
{"code":"func (c *ServerConfig) ReqTimeout() time.Duration {\r\n\t\r\n\t\r\n\treturn 5*time.Second + 2*time.Duration(c.ElectionTicks*int(c.TickMs))*time.Millisecond\r\n}\r\n\r\n\/*This method is used to","code-length":59,"reference":"\/\/ ReqTimeout returns timeout for request to finish.","result":"Send a message to the server.","score":[0.1383,0.0641]}
{"code":"func getStatus(r *raft) Status {\r\n\ts := getStatusWithoutProgress(r)\r\n\tif s.RaftState == StateLeader {\r\n\t\ts.Progress = getProgressCopy(r)\r\n\t}\r\n\treturn s\r\n}\r\n\r\n\/*This method is used to","code-length":64,"reference":"\/\/ getStatus gets a copy of the current raft status.","result":"Get the status of the current player.","score":[0.2167,0.3866]}
{"code":"func GetDefaultHost() (string, error) {\r\n\trmsgs, rerr := getDefaultRoutes()\r\n\tif rerr != nil {\r\n\t\treturn \"\", rerr\r\n\t}\r\n\t\r\n\tif rmsg, ok := rmsgs[syscall.AF_INET]; ok {\r\n\t\tif host, err := chooseHost(syscall.AF_INET, rmsg); host != \"\" || err != nil {\r\n\t\t\treturn host, err\r\n\t\t}\r\n\t\tdelete(rmsgs, syscall.AF_INET)\r\n\t}\r\n\t\r\n\tvar families []int\r\n\tfor family := range rmsgs {\r\n\t\tfamilies = append(families, int(family))\r\n\t}\r\n\tsort.Ints(families)\r\n\tfor _, f := range families {\r\n\t\tfamily := uint8(f)\r\n\t\tif host, err := chooseHost(family, rmsgs[family]); host != \"\" || err != nil {\r\n\t\t\treturn host, err\r\n\t\t}\r\n\t}\r\n\treturn \"\", errNoDefaultHost\r\n}\r\n\r\n\/*This method is used to","code-length":227,"reference":"GetDefaultHost obtains the first IP address of machine from the routing table and returns the IP address as string.","result":"Get the default route for a given host .","score":[0.0401,0.1111]}
{"code":"func getIfaceAddr(idx uint32, family uint8) (*syscall.NetlinkMessage, error) {\r\n\tdat, err := syscall.NetlinkRIB(syscall.RTM_GETADDR, int(family))\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\tmsgs, msgErr := syscall.ParseNetlinkMessage(dat)\r\n\tif msgErr != nil {\r\n\t\treturn nil, msgErr\r\n\t}\r\n\tifaddrmsg := syscall.IfAddrmsg{}\r\n\tfor _, m := range msgs {\r\n\t\tif m.Header.Type != syscall.RTM_NEWADDR {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tbuf := bytes.NewBuffer(m.Data[:syscall.SizeofIfAddrmsg])\r\n\t\tif rerr := binary.Read(buf, cpuutil.ByteOrder(), &ifaddrmsg); rerr != nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ifaddrmsg.Index == idx {\r\n\t\t\treturn &m, nil\r\n\t\t}\r\n\t}\r\n\treturn nil, fmt.Errorf(\"could not find address for interface index %v\", idx)\r\n}\r\n\r\n\/*This method is used to","code-length":254,"reference":"\/\/ Used to get an address of interface.","result":"Find the interface name for a given interface.","score":[0.1389,0.125]}
{"code":"func getIfaceLink(idx uint32) (*syscall.NetlinkMessage, error) {\r\n\tdat, err := syscall.NetlinkRIB(syscall.RTM_GETLINK, syscall.AF_UNSPEC)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\tmsgs, msgErr := syscall.ParseNetlinkMessage(dat)\r\n\tif msgErr != nil {\r\n\t\treturn nil, msgErr\r\n\t}\r\n\tifinfomsg := syscall.IfInfomsg{}\r\n\tfor _, m := range msgs {\r\n\t\tif m.Header.Type != syscall.RTM_NEWLINK {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tbuf := bytes.NewBuffer(m.Data[:syscall.SizeofIfInfomsg])\r\n\t\tif rerr := binary.Read(buf, cpuutil.ByteOrder(), &ifinfomsg); rerr != nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tif ifinfomsg.Index == int32(idx) {\r\n\t\t\treturn &m, nil\r\n\t\t}\r\n\t}\r\n\treturn nil, fmt.Errorf(\"could not find link for interface index %v\", idx)\r\n}\r\n\r\n\/*This method is used to","code-length":257,"reference":"\/\/ Used to get a name of interface.","result":"Find the interface that is used by the kernel.","score":[0,0.1235]}
{"code":"func lsCommandFunc(c *cli.Context, ki client.KeysAPI) {\r\n\tkey := \"\/\"\r\n\tif len(c.Args()) != 0 {\r\n\t\tkey = c.Args()[0]\r\n\t}\r\n\tsort := c.Bool(\"sort\")\r\n\trecursive := c.Bool(\"recursive\")\r\n\tquorum := c.Bool(\"quorum\")\r\n\tctx, cancel := contextWithTotalTimeout(c)\r\n\tresp, err := ki.Get(ctx, key, &client.GetOptions{Sort: sort, Recursive: recursive, Quorum: quorum})\r\n\tcancel()\r\n\tif err != nil {\r\n\t\thandleError(c, ExitServerError, err)\r\n\t}\r\n\tprintLs(c, resp)\r\n}\r\n\r\n\/*This method is used to","code-length":177,"reference":"\/\/ lsCommandFunc executes the \"ls\" command.","result":"Get the list of keys for a given key.","score":[0.1219,0.0794]}
{"code":"func printLs(c *cli.Context, resp *client.Response) {\r\n\tif c.GlobalString(\"output\") == \"simple\" {\r\n\t\tif !resp.Node.Dir {\r\n\t\t\tfmt.Println(resp.Node.Key)\r\n\t\t}\r\n\t\tfor _, node := range resp.Node.Nodes {\r\n\t\t\trPrint(c, node)\r\n\t\t}\r\n\t} else {\r\n\t\t\r\n\t\tprintResponseKey(resp, c.GlobalString(\"output\"))\r\n\t}\r\n}\r\n\r\n\/*This method is used to","code-length":119,"reference":"printLs writes a response out in a manner similar to the `ls` command in unix.","result":"Print the response to the client .","score":[0.0806,0.18]}
{"code":"func rPrint(c *cli.Context, n *client.Node) {\r\n\tif n.Dir && c.Bool(\"p\") {\r\n\t\tfmt.Println(fmt.Sprintf(\"%v\/\", n.Key))\r\n\t} else {\r\n\t\tfmt.Println(n.Key)\r\n\t}\r\n\tfor _, node := range n.Nodes {\r\n\t\trPrint(c, node)\r\n\t}\r\n}\r\n\r\n\/*This method is used to","code-length":102,"reference":"\/\/ rPrint recursively prints out the nodes in the node structure.","result":"Print the current state of the client .","score":[0.1135,0.295]}
{"code":"func NewLeaseRenewerCommand() *cobra.Command {\r\n\tcmd := &cobra.Command{\r\n\t\tUse:   \"lease-renewer\",\r\n\t\tShort: \"Performs lease renew operation\",\r\n\t\tRun:   runLeaseRenewerFunc,\r\n\t}\r\n\tcmd.Flags().Int64Var(&leaseTTL, \"ttl\", 5, \"lease's ttl\")\r\n\treturn cmd\r\n}\r\n\r\n\/*This method is used to","code-length":102,"reference":"\/\/ NewLeaseRenewerCommand returns the cobra command for \"lease-renewer runner\".","result":"Set the lease TTL for a lease.","score":[0.1443,0.1136]}
{"code":"func Read(lg *zap.Logger, snapname string) (*raftpb.Snapshot, error) {\r\n\tb, err := ioutil.ReadFile(snapname)\r\n\tif err != nil {\r\n\t\tif lg != nil {\r\n\t\t\tlg.Warn(\"failed to read a snap file\", zap.String(\"path\", snapname), zap.Error(err))\r\n\t\t} else {\r\n\t\t\tplog.Errorf(\"cannot read file %v: %v\", snapname, err)\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r\n\tif len(b) == 0 {\r\n\t\tif lg != nil {\r\n\t\t\tlg.Warn(\"failed to read empty snapshot file\", zap.String(\"path\", snapname))\r\n\t\t} else {\r\n\t\t\tplog.Errorf(\"unexpected empty snapshot\")\r\n\t\t}\r\n\t\treturn nil, ErrEmptySnapshot\r\n\t}\r\n\tvar serializedSnap snappb.Snapshot\r\n\tif err = serializedSnap.Unmarshal(b); err != nil {\r\n\t\tif lg != nil {\r\n\t\t\tlg.Warn(\"failed to unmarshal snappb.Snapshot\", zap.String(\"path\", snapname), zap.Error(err))\r\n\t\t} else {\r\n\t\t\tplog.Errorf(\"corrupted snapshot file %v: %v\", snapname, err)\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r\n\tif len(serializedSnap.Data) == 0 || serializedSnap.Crc == 0 {\r\n\t\tif lg != nil {\r\n\t\t\tlg.Warn(\"failed to read empty snapshot data\", zap.String(\"path\", snapname))\r\n\t\t} else {\r\n\t\t\tplog.Errorf(\"unexpected empty snapshot\")\r\n\t\t}\r\n\t\treturn nil, ErrEmptySnapshot\r\n\t}\r\n\tcrc := crc32.Update(0, crcTable, serializedSnap.Data)\r\n\tif crc != serializedSnap.Crc {\r\n\t\tif lg != nil {\r\n\t\t\tlg.Warn(\"snap file is corrupt\",\r\n\t\t\t\tzap.String(\"path\", snapname),\r\n\t\t\t\tzap.Uint32(\"prev-crc\", serializedSnap.Crc),\r\n\t\t\t\tzap.Uint32(\"new-crc\", crc),\r\n\t\t\t)\r\n\t\t} else {\r\n\t\t\tplog.Errorf(\"corrupted snapshot file %v: crc mismatch\", snapname)\r\n\t\t}\r\n\t\treturn nil, ErrCRCMismatch\r\n\t}\r\n\tvar snap raftpb.Snapshot\r\n\tif err = snap.Unmarshal(serializedSnap.Data); err != nil {\r\n\t\tif lg != nil {\r\n\t\t\tlg.Warn(\"failed to unmarshal raftpb.Snapshot\", zap.String(\"path\", snapname), zap.Error(err))\r\n\t\t} else {\r\n\t\t\tplog.Errorf(\"corrupted snapshot file %v: %v\", snapname, err)\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r\n\treturn &snap, nil\r\n}\r\n\r\n\/*This method is used to","code-length":648,"reference":"\/\/ Read reads the snapshot named by snapname and returns the snapshot.","result":"Code too long,keep in 512.","score":[0,0.0]}
