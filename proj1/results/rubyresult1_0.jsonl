{"code":"# is used to<extra_id_0>\r\ndef print_summary(status)\r\n      status_string = status.to_s.humanize.upcase\r\n      if status == :success\r\n        heading(\"Result: \", status_string, :green)\r\n        level = :info\r\n      elsif status == :timed_out\r\n        heading(\"Result: \", status_string, :yellow)\r\n        level = :fatal\r\n      else\r\n        heading(\"Result: \", status_string, :red)\r\n        level = :fatal\r\n      end\r\n      if (actions_sentence = summary.actions_sentence.presence)\r\n        public_send(level, actions_sentence)\r\n        blank_line(level)\r\n      end\r\n      summary.paragraphs.each do |para|\r\n        msg_lines = para.split(\"\\n\")\r\n        msg_lines.each { |line| public_send(level, line) }\r\n        blank_line(level) unless para == summary.paragraphs.last\r\n      end\r\n    end","code-length":242,"reference":"Outputs the deferred summary information saved via ","result":"Print the summary of the result.","score":[0.1943,0.1449]}
{"code":"# is used to<extra_id_0>\r\ndef find_bad_files_from_kubectl_output(line)\r\n      line.scan(%r{\"(\/\\S+\\.ya?ml\\S*)\"}).each_with_object([]) do |matches, bad_files|\r\n        matches.each do |path|\r\n          content = File.read(path) if File.file?(path)\r\n          bad_files << { filename: File.basename(path), err: line, content: content }\r\n        end\r\n      end\r\n    end","code-length":130,"reference":"Inspect the file referenced in the kubectl stderr to make it easier for developer to understand what's going on","result":"Find bad files from the output.","score":[0.0221,0.0565]}
{"code":"# is used to<extra_id_0>\r\ndef confirm_ejson_keys_not_prunable\r\n      secret = ejson_provisioner.ejson_keys_secret\r\n      return unless secret.dig(\"metadata\", \"annotations\", KubernetesResource::LAST_APPLIED_ANNOTATION)\r\n      @logger.error(\"Deploy cannot proceed because protected resource \" \\\r\n        \"Secret\/#{EjsonSecretProvisioner::EJSON_KEYS_SECRET} would be pruned.\")\r\n      raise EjsonPrunableError\r\n    rescue Kubectl::ResourceNotFoundError => e\r\n      @logger.debug(\"Secret\/#{EjsonSecretProvisioner::EJSON_KEYS_SECRET} does not exist: #{e}\")\r\n    end","code-length":157,"reference":"make sure to never prune the ejson-keys secret","result":"Generate a new file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef for_current_system(compressors)\r\n      family = Ohai[\"platform_family\"]\r\n      if family == \"mac_os_x\"\r\n        if compressors.include?(:dmg)\r\n          return DMG\r\n        end\r\n        if compressors.include?(:tgz)\r\n          return TGZ\r\n        end\r\n      end\r\n      if compressors.include?(:tgz)\r\n        return TGZ\r\n      else\r\n        log.info(log_key) { \"No compressor defined for `#{family}'.\" }\r\n        return Null\r\n      end\r\n    end","code-length":155,"reference":"Determine the best compressor for the current system.","result":"Determine the compressor.","score":[0.109,0.1333]}
{"code":"# is used to<extra_id_0>\r\ndef create_bff_file\r\n      shellout!(\"sudo chown -Rh 0:0 #{File.join(staging_dir, project.install_dir.match(\/^\\\/?(\\w+)\/).to_s)}\")\r\n      log.info(log_key) { \"Creating .bff file\" }\r\n      shellout!(\"sudo \/usr\/sbin\/mkinstallp -d #{staging_dir} -T #{File.join(staging_dir, 'gen.template')}\")\r\n      log.debug(log_key) do\r\n        \"With .inventory file of:\\n\" + File.read(\"#{File.join( staging_dir, '.info', \"#{safe_base_package_name}.inventory\" )}\")\r\n      end\r\n      FileSyncer.glob(File.join(staging_dir, \"tmp\/*.bff\")).each do |bff|\r\n        copy_file(bff, File.join(Config.package_dir, create_bff_file_name))\r\n      end\r\n    ensure\r\n      original_uid = shellout!(\"id -u\").stdout.chomp\r\n      original_gid = shellout!(\"id -g\").stdout.chomp\r\n      shellout!(\"sudo chown -Rh #{original_uid}:#{original_gid} #{staging_dir}\")\r\n    end","code-length":331,"reference":"Create the bff file using +mkinstallp+.","result":"Generate the package.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef glob(pattern)\r\n      pattern = Pathname.new(pattern).cleanpath.to_s\r\n      Dir.glob(pattern, File::FNM_DOTMATCH).sort.reject do |file|\r\n        basename = File.basename(file)\r\n        IGNORED_FILES.include?(basename)\r\n      end\r\n    end","code-length":89,"reference":"Glob across the given pattern, accounting for dotfiles, removing Ruby's dumb idea to include +'.","result":"Generate the code.","score":[0.0075,0.0362]}
{"code":"# is used to<extra_id_0>\r\ndef sync(source, destination, options = {})\r\n      unless File.directory?(source)\r\n        raise ArgumentError, \"`source' must be a directory, but was a \" \\\r\n          \"`#{File.ftype(source)}'! If you just want to sync a file, use \" \\\r\n          \"the `copy' method instead.\"\r\n      end\r\n      source_files = all_files_under(source, options)\r\n      FileUtils.mkdir_p(destination) unless File.directory?(destination)\r\n      source_files.each do |source_file|\r\n        relative_path = relative_path_for(source_file, source)\r\n        parent = File.join(destination, File.dirname(relative_path))\r\n        FileUtils.mkdir_p(parent) unless File.directory?(parent)\r\n        case File.ftype(source_file).to_sym\r\n        when :directory\r\n          FileUtils.mkdir_p(\"#{destination}\/#{relative_path}\")\r\n        when :link\r\n          target = File.readlink(source_file)\r\n          Dir.chdir(destination) do\r\n            FileUtils.ln_sf(target, \"#{destination}\/#{relative_path}\")\r\n          end\r\n        when :file\r\n          source_stat = File.stat(source_file)\r\n          if hardlink? source_stat\r\n            if existing = hardlink_sources[[source_stat.dev, source_stat.ino]]\r\n              FileUtils.ln(existing, \"#{destination}\/#{relative_path}\", force: true)\r\n            else\r\n              begin\r\n                FileUtils.cp(source_file, \"#{destination}\/#{relative_path}\")\r\n              rescue Errno::EACCES\r\n                FileUtils.cp_r(source_file, \"#{destination}\/#{relative_path}\", remove_destination: true)\r\n              end\r\n              hardlink_sources.store([source_stat.dev, source_stat.ino], \"#{destination}\/#{relative_path}\")\r\n            end\r\n          else\r\n            begin\r\n              FileUtils.cp(source_file, \"#{destination}\/#{relative_path}\")\r\n            rescue Errno::EACCES\r\n              FileUtils.cp_r(source_file, \"#{destination}\/#{relative_path}\", remove_destination: true)\r\n            end\r\n          end\r\n        else\r\n          raise \"Unknown file type: `File.ftype(source_file)' at `#{source_file}'!\"\r\n        end\r\n      end\r\n      destination_files = glob(\"#{destination}\/**\/*\")\r\n      relative_source_files = source_files.map do |file|\r\n        relative_path_for(file, source)\r\n      end\r\n      relative_destination_files = destination_files.map do |file|\r\n        relative_path_for(file, destination)\r\n      end\r\n      extra_files = relative_destination_files - relative_source_files\r\n      extra_files.each do |file|\r\n        FileUtils.rm_rf(File.join(destination, file))\r\n      end\r\n      true\r\n    end","code-length":722,"reference":"Copy the files from +source+ to +destination+, while removing any files in +destination+ that are not present in +source+.","result":"Code too long,keep in 512.","score":[0.0146,0.0284]}
{"code":"# is used to<extra_id_0>\r\ndef relative_path_for(path, parent)\r\n      Pathname.new(path).relative_path_from(Pathname.new(parent)).to_s\r\n    end","code-length":51,"reference":"The relative path of the given +path+ to the +parent+.","result":"Generate the code.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef clean_disks\r\n      log.info(log_key) { \"Cleaning previously mounted disks\" }\r\n      existing_disks = shellout!(\"mount | grep \\\"\/Volumes\/#{volume_name}\\\" | awk '{print $1}'\")\r\n      existing_disks.stdout.lines.each do |existing_disk|\r\n        existing_disk.chomp!\r\n        Omnibus.logger.debug(log_key) do\r\n          \"Detaching disk `#{existing_disk}' before starting dmg packaging.\"\r\n        end\r\n        shellout!(\"hdiutil detach '#{existing_disk}'\")\r\n      end\r\n    end","code-length":160,"reference":"Cleans any previously left over mounted disks.","result":"Clean previously mounted disks.","score":[0.2362,0.4711]}
{"code":"# is used to<extra_id_0>\r\ndef copy_assets_to_dmg\r\n      log.info(log_key) { \"Copying assets into dmg\" }\r\n      FileSyncer.glob(\"#{resources_dir}\/*\").each do |file|\r\n        FileUtils.cp_r(file, \"\/Volumes\/#{volume_name}\")\r\n      end\r\n    end","code-length":87,"reference":"Copy assets to dmg","result":"Create the dmg.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef write_transform_file\r\n      render_template(resource_path(\"doc-transform.erb\"),\r\n        destination: transform_file,\r\n        variables: {\r\n          pathdir: project.install_dir.split(\"\/\")[1],\r\n        }\r\n      )\r\n    end","code-length":79,"reference":"A set of transform rules that `pkgmogrify' will apply to the package manifest.","result":"Generate the doc-transform.","score":[0.0146,0.0417]}
{"code":"# is used to<extra_id_0>\r\ndef write_pkg_metadata\r\n      render_template(resource_path(\"gen.manifestfile.erb\"),\r\n        destination: pkg_metadata_file,\r\n        variables: {\r\n          name: safe_base_package_name,\r\n          fmri_package_name: fmri_package_name,\r\n          description: project.description,\r\n          summary: project.friendly_name,\r\n          arch: safe_architecture,\r\n        }\r\n      )\r\n      if symlinks_file\r\n        File.open(pkg_metadata_file, \"a\") do |symlink|\r\n          symlink.write(render_symlinks)\r\n        end\r\n      end\r\n      log.debug(log_key) { \"Rendered Template:\\n\" + File.read(pkg_metadata_file) }\r\n    end","code-length":201,"reference":"Generate package metadata","result":"Generate the package metadata.","score":[0.3799,0.3226]}
{"code":"# is used to<extra_id_0>\r\ndef health_check_otool\r\n      current_library = nil\r\n      bad_libs = {}\r\n      read_shared_libs(\"find #{project.install_dir}\/ -type f | egrep '\\.(dylib|bundle)$' | xargs otool -L\") do |line|\r\n        case line\r\n        when \/^(.+):$\/\r\n          current_library = Regexp.last_match[1]\r\n        when \/^\\s+(.+) \\(.+\\)$\/\r\n          linked = Regexp.last_match[1]\r\n          name = File.basename(linked)\r\n          bad_libs = check_for_bad_library(bad_libs, current_library, name, linked)\r\n        end\r\n      end\r\n      bad_libs\r\n    end","code-length":188,"reference":"Run healthchecks against otool.","result":"Check for bad libraries.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef health_check_aix\r\n      current_library = nil\r\n      bad_libs = {}\r\n      read_shared_libs(\"find #{project.install_dir}\/ -type f | xargs file | grep \\\"RISC System\\\" | awk -F: '{print $1}' | xargs -n 1 ldd\") do |line|\r\n        case line\r\n        when \/^(.+) needs:$\/\r\n          current_library = Regexp.last_match[1]\r\n          log.debug(log_key) { \"Analyzing dependencies for #{current_library}\" }\r\n        when \/^\\s+(.+)$\/\r\n          name = Regexp.last_match[1]\r\n          linked = Regexp.last_match[1]\r\n          bad_libs = check_for_bad_library(bad_libs, current_library, name, linked)\r\n        when \/File is not an executable XCOFF file\/\r\n        else\r\n          log.warn(log_key) { \"Line did not match for #{current_library}\\n#{line}\" }\r\n        end\r\n      end\r\n      bad_libs\r\n    end","code-length":269,"reference":"Run healthchecks against aix.","result":"Check for bad dependencies.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef health_check_ldd\r\n      regexp_ends = \".*(\" + IGNORED_ENDINGS.map { |e| e.gsub(\/\\.\/, '\\.') }.join(\"|\") + \")$\"\r\n      regexp_patterns = IGNORED_PATTERNS.map { |e| \".*\" + e.gsub(\/\\\/\/, '\\\/') + \".*\" }.join(\"|\")\r\n      regexp = regexp_ends + \"|\" + regexp_patterns\r\n      current_library = nil\r\n      bad_libs = {}\r\n      read_shared_libs(\"find #{project.install_dir}\/ -type f -regextype posix-extended ! -regex '#{regexp}' | xargs ldd\") do |line|\r\n        case line\r\n        when \/^(.+):$\/\r\n          current_library = Regexp.last_match[1]\r\n          log.debug(log_key) { \"Analyzing dependencies for #{current_library}\" }\r\n        when \/^\\s+(.+) \\=\\>\\s+(.+)( \\(.+\\))?$\/\r\n          name = Regexp.last_match[1]\r\n          linked = Regexp.last_match[2]\r\n          bad_libs = check_for_bad_library(bad_libs, current_library, name, linked)\r\n        when \/^\\s+(.+) \\(.+\\)$\/\r\n          next\r\n        when \/^\\s+statically linked$\/\r\n          next\r\n        when \/^\\s+libjvm.so\/\r\n          next\r\n        when \/^\\s+libjava.so\/\r\n          next\r\n        when \/^\\s+libmawt.so\/\r\n          next\r\n        when \/^\\s+not a dynamic executable$\/\r\n        else\r\n          log.warn(log_key) do\r\n            \"Line did not match for #{current_library}\\n#{line}\"\r\n          end\r\n        end\r\n      end\r\n      bad_libs\r\n    end","code-length":460,"reference":"Run healthchecks against ldd.","result":"Check for bad dependencies.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef read_shared_libs(command)\r\n      cmd = shellout(command)\r\n      cmd.stdout.each_line do |line|\r\n        yield line\r\n      end\r\n    end","code-length":56,"reference":"Execute the given command, yielding each line.","result":"Read shared libs.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef check_for_bad_library(bad_libs, current_library, name, linked)\r\n      safe = nil\r\n      whitelist_libs = case Ohai[\"platform\"]\r\n                       when \"arch\"\r\n                         ARCH_WHITELIST_LIBS\r\n                       when \"mac_os_x\"\r\n                         MAC_WHITELIST_LIBS\r\n                       when \"solaris2\"\r\n                         SOLARIS_WHITELIST_LIBS\r\n                       when \"smartos\"\r\n                         SMARTOS_WHITELIST_LIBS\r\n                       when \"freebsd\"\r\n                         FREEBSD_WHITELIST_LIBS\r\n                       when \"aix\"\r\n                         AIX_WHITELIST_LIBS\r\n                       else\r\n                         WHITELIST_LIBS\r\n                       end\r\n      whitelist_libs.each do |reg|\r\n        safe ||= true if reg.match(name)\r\n      end\r\n      whitelist_files.each do |reg|\r\n        safe ||= true if reg.match(current_library)\r\n      end\r\n      log.debug(log_key) { \"  --> Dependency: #{name}\" }\r\n      log.debug(log_key) { \"  --> Provided by: #{linked}\" }\r\n      if !safe && linked !~ Regexp.new(project.install_dir)\r\n        log.debug(log_key) { \"    -> FAILED: #{current_library} has unsafe dependencies\" }\r\n        bad_libs[current_library] ||= {}\r\n        bad_libs[current_library][name] ||= {}\r\n        if bad_libs[current_library][name].key?(linked)\r\n          bad_libs[current_library][name][linked] += 1\r\n        else\r\n          bad_libs[current_library][name][linked] = 1\r\n        end\r\n      else\r\n        log.debug(log_key) { \"    -> PASSED: #{name} is either whitelisted or safely provided.\" }\r\n      end\r\n      bad_libs\r\n    end","code-length":476,"reference":"Check the given path and library for \"bad\" libraries.","result":"Check for bad dependencies.","score":[0.1088,0.1176]}
{"code":"# is used to<extra_id_0>\r\ndef digest(path, type = :md5)\r\n      digest = digest_from_type(type)\r\n      update_with_file_contents(digest, path)\r\n      digest.hexdigest\r\n    end","code-length":59,"reference":"Calculate the digest of the file at the given path.","result":"Define the digest method.","score":[0.1008,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef update_with_file_contents(digest, filename)\r\n      File.open(filename) do |io|\r\n        while (chunk = io.read(1024 * 8))\r\n          digest.update(chunk)\r\n        end\r\n      end\r\n    end","code-length":72,"reference":"Update the digest with the given contents of the file, reading in small chunks to reduce memory.","result":"Update digests with file contents.","score":[0.0259,0.1617]}
{"code":"# is used to<extra_id_0>\r\ndef packages\r\n      @packages ||= begin\r\n        publish_packages = Array.new\r\n        build_packages   = FileSyncer.glob(@pattern).map { |path| Package.new(path) }\r\n        if @options[:platform_mappings]\r\n          @options[:platform_mappings].each_pair do |build_platform, publish_platforms|\r\n            build_platform, build_platform_version = build_platform.rpartition(\"-\") - %w{ - }\r\n            packages = build_packages.select do |p|\r\n              p.metadata[:platform] == build_platform &&\r\n                p.metadata[:platform_version] == build_platform_version\r\n            end\r\n            if packages.empty?\r\n              log.warn(log_key) do\r\n                \"Could not locate a package for build platform #{build_platform}-#{build_platform_version}. \" \\\r\n                \"Publishing will be skipped for: #{publish_platforms.join(', ')}\"\r\n              end\r\n            end\r\n            publish_platforms.each do |publish_platform|\r\n              publish_platform, publish_platform_version = publish_platform.rpartition(\"-\") - %w{ - }\r\n              packages.each do |p|\r\n                publish_package  = p.dup\r\n                publish_metadata = p.metadata.dup.to_hash\r\n                publish_metadata[:platform]         = publish_platform\r\n                publish_metadata[:platform_version] = publish_platform_version\r\n                publish_package.metadata = Metadata.new(publish_package, publish_metadata)\r\n                publish_packages << publish_package\r\n              end\r\n            end\r\n          end\r\n        else\r\n          publish_packages.concat(build_packages)\r\n        end\r\n        if publish_packages.empty?\r\n          log.info(log_key) { \"No packages found, skipping publish\" }\r\n        end\r\n        publish_packages\r\n      end\r\n    end","code-length":468,"reference":"Create a new publisher from the given pattern.","result":"Generate the packages.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef write_distribution_file\r\n      render_template(resource_path(\"distribution.xml.erb\"),\r\n        destination: \"#{staging_dir}\/Distribution\",\r\n        mode: 0600,\r\n        variables: {\r\n          friendly_name: project.friendly_name,\r\n          identifier: safe_identifier,\r\n          version: safe_version,\r\n          component_pkg: component_pkg,\r\n        }\r\n      )\r\n    end","code-length":115,"reference":"Write the Distribution file to the staging area.","result":"Generate the distribution file.","score":[0.1175,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef artifact_for(artifact)\r\n      md5  = artifact.respond_to?(:metadata) ? artifact.metadata[:md5] : digest(artifact.path, :md5)\r\n      sha1 = artifact.respond_to?(:metadata) ? artifact.metadata[:sha1] : digest(artifact.path, :sha1)\r\n      Artifactory::Resource::Artifact.new(\r\n        local_path: artifact.path,\r\n        client:     client,\r\n        checksums: {\r\n          \"md5\" => md5,\r\n          \"sha1\" => sha1,\r\n        }\r\n      )\r\n    end","code-length":157,"reference":"The artifact object that corresponds to this package.","result":"Create an artifact.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef build_for(packages)\r\n      metadata = packages.first.metadata\r\n      name     = metadata[:name]\r\n      manifest = if version_manifest = metadata[:version_manifest]\r\n                   Manifest.from_hash(version_manifest)\r\n                 else\r\n                   Manifest.new(\r\n                     metadata[:version],\r\n                     nil,\r\n                     metadata[:license]\r\n                   )\r\n                 end\r\n      log.info(log_key) { \"Saving build info for #{name}, Build\r\n      Artifactory::Resource::Build.new(\r\n        client: client,\r\n        name:   name,\r\n        number: manifest.build_version,\r\n        vcs_revision: manifest.build_git_revision,\r\n        build_agent: {\r\n          name: \"omnibus\",\r\n          version: Omnibus::VERSION,\r\n        },\r\n        modules: [\r\n          {\r\n            id: [\r\n              Config.artifactory_base_path.tr(\"\/\", \".\"),\r\n              name,\r\n              manifest.build_version,\r\n            ].join(\":\"),\r\n            artifacts: packages.map do |package|\r\n              [\r\n                {\r\n                  type: File.extname(package.path).split(\".\").last,\r\n                  sha1: package.metadata[:sha1],\r\n                  md5: package.metadata[:md5],\r\n                  name: package.metadata[:basename],\r\n                },\r\n                {\r\n                  type: File.extname(package.metadata.path).split(\".\").last,\r\n                  sha1: digest(package.metadata.path, :sha1),\r\n                  md5: digest(package.metadata.path, :md5),\r\n                  name: File.basename(package.metadata.path),\r\n                },\r\n              ]\r\n            end.flatten,\r\n          },\r\n        ]\r\n      )\r\n    end","code-length":460,"reference":"The build object that corresponds to this package.","result":"Build artifacts.","score":[0,0.0676]}
{"code":"# is used to<extra_id_0>\r\ndef client\r\n      @client ||= Artifactory::Client.new(\r\n        endpoint:       Config.artifactory_endpoint,\r\n        username:       Config.artifactory_username,\r\n        password:       Config.artifactory_password,\r\n        ssl_pem_file:   Config.artifactory_ssl_pem_file,\r\n        ssl_verify:     Config.artifactory_ssl_verify,\r\n        proxy_username: Config.artifactory_proxy_username,\r\n        proxy_password: Config.artifactory_proxy_password,\r\n        proxy_address:  Config.artifactory_proxy_address,\r\n        proxy_port:     Config.artifactory_proxy_port\r\n      )\r\n    end","code-length":184,"reference":"The Artifactory client object to communicate with the Artifactory API.","result":"Generate a new file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef metadata_properties_for(package)\r\n      metadata = {\r\n        \"omnibus.project\" => package.metadata[:name],\r\n        \"omnibus.platform\" => package.metadata[:platform],\r\n        \"omnibus.platform_version\" => package.metadata[:platform_version],\r\n        \"omnibus.architecture\" => package.metadata[:arch],\r\n        \"omnibus.version\" => package.metadata[:version],\r\n        \"omnibus.iteration\" => package.metadata[:iteration],\r\n        \"omnibus.license\" => package.metadata[:license],\r\n        \"omnibus.md5\" => package.metadata[:md5],\r\n        \"omnibus.sha1\" => package.metadata[:sha1],\r\n        \"omnibus.sha256\" => package.metadata[:sha256],\r\n        \"omnibus.sha512\" => package.metadata[:sha512],\r\n        \"md5\" => package.metadata[:md5],\r\n        \"sha1\" => package.metadata[:sha1],\r\n        \"sha256\" => package.metadata[:sha256],\r\n        \"sha512\" => package.metadata[:sha512],\r\n      }.tap do |h|\r\n        if build_record?\r\n          h[\"build.name\"] = package.metadata[:name]\r\n          h[\"build.number\"] = package.metadata[:version]\r\n        end\r\n      end\r\n      metadata\r\n    end","code-length":361,"reference":"The metadata for this package.","result":"Store metadata properties.","score":[0.2096,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef remote_path_for(package)\r\n      File.join(\r\n        Config.artifactory_base_path,\r\n        Config.artifactory_publish_pattern % package.metadata\r\n      )\r\n    end","code-length":62,"reference":"The path where the package will live inside of the Artifactory repository.","result":"Determine the remote path.","score":[0.0432,0.0446]}
{"code":"# is used to<extra_id_0>\r\ndef parameters(val = NULL)\r\n      if null?(val)\r\n        @parameters || {}\r\n      else\r\n        unless val.is_a?(Hash)\r\n          raise InvalidValue.new(:parameters, \"be a Hash\")\r\n        end\r\n        @parameters = val\r\n      end\r\n    end","code-length":84,"reference":"Set or retrieve the custom msi building parameters.","result":"Define the parameters.","score":[0.0917,0.1333]}
{"code":"# is used to<extra_id_0>\r\ndef wix_light_extension(extension)\r\n      unless extension.is_a?(String)\r\n        raise InvalidValue.new(:wix_light_extension, \"be an String\")\r\n      end\r\n      wix_light_extensions << extension\r\n    end","code-length":72,"reference":"Set the wix light extensions to load ","result":"Define the extension.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef wix_light_delay_validation(val = false)\r\n      unless val.is_a?(TrueClass) || val.is_a?(FalseClass)\r\n        raise InvalidValue.new(:iwix_light_delay_validation, \"be TrueClass or FalseClass\")\r\n      end\r\n      @delay_validation ||= val\r\n      unless @delay_validation\r\n        return \"\"\r\n      end\r\n      \"-sval\"\r\n    end","code-length":115,"reference":"Signal delay validation for wix light ","result":"Set the wix_light_delay_validation.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef wix_candle_extension(extension)\r\n      unless extension.is_a?(String)\r\n        raise InvalidValue.new(:wix_candle_extension, \"be an String\")\r\n      end\r\n      wix_candle_extensions << extension\r\n    end","code-length":78,"reference":"Set the wix candle extensions to load ","result":"Define the extension.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef write_localization_file\r\n      render_template(resource_path(\"localization-#{localization}.wxl.erb\"),\r\n        destination: \"#{staging_dir}\/localization-#{localization}.wxl\",\r\n        variables: {\r\n          name: project.package_name,\r\n          friendly_name: project.friendly_name,\r\n          maintainer: project.maintainer,\r\n        }\r\n      )\r\n    end","code-length":116,"reference":"Write the localization file into the staging directory.","result":"Write localization file.","score":[0.0917,0.1333]}
{"code":"# is used to<extra_id_0>\r\ndef write_parameters_file\r\n      render_template(resource_path(\"parameters.wxi.erb\"),\r\n        destination: \"#{staging_dir}\/parameters.wxi\",\r\n        variables: {\r\n          name: project.package_name,\r\n          friendly_name: project.friendly_name,\r\n          maintainer: project.maintainer,\r\n          upgrade_code: upgrade_code,\r\n          parameters: parameters,\r\n          version: windows_package_version,\r\n          display_version: msi_display_version,\r\n        }\r\n      )\r\n    end","code-length":148,"reference":"Write the parameters file into the staging directory.","result":"Write the parameters file.","score":[0.2421,0.1974]}
{"code":"# is used to<extra_id_0>\r\ndef write_source_file\r\n      paths = []\r\n      install_dir = project.install_dir.split(\"\/\")[1..-1].join(\"\/\")\r\n      Pathname.new(install_dir).ascend do |path|\r\n        paths << path.to_s\r\n      end\r\n      hierarchy = paths.reverse.inject({}) do |hash, path|\r\n        hash[File.basename(path)] = path.gsub(\/[^[:alnum:]]\/, \"\").upcase + \"LOCATION\"\r\n        hash\r\n      end\r\n      hierarchy[hierarchy.keys.last] = \"PROJECTLOCATION\"\r\n      wix_install_dir = if hierarchy.size > 1\r\n                          hierarchy.to_a[-2][1]\r\n                        else\r\n                          \"WINDOWSVOLUME\"\r\n                        end\r\n      render_template(resource_path(\"source.wxs.erb\"),\r\n        destination: \"#{staging_dir}\/source.wxs\",\r\n        variables: {\r\n          name: project.package_name,\r\n          friendly_name: project.friendly_name,\r\n          maintainer: project.maintainer,\r\n          hierarchy: hierarchy,\r\n          fastmsi: fast_msi,\r\n          wix_install_dir: wix_install_dir,\r\n        }\r\n      )\r\n    end","code-length":325,"reference":"Write the source file into the staging directory.","result":"Generate the source file.","score":[0.1662,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef write_bundle_file\r\n      render_template(resource_path(\"bundle.wxs.erb\"),\r\n        destination: \"#{staging_dir}\/bundle.wxs\",\r\n        variables: {\r\n          name: project.package_name,\r\n          friendly_name: project.friendly_name,\r\n          maintainer: project.maintainer,\r\n          upgrade_code: upgrade_code,\r\n          parameters: parameters,\r\n          version: windows_package_version,\r\n          display_version: msi_display_version,\r\n          msi: windows_safe_path(Config.package_dir, msi_name),\r\n        }\r\n      )\r\n    end","code-length":171,"reference":"Write the bundle file into the staging directory.","result":"Generate the bundle file.","score":[0.1662,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef resolve(dependency)\r\n      if from_dependency? && version_dependency == dependency.name\r\n        construct_build_version(dependency)\r\n        log.info(log_key) { \"Build Version is set to '#{build_version}'\" }\r\n      end\r\n    end","code-length":73,"reference":"Callback that is called by software objects to determine the version.","result":"Resolve dependencies.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef maybe_append_timestamp(version)\r\n      if Config.append_timestamp && !has_timestamp?(version)\r\n        [version, Omnibus::BuildVersion.build_start_time].join(\"+\")\r\n      else\r\n        version\r\n      end\r\n    end","code-length":76,"reference":"Append the build_start_time to the given string if","result":"Detect build version.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef has_timestamp?(version)\r\n      _ver, build_info = version.split(\"+\")\r\n      return false if build_info.nil?\r\n      build_info.split(\".\").any? do |part|\r\n        begin\r\n          Time.strptime(part, Omnibus::BuildVersion::TIMESTAMP_FORMAT)\r\n          true\r\n        rescue ArgumentError\r\n          false\r\n        end\r\n      end\r\n    end","code-length":113,"reference":"Returns true if a given version string Looks like it was already created with a function that added a timestamp.","result":"Detect if a version has a timestamp.","score":[0.0496,0.1989]}
{"code":"# is used to<extra_id_0>\r\ndef construct_build_version(version_source = nil)\r\n      case source_type\r\n      when :git\r\n        version = if version_source\r\n                    Omnibus::BuildVersion.new(version_source.project_dir)\r\n                  else\r\n                    Omnibus::BuildVersion.new\r\n                  end\r\n        output = output_method || :semver\r\n        self.build_version = version.send(output)\r\n      when :version\r\n        if version_source\r\n          self.build_version = version_source.version\r\n        else\r\n          raise \"Please tell me the source to get the version from\"\r\n        end\r\n      else\r\n        raise \"I don't know how to construct a build_version using source '#{source_type}'\"\r\n      end\r\n    end","code-length":198,"reference":"Determines the build_version based on source_type, output_method.","result":"Construct the build_version.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef render_template_content(source, variables = {})\r\n      template = ERB.new(File.read(source), nil, \"-\")\r\n      struct =\r\n        if variables.empty?\r\n          Struct.new(\"Empty\")\r\n        else\r\n          Struct.new(*variables.keys).new(*variables.values)\r\n        end\r\n      template.result(struct.instance_eval { binding })\r\n    end","code-length":109,"reference":"Render an erb template to a String variable.","result":"Render the template content.","score":[0.1398,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef deprecated(progname, &block)\r\n      meta = Proc.new { \"DEPRECATED: #{yield}\" }\r\n      add(LEVELS.index(\"WARN\"), progname, &meta)\r\n    end","code-length":57,"reference":"Print a deprecation warning.","result":"Mark functions as deprecated.","score":[0,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef add(severity, progname, &block)\r\n      return true if io.nil? || severity < level\r\n      message = format_message(severity, progname, yield)\r\n      MUTEX.synchronize { io.write(message) }\r\n      true\r\n    end","code-length":76,"reference":"Add a message to the logger with the given severity and progname.","result":"Add a message to the log.","score":[0.2956,0.4246]}
{"code":"# is used to<extra_id_0>\r\ndef command(command, options = {})\r\n      warn_for_shell_commands(command)\r\n      build_commands << BuildCommand.new(\"Execute: `#{command}'\") do\r\n        shellout!(command, options)\r\n      end\r\n    end","code-length":71,"reference":"Create a new builder object for evaluation.","result":"Define the command.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef make(*args)\r\n      options = args.last.is_a?(Hash) ? args.pop : {}\r\n      make = options.delete(:bin) ||\r\n        if !windows? && Omnibus.which(\"gmake\")\r\n          env = options.delete(:env) || {}\r\n          env = { \"MAKE\" => \"gmake\" }.merge(env)\r\n          options[:env] = env\r\n          \"gmake\"\r\n        else\r\n          \"make\"\r\n        end\r\n      options[:in_msys_bash] = true\r\n      make_cmd = ([make] + args).join(\" \").strip\r\n      command(make_cmd, options)\r\n    end","code-length":177,"reference":"Execute the given make command.","result":"Generate a new file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef appbundle(software_name, lockdir: nil, gem: nil, without: nil, extra_bin_files: nil , **options)\r\n      build_commands << BuildCommand.new(\"appbundle `#{software_name}'\") do\r\n        bin_dir            = \"#{install_dir}\/bin\"\r\n        appbundler_bin     = embedded_bin(\"appbundler\")\r\n        lockdir ||=\r\n          begin\r\n            app_software = project.softwares.find do |p|\r\n              p.name == software_name\r\n            end\r\n            if app_software.nil?\r\n              raise \"could not find software definition for #{software_name}, add a dependency to it, or pass a lockdir argument to appbundle command.\"\r\n            end\r\n            app_software.project_dir\r\n          end\r\n        command = [ appbundler_bin, \"'#{lockdir}'\", \"'#{bin_dir}'\" ]\r\n        command << [ \"'#{gem}'\" ] if gem\r\n        command << [ \"--without\", without.join(\",\") ] unless without.nil?\r\n        command << [ \"--extra-bin-files\", extra_bin_files.join(\",\") ] unless extra_bin_files.nil? || extra_bin_files.empty?\r\n        FileUtils.mkdir_p(bin_dir)\r\n        shellout!(command.join(\" \"), options)\r\n      end\r\n    end","code-length":342,"reference":"Execute the given appbundler command against the embedded Ruby's appbundler.","result":"Build the appbundle command.","score":[0.0713,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef rake(command, options = {})\r\n      build_commands << BuildCommand.new(\"rake `#{command}'\") do\r\n        bin = embedded_bin(\"rake\")\r\n        shellout!(\"#{bin} #{command}\", options)\r\n      end\r\n    end","code-length":76,"reference":"Execute the given Rake command against the embedded Ruby's rake.","result":"Run rake.","score":[0.0092,0.0543]}
{"code":"# is used to<extra_id_0>\r\ndef touch(file, options = {})\r\n      build_commands << BuildCommand.new(\"touch `#{file}'\") do\r\n        Dir.chdir(software.project_dir) do\r\n          parent = File.dirname(file)\r\n          FileUtils.mkdir_p(parent) unless File.directory?(parent)\r\n          FileUtils.touch(file, options)\r\n        end\r\n      end\r\n    end","code-length":106,"reference":"Touch the given filepath at runtime.","result":"Touch a file.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef delete(path, options = {})\r\n      build_commands << BuildCommand.new(\"delete `#{path}'\") do\r\n        Dir.chdir(software.project_dir) do\r\n          FileSyncer.glob(path).each do |file|\r\n            FileUtils.rm_rf(file, options)\r\n          end\r\n        end\r\n      end\r\n    end","code-length":98,"reference":"Delete the given file or directory on the system.","result":"Delete a file.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef copy(source, destination, options = {})\r\n      command = \"copy `#{source}' to `#{destination}'\"\r\n      build_commands << BuildCommand.new(command) do\r\n        Dir.chdir(software.project_dir) do\r\n          files = FileSyncer.glob(source)\r\n          if files.empty?\r\n            log.warn(log_key) { \"no matched files for glob #{command}\" }\r\n          else\r\n            files.each do |file|\r\n              FileUtils.cp_r(file, destination, options)\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end","code-length":159,"reference":"Copy the given source to the destination.","result":"Copy files to the project.","score":[0.2521,0.3758]}
{"code":"# is used to<extra_id_0>\r\ndef update_config_guess(target: \".\", install: [:config_guess, :config_sub])\r\n      build_commands << BuildCommand.new(\"update_config_guess `target: #{target} install: #{install.inspect}'\") do\r\n        config_guess_dir = \"#{install_dir}\/embedded\/lib\/config_guess\"\r\n        %w{config.guess config.sub}.each do |c|\r\n          unless File.exist?(File.join(config_guess_dir, c))\r\n            raise \"Can not find #{c}. Make sure you add a dependency on 'config_guess' in your software definition\"\r\n          end\r\n        end\r\n        destination = File.join(software.project_dir, target)\r\n        FileUtils.mkdir_p(destination)\r\n        FileUtils.cp_r(\"#{config_guess_dir}\/config.guess\", destination) if install.include? :config_guess\r\n        FileUtils.cp_r(\"#{config_guess_dir}\/config.sub\", destination) if install.include? :config_sub\r\n      end\r\n    end","code-length":261,"reference":"Helper method to update config_guess in the software's source directory.","result":"Update the config_guess.","score":[0.0396,0.1075]}
{"code":"# is used to<extra_id_0>\r\ndef write_tgz\r\n      contents = gzipped_tarball\r\n      File.open(\"#{staging_dir}\/#{package_name}\", \"wb\") do |tgz|\r\n        while chunk = contents.read(1024)\r\n          tgz.write(chunk)\r\n        end\r\n      end\r\n      FileSyncer.glob(\"#{staging_dir}\/*.tar.gz\").each do |tgz|\r\n        copy_file(tgz, Config.package_dir)\r\n      end\r\n    end","code-length":131,"reference":"memory usage.","result":"Write the tarball.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef tarball\r\n      tarfile = StringIO.new(\"\")\r\n      Gem::Package::TarWriter.new(tarfile) do |tar|\r\n        path = \"#{staging_dir}\/#{packager.package_name}\"\r\n        name = packager.package_name\r\n        mode = File.stat(path).mode\r\n        tar.add_file(name, mode) do |tf|\r\n          File.open(path, \"rb\") do |file|\r\n            tf.write(file.read)\r\n          end\r\n        end\r\n      end\r\n      tarfile.rewind\r\n      tarfile\r\n    end","code-length":153,"reference":"Create an in-memory tarball from the given packager.","result":"Create a tarball.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef clean\r\n      needs_cleaning = File.exist?(project_dir)\r\n      if needs_cleaning\r\n        log.info(log_key) { \"Cleaning project directory `#{project_dir}'\" }\r\n        FileUtils.rm_rf(project_dir)\r\n      end\r\n      create_required_directories\r\n      deploy\r\n      needs_cleaning\r\n    end","code-length":100,"reference":"Clean the project directory if it exists and actually extract the downloaded file.","result":"Clean the project directory.","score":[0.0694,0.124]}
{"code":"# is used to<extra_id_0>\r\ndef deploy\r\n      if downloaded_file.end_with?(*ALL_EXTENSIONS)\r\n        log.info(log_key) { \"Extracting `#{safe_downloaded_file}' to `#{safe_project_dir}'\" }\r\n        extract\r\n      else\r\n        log.info(log_key) { \"`#{safe_downloaded_file}' is not an archive - copying to `#{safe_project_dir}'\" }\r\n        if File.directory?(downloaded_file)\r\n          FileUtils.cp_r(\"#{downloaded_file}\/.\", project_dir)\r\n        else\r\n          FileUtils.cp(downloaded_file, project_dir)\r\n        end\r\n      end\r\n    end","code-length":175,"reference":"Extract the downloaded file, using the magical logic based off of the ending file extension.","result":"Deploy the project.","score":[0.0075,0.0362]}
{"code":"# is used to<extra_id_0>\r\ndef extract\r\n      compression_switch = \"\"\r\n      compression_switch = \"z\"        if downloaded_file.end_with?(\"gz\")\r\n      compression_switch = \"--lzma -\" if downloaded_file.end_with?(\"lzma\")\r\n      compression_switch = \"j\"        if downloaded_file.end_with?(\"bz2\")\r\n      compression_switch = \"J\"        if downloaded_file.end_with?(\"xz\")\r\n      if Ohai[\"platform\"] == \"windows\"\r\n        if downloaded_file.end_with?(*TAR_EXTENSIONS) && source[:extract] != :seven_zip\r\n          returns = [0]\r\n          returns << 1 if source[:extract] == :lax_tar\r\n          shellout!(\"tar #{compression_switch}xf #{safe_downloaded_file} -C#{safe_project_dir}\", returns: returns)\r\n        elsif downloaded_file.end_with?(*COMPRESSED_TAR_EXTENSIONS)\r\n          Dir.mktmpdir do |temp_dir|\r\n            log.debug(log_key) { \"Temporarily extracting `#{safe_downloaded_file}' to `#{temp_dir}'\" }\r\n            shellout!(\"7z.exe x #{safe_downloaded_file} -o#{windows_safe_path(temp_dir)} -r -y\")\r\n            fname = File.basename(downloaded_file, File.extname(downloaded_file))\r\n            fname << \".tar\" if downloaded_file.end_with?(\"tgz\", \"txz\")\r\n            next_file = windows_safe_path(File.join(temp_dir, fname))\r\n            log.debug(log_key) { \"Temporarily extracting `#{next_file}' to `#{safe_project_dir}'\" }\r\n            shellout!(\"7z.exe x #{next_file} -o#{safe_project_dir} -r -y\")\r\n          end\r\n        else\r\n          shellout!(\"7z.exe x #{safe_downloaded_file} -o#{safe_project_dir} -r -y\")\r\n        end\r\n      elsif downloaded_file.end_with?(\".7z\")\r\n        shellout!(\"7z x #{safe_downloaded_file} -o#{safe_project_dir} -r -y\")\r\n      elsif downloaded_file.end_with?(\".zip\")\r\n        shellout!(\"unzip #{safe_downloaded_file} -d #{safe_project_dir}\")\r\n      else\r\n        shellout!(\"#{tar} #{compression_switch}xf #{safe_downloaded_file} -C#{safe_project_dir}\")\r\n      end\r\n    end","code-length":657,"reference":"Extracts the downloaded archive file into project_dir.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef digest_type\r\n      DIGESTS.each do |digest|\r\n        return digest if source.key? digest\r\n      end\r\n      raise ChecksumMissing.new(self)\r\n    end","code-length":55,"reference":"The digest type defined in the software definition ","result":"Generate the digest.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef verify_checksum!\r\n      log.info(log_key) { \"Verifying checksum\" }\r\n      expected = checksum\r\n      actual   = digest(downloaded_file, digest_type)\r\n      if expected != actual\r\n        raise ChecksumMismatch.new(self, expected, actual)\r\n      end\r\n    end","code-length":85,"reference":"Verify the downloaded file has the correct checksum.","result":"Verify the checksum.","score":[0.1207,0.2]}
{"code":"# is used to<extra_id_0>\r\ndef signing_identity(thumbprint = NULL, params = NULL)\r\n      unless null?(thumbprint)\r\n        @signing_identity = {}\r\n        unless thumbprint.is_a?(String)\r\n          raise InvalidValue.new(:signing_identity, \"be a String\")\r\n        end\r\n        @signing_identity[:thumbprint] = thumbprint\r\n        if !null?(params)\r\n          unless params.is_a?(Hash)\r\n            raise InvalidValue.new(:params, \"be a Hash\")\r\n          end\r\n          valid_keys = [:store, :timestamp_servers, :machine_store, :algorithm]\r\n          invalid_keys = params.keys - valid_keys\r\n          unless invalid_keys.empty?\r\n            raise InvalidValue.new(:params, \"contain keys from [#{valid_keys.join(', ')}]. \"\\\r\n                                   \"Found invalid keys [#{invalid_keys.join(', ')}]\")\r\n          end\r\n          if !params[:machine_store].nil? && !(\r\n             params[:machine_store].is_a?(TrueClass) ||\r\n             params[:machine_store].is_a?(FalseClass))\r\n            raise InvalidValue.new(:params, \"contain key :machine_store of type TrueClass or FalseClass\")\r\n          end\r\n        else\r\n          params = {}\r\n        end\r\n        @signing_identity[:store] = params[:store] || \"My\"\r\n        @signing_identity[:algorithm] = params[:algorithm] || \"SHA256\"\r\n        servers = params[:timestamp_servers] || DEFAULT_TIMESTAMP_SERVERS\r\n        @signing_identity[:timestamp_servers] = [servers].flatten\r\n        @signing_identity[:machine_store] = params[:machine_store] || false\r\n      end\r\n      @signing_identity\r\n    end","code-length":440,"reference":"Set the signing certificate name ","result":"Generate a signing identity.","score":[0.2488,0.102]}
{"code":"# is used to<extra_id_0>\r\ndef sign_package(package_file)\r\n      success = false\r\n      timestamp_servers.each do |ts|\r\n        success = try_sign(package_file, ts)\r\n        break if success\r\n      end\r\n      raise FailedToSignWindowsPackage.new if !success\r\n    end","code-length":79,"reference":"Iterates through available timestamp servers and tries to sign the file with with each server, stopping after the first to succeed.","result":"Sign packages.","score":[0,0.0262]}
{"code":"# is used to<extra_id_0>\r\ndef certificate_subject\r\n      return \"CN=#{project.package_name}\" unless signing_identity\r\n      store = machine_store? ? \"LocalMachine\" : \"CurrentUser\"\r\n      cmd = Array.new.tap do |arr|\r\n        arr << \"powershell.exe\"\r\n        arr << \"-ExecutionPolicy Bypass\"\r\n        arr << \"-NoProfile\"\r\n        arr << \"-Command (Get-Item Cert:\/#{store}\/#{cert_store_name}\/#{thumbprint}).Subject\"\r\n      end.join(\" \")\r\n      shellout!(cmd).stdout.strip\r\n    end","code-length":149,"reference":"Get the certificate subject of the signing identity ","result":"Generate the certificate subject.","score":[0.1662,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef manifest_entry\r\n      @manifest_entry ||= if manifest\r\n                            log.info(log_key) { \"Using user-supplied manifest entry for #{name}\" }\r\n                            manifest.entry_for(name)\r\n                          else\r\n                            log.info(log_key) { \"Resolving manifest entry for #{name}\" }\r\n                            to_manifest_entry\r\n                          end\r\n    end","code-length":101,"reference":"Create a new software object.","result":"Resolve manifest entries.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef source(val = NULL)\r\n      unless null?(val)\r\n        unless val.is_a?(Hash)\r\n          raise InvalidValue.new(:source,\r\n            \"be a kind of `Hash', but was `#{val.class.inspect}'\")\r\n        end\r\n        val = canonicalize_source(val)\r\n        extra_keys = val.keys - [\r\n          :git, :file, :path, :url,\r\n          :md5, :sha1, :sha256, :sha512,\r\n          :cookie, :warning, :unsafe, :extract, :cached_name, :authorization,\r\n          :options,\r\n          :submodules\r\n        ]\r\n        unless extra_keys.empty?\r\n          raise InvalidValue.new(:source,\r\n            \"only include valid keys. Invalid keys: #{extra_keys.inspect}\")\r\n        end\r\n        duplicate_keys = val.keys & [:git, :file, :path, :url]\r\n        unless duplicate_keys.size < 2\r\n          raise InvalidValue.new(:source,\r\n            \"not include duplicate keys. Duplicate keys: #{duplicate_keys.inspect}\")\r\n        end\r\n        @source ||= {}\r\n        @source.merge!(val)\r\n      end\r\n      override = canonicalize_source(overrides[:source])\r\n      apply_overrides(:source, override)\r\n    end","code-length":337,"reference":"Set or retrieve the source for the software.","result":"Set the source for the.","score":[0.2919,0.4099]}
{"code":"# is used to<extra_id_0>\r\ndef version(val = NULL, &block)\r\n      final_version = apply_overrides(:version)\r\n      if block_given?\r\n        if val.equal?(NULL)\r\n          raise InvalidValue.new(:version,\r\n            \"pass a block when given a version argument\")\r\n        else\r\n          if val == final_version\r\n            current_license_files = @license_files\r\n            @license_files = []\r\n            yield\r\n            new_license_files = @license_files\r\n            if new_license_files.empty?\r\n              @license_files = current_license_files\r\n            end\r\n          end\r\n        end\r\n      end\r\n      return if final_version.nil?\r\n      begin\r\n        Chef::Sugar::Constraints::Version.new(final_version)\r\n      rescue ArgumentError\r\n        log.warn(log_key) do\r\n          \"Version #{final_version} for software #{name} was not parseable. \" \\\r\n          \"Comparison methods such as\r\n        end\r\n        final_version\r\n      end\r\n    end","code-length":266,"reference":"Evaluate a block only if the version matches.","result":"Set the version of the software.","score":[0.1956,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef whitelist_file(file)\r\n      file = Regexp.new(file) unless file.kind_of?(Regexp)\r\n      whitelist_files << file\r\n      whitelist_files.dup\r\n    end","code-length":57,"reference":"Add a file to the healthcheck whitelist.","result":"Add a file to the whitelist.","score":[0.7118,0.8535]}
{"code":"# is used to<extra_id_0>\r\ndef project_file\r\n      if fetcher && fetcher.is_a?(NetFetcher)\r\n        log.deprecated(log_key) do\r\n          \"project_file (DSL). This is a property of the NetFetcher and will \" \\\r\n          \"not be publically exposed in the next major release. In general, \" \\\r\n          \"you should not be using this method in your software definitions \" \\\r\n          \"as it is an internal implementation detail of the NetFetcher. If \" \\\r\n          \"you disagree with this statement, you should open an issue on the \" \\\r\n          \"Omnibus repository on GitHub an explain your use case. For now, \" \\\r\n          \"I will return the path to the downloaded file on disk, but please \" \\\r\n          \"rethink the problem you are trying to solve :).\"\r\n        end\r\n        fetcher.downloaded_file\r\n      else\r\n        log.warn(log_key) do\r\n          \"Cannot retrieve a `project_file' for software `#{name}'. This \" \\\r\n          \"attribute is actually an internal representation that is unique \" \\\r\n          \"to the NetFetcher class and requires the use of a `source' \" \\\r\n          \"attribute that is declared using a `:url' key. For backwards-\" \\\r\n          \"compatability, I will return `nil', but this is most likely not \" \\\r\n          \"your desired behavior.\"\r\n        end\r\n        nil\r\n      end\r\n    end","code-length":350,"reference":"The path to the downloaded file from a NetFetcher.","result":"Retrieve the project file from the software definition.","score":[0.1918,0.3546]}
{"code":"# is used to<extra_id_0>\r\ndef prepend_path(*paths)\r\n      path_values = Array(paths)\r\n      path_values << ENV[path_key]\r\n      separator = File::PATH_SEPARATOR || \":\"\r\n      path_values.join(separator)\r\n    end","code-length":67,"reference":"A PATH variable format string representing the current PATH with the given path prepended.","result":"Add paths to the path.","score":[0.0397,0.0763]}
{"code":"# is used to<extra_id_0>\r\ndef overrides\r\n      if null?(@overrides)\r\n        @overrides = {}\r\n        @overrides = project.overrides[name.to_sym].dup if project.overrides[name.to_sym]\r\n      end\r\n      @overrides\r\n    end","code-length":68,"reference":"The repo-level and project-level overrides for the software.","result":"Define the overrides.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef version_for_cache\r\n      @version_for_cache ||= if fetcher.version_for_cache\r\n                               fetcher.version_for_cache\r\n                             elsif version\r\n                               version\r\n                             else\r\n                               log.warn(log_key) do\r\n                                 \"No version given! This is probably a bad thing. I am going to \" \\\r\n                                 \"assume the version `0.0.0', but that is most certainly not your \" \\\r\n                                 \"desired behavior. If git caching seems off, this is probably why.\"\r\n                               end\r\n                               \"0.0.0\"\r\n                             end\r\n    end","code-length":159,"reference":"Returns the version to be used in cache.","result":"Determine the version for the cache.","score":[0.2165,0.1923]}
{"code":"# is used to<extra_id_0>\r\ndef fetcher\r\n      @fetcher ||=\r\n        if source_type == :url && File.basename(source[:url], \"?*\").end_with?(*NetFetcher::ALL_EXTENSIONS)\r\n          Fetcher.fetcher_class_for_source(source).new(manifest_entry, fetch_dir, build_dir)\r\n        else\r\n          Fetcher.fetcher_class_for_source(source).new(manifest_entry, project_dir, build_dir)\r\n        end\r\n    end","code-length":127,"reference":"The fetcher for this software","result":"Define the fetcher.","score":[0,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef shasum\r\n      @shasum ||= begin\r\n        digest = Digest::SHA256.new\r\n        update_with_string(digest, project.shasum)\r\n        update_with_string(digest, builder.shasum)\r\n        update_with_string(digest, name)\r\n        update_with_string(digest, version_for_cache)\r\n        update_with_string(digest, FFI_Yajl::Encoder.encode(overrides))\r\n        if filepath && File.exist?(filepath)\r\n          update_with_file_contents(digest, filepath)\r\n        else\r\n          update_with_string(digest, \"<DYNAMIC>\")\r\n        end\r\n        digest.hexdigest\r\n      end\r\n    end","code-length":188,"reference":"The unique SHA256 for this sofware definition.","result":"Generate the shasum.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef canonicalize_source(source)\r\n      if source.is_a?(Hash) && source[:github]\r\n        source = source.dup\r\n        source[:git] = \"https:\/\/github.com\/#{source[:github]}.git\"\r\n        source.delete(:github)\r\n      end\r\n      source\r\n    end","code-length":85,"reference":"Transform github -> git in source","result":"Canonicalize the source.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef write_makeselfinst\r\n      makeselfinst_staging_path = File.join(staging_dir, \"makeselfinst\")\r\n      render_template(resource_path(\"makeselfinst.erb\"),\r\n        destination: makeselfinst_staging_path,\r\n        variables: {\r\n          install_dir: project.install_dir,\r\n        }\r\n      )\r\n      FileUtils.chmod(0755, makeselfinst_staging_path)\r\n    end","code-length":134,"reference":"Render a makeselfinst in the staging directory using the supplied ERB template.","result":"Write the makeselfinst file.","score":[0.0514,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef create_cache_path\r\n      if File.directory?(cache_path)\r\n        false\r\n      else\r\n        create_directory(File.dirname(cache_path))\r\n        git_cmd(\"init -q\")\r\n        git_cmd(\"config --local user.name \\\"Omnibus Git Cache\\\"\")\r\n        git_cmd(\"config --local user.email \\\"omnibus@localhost\\\"\")\r\n        true\r\n      end\r\n    end","code-length":118,"reference":"Creates the full path if it does not exist already.","result":"Create the cache directory.","score":[0.0713,0.1995]}
{"code":"# is used to<extra_id_0>\r\ndef tag\r\n      return @tag if @tag\r\n      log.internal(log_key) { \"Calculating tag\" }\r\n      dep_list = software.project.library.build_order.take_while do |dep|\r\n        if dep.name == software.name && dep.version == software.version\r\n          false\r\n        else\r\n          true\r\n        end\r\n      end\r\n      log.internal(log_key) { \"dep_list: #{dep_list.map(&:name).inspect}\" }\r\n      shasums = [dep_list.map(&:shasum), software.shasum].flatten\r\n      suffix  = Digest::SHA256.hexdigest(shasums.join(\"|\"))\r\n      @tag    = \"#{software.name}-#{suffix}-#{SERIAL_NUMBER}\"\r\n      log.internal(log_key) { \"tag: #{@tag}\" }\r\n      @tag\r\n    end","code-length":232,"reference":"Computes the tag for this cache entry.","result":"Calculate the tag.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef incremental\r\n      log.internal(log_key) { \"Performing incremental cache\" }\r\n      create_cache_path\r\n      remove_git_dirs\r\n      git_cmd(\"add -A -f\")\r\n      begin\r\n        git_cmd(%Q{commit -q -m \"Backup of #{tag}\"})\r\n      rescue CommandFailed => e\r\n        raise unless e.message.include?(\"nothing to commit\")\r\n      end\r\n      git_cmd(%Q{tag -f \"#{tag}\"})\r\n    end","code-length":132,"reference":"Create an incremental install path cache for the software step","result":"Store the cache.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef remove_git_dirs\r\n      log.internal(log_key) { \"Removing git directories\" }\r\n      Dir.glob(\"#{install_dir}\/**\/{,.*}\/config\").reject do |path|\r\n        REQUIRED_GIT_FILES.any? do |required_file|\r\n          !File.exist?(File.join(File.dirname(path), required_file))\r\n        end\r\n      end.each do |path|\r\n        log.internal(log_key) { \"Removing git dir `#{path}'\" }\r\n        FileUtils.rm_rf(File.dirname(path))\r\n      end\r\n      true\r\n    end","code-length":160,"reference":"Git caching will attempt to version embedded git directories, partially versioning them.","result":"Remove git directories.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef write_manifest_file\r\n      render_template(resource_path(\"AppxManifest.xml.erb\"),\r\n        destination: \"#{windows_safe_path(project.install_dir)}\/AppxManifest.xml\",\r\n        variables: {\r\n          name: project.package_name,\r\n          friendly_name: project.friendly_name,\r\n          version: windows_package_version,\r\n          maintainer: project.maintainer,\r\n          certificate_subject: certificate_subject.gsub('\"', \"&quot;\"),\r\n        }\r\n      )\r\n    end","code-length":145,"reference":"Write the manifest file into the staging directory.","result":"Generate the manifest file.","score":[0.1662,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef shellout(*args)\r\n      options = args.last.kind_of?(Hash) ? args.pop : {}\r\n      options = SHELLOUT_OPTIONS.merge(options)\r\n      command_string = args.join(\" \")\r\n      in_msys = options.delete(:in_msys_bash) && ENV[\"MSYSTEM\"]\r\n      command_string = \"bash -c \\'#{command_string}\\'\" if in_msys\r\n      log_level = options.delete(:log_level)\r\n      options[:live_stream] ||= log.live_stream(:internal)\r\n      if options[:env]\r\n        options[:environment] = options.fetch(:environment, {}).merge(options[:env])\r\n      end\r\n      unless options[:environment].empty?\r\n        log.public_send(log_level, log_key) { \"Environment:\" }\r\n        options[:environment].sort.each do |key, value|\r\n          log.public_send(log_level, log_key) { \"  #{key}=#{value.inspect}\" }\r\n        end\r\n      end\r\n      log.public_send(log_level, log_key) { \"$ #{command_string}\" }\r\n      cmd = Mixlib::ShellOut.new(command_string, options)\r\n      cmd.environment[\"HOME\"] = \"\/tmp\" unless ENV[\"HOME\"]\r\n      cmd.run_command\r\n      cmd\r\n    end","code-length":345,"reference":"Shells out and runs +command+.","result":"Run a command.","score":[0,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef shellout!(*args)\r\n      cmd = shellout(*args)\r\n      cmd.error!\r\n      cmd\r\n    rescue Mixlib::ShellOut::ShellCommandFailed\r\n      raise CommandFailed.new(cmd)\r\n    rescue Mixlib::ShellOut::CommandTimeout\r\n      raise CommandTimeout.new(cmd)\r\n    end","code-length":90,"reference":"Similar to +shellout+ method except it raises an exception if the command fails.","result":"Create a command.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef retry_block(logstr, retried_exceptions = [], retries = Omnibus::Config.fetcher_retries, &block)\r\n      yield\r\n    rescue Exception => e\r\n      raise e unless retried_exceptions.any? { |eclass| e.is_a?(eclass) }\r\n      if retries != 0\r\n        log.info(log_key) { \"Retrying failed #{logstr} due to #{e} (#{retries} retries left)...\" }\r\n        retries -= 1\r\n        retry\r\n      else\r\n        log.error(log_key) { \"#{logstr} failed - #{e.class}!\" }\r\n        raise\r\n      end\r\n    end","code-length":170,"reference":"Retry the given block if a retriable exception is raised.","result":"Retry fetchers.","score":[0.0092,0.0543]}
{"code":"# is used to<extra_id_0>\r\ndef windows_safe_path(*pieces)\r\n      path = File.join(*pieces)\r\n      if File::ALT_SEPARATOR\r\n        path.gsub(File::SEPARATOR, File::ALT_SEPARATOR)\r\n      else\r\n        path\r\n      end\r\n    end","code-length":72,"reference":"Convert the given path to be appropiate for shelling out on Windows.","result":"Avoid windows-safe path escaping.","score":[0.0432,0.0446]}
{"code":"# is used to<extra_id_0>\r\ndef compiler_safe_path(*pieces)\r\n      path = File.join(*pieces)\r\n      path = path.sub(\/^([A-Za-z]):\\\/\/, \"\/\\\\1\/\") if ENV[\"MSYSTEM\"]\r\n      path\r\n    end","code-length":70,"reference":"Convert the given path to be appropriate for usage with the given compiler   the pieces of the path to join and fix ","result":"Avoid the compiler to generate a safe path.","score":[0.0318,0.0728]}
{"code":"# is used to<extra_id_0>\r\ndef create_directory(*paths)\r\n      path = File.join(*paths)\r\n      log.debug(log_key) { \"Creating directory `#{path}'\" }\r\n      FileUtils.mkdir_p(path)\r\n      path\r\n    end","code-length":66,"reference":"Create a directory at the given +path+.","result":"Create a directory.","score":[0.1522,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef remove_directory(*paths)\r\n      path = File.join(*paths)\r\n      log.debug(log_key) { \"Remove directory `#{path}'\" }\r\n      FileUtils.rm_rf(path)\r\n      path\r\n    end","code-length":66,"reference":"Remove the directory at the given +path+.","result":"Remove a directory.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef copy_file(source, destination)\r\n      log.debug(log_key) { \"Copying `#{source}' to `#{destination}'\" }\r\n      FileUtils.cp(source, destination)\r\n      destination\r\n    end","code-length":62,"reference":"Copy the +source+ file to the +destination+.","result":"In the destination.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef remove_file(*paths)\r\n      path = File.join(*paths)\r\n      log.debug(log_key) { \"Removing file `#{path}'\" }\r\n      FileUtils.rm_f(path)\r\n      path\r\n    end","code-length":66,"reference":"Remove the file at the given path.","result":"Remove files.","score":[0.041,0.0769]}
{"code":"# is used to<extra_id_0>\r\ndef create_file(*paths, &block)\r\n      path = File.join(*paths)\r\n      log.debug(log_key) { \"Creating file `#{path}'\" }\r\n      FileUtils.mkdir_p(File.dirname(path))\r\n      if block\r\n        File.open(path, \"wb\") { |f| f.write(yield) }\r\n      else\r\n        FileUtils.touch(path)\r\n      end\r\n      path\r\n    end","code-length":118,"reference":"Create a file at the given path.","result":"Create a file.","score":[0.1522,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef create_link(a, b)\r\n      log.debug(log_key) { \"Linking `#{a}' to `#{b}'\" }\r\n      FileUtils.ln_s(a, b)\r\n    end","code-length":60,"reference":"Create a symlink from a to b ","result":"Create links.","score":[0.041,0.0769]}
{"code":"# is used to<extra_id_0>\r\ndef validate_license_info\r\n      if project.license == \"Unspecified\"\r\n        licensing_warning(\"Project '#{project.name}' does not contain licensing information.\")\r\n      end\r\n      if project.license != \"Unspecified\" && project.license_file.nil?\r\n        licensing_warning(\"Project '#{project.name}' does not point to a license file.\")\r\n      end\r\n      if project.license != \"Unspecified\" && !STANDARD_LICENSES.include?(project.license)\r\n        licensing_info(\"Project '#{project.name}' is using '#{project.license}' which is not one of the standard licenses identified in https:\/\/opensource.org\/licenses\/alphabetical. Consider using one of the standard licenses.\")\r\n      end\r\n      license_map.each do |software_name, license_info|\r\n        if license_info[:license] == \"Unspecified\"\r\n          licensing_warning(\"Software '#{software_name}' does not contain licensing information.\")\r\n        end\r\n        if license_info[:license] != \"Unspecified\" && license_info[:license_files].empty?\r\n          licensing_warning(\"Software '#{software_name}' does not point to any license files.\")\r\n        end\r\n        if license_info[:license] != \"Unspecified\" && !STANDARD_LICENSES.include?(license_info[:license])\r\n          licensing_info(\"Software '#{software_name}' uses license '#{license_info[:license]}' which is not one of the standard licenses identified in https:\/\/opensource.org\/licenses\/alphabetical. Consider using one of the standard licenses.\")\r\n        end\r\n      end\r\n    end","code-length":421,"reference":"Inspects the licensing information for the project and the included software components.","result":"Validate the project license information.","score":[0.0838,0.1327]}
{"code":"# is used to<extra_id_0>\r\ndef project_license_content\r\n      project.license_file.nil? ? \"\" : IO.read(File.join(Config.project_root, project.license_file))\r\n    end","code-length":53,"reference":"Contents of the project's license ","result":"Generate the project license content.","score":[0.2857,0.2]}
{"code":"# is used to<extra_id_0>\r\ndef license_map\r\n      @license_map ||= begin\r\n        map = {}\r\n        project.library.each do |component|\r\n          next if component.license == :project_license\r\n          map[component.name] = {\r\n            license: component.license,\r\n            license_files: component.license_files,\r\n            version: component.version,\r\n            project_dir: component.project_dir,\r\n          }\r\n        end\r\n        map\r\n      end\r\n    end","code-length":128,"reference":"Map that collects information about the licenses of the softwares included in the project.","result":"Map the license to the project.","score":[0.0856,0.2818]}
{"code":"# is used to<extra_id_0>\r\ndef process_transitive_dependency_licensing_info\r\n      Dir.glob(\"#{cache_dir}\/*\/*-dependency-licenses.json\").each do |license_manifest_path|\r\n        license_manifest_data = FFI_Yajl::Parser.parse(File.read(license_manifest_path))\r\n        project_name = license_manifest_data[\"project_name\"]\r\n        dependency_license_dir = File.dirname(license_manifest_path)\r\n        license_manifest_data[\"dependency_managers\"].each do |dep_mgr_name, dependencies|\r\n          dep_license_map[dep_mgr_name] ||= {}\r\n          dependencies.each do |dependency|\r\n            dependency[\"license_files\"].each do |f|\r\n              license_path = File.join(dependency_license_dir, f)\r\n              output_path = File.join(output_dir, f)\r\n              FileUtils.cp(license_path, output_path)\r\n            end\r\n            dep_name = dependency[\"name\"]\r\n            dep_version = dependency[\"version\"]\r\n            if dep_license_map[dep_mgr_name][dep_name] && dep_license_map[dep_mgr_name][dep_name][dep_version]\r\n              dep_license_map[dep_mgr_name][dep_name][dep_version][\"dependency_of\"] << project_name\r\n            else\r\n              dep_license_map[dep_mgr_name][dep_name] ||= {}\r\n              dep_license_map[dep_mgr_name][dep_name][dep_version] = {\r\n                \"license\" => dependency[\"license\"],\r\n                \"license_files\" => dependency[\"license_files\"],\r\n                \"dependency_of\" => [ project_name ],\r\n              }\r\n            end\r\n          end\r\n        end\r\n      end\r\n      FileUtils.rm_rf(cache_dir)\r\n    end","code-length":467,"reference":"0.","result":"Process transitive dependency licensing info.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef collect_licenses_for(software)\r\n      return nil if software.license == :project_license\r\n      software_name = software.name\r\n      license_data = license_map[software_name]\r\n      license_files = license_data[:license_files]\r\n      license_files.each do |license_file|\r\n        if license_file\r\n          output_file = license_package_location(software_name, license_file)\r\n          if local?(license_file)\r\n            input_file = File.expand_path(license_file, license_data[:project_dir])\r\n            if File.exist?(input_file)\r\n              FileUtils.cp(input_file, output_file)\r\n              File.chmod 0644, output_file unless windows?\r\n            else\r\n              licensing_warning(\"License file '#{input_file}' does not exist for software '#{software_name}'.\")\r\n              raise_if_warnings_fatal!\r\n            end\r\n          else\r\n            begin\r\n              download_file!(license_file, output_file, enable_progress_bar: false)\r\n              File.chmod 0644, output_file unless windows?\r\n            rescue SocketError,\r\n                   Errno::ECONNREFUSED,\r\n                   Errno::ECONNRESET,\r\n                   Errno::ENETUNREACH,\r\n                   Timeout::Error,\r\n                   OpenURI::HTTPError,\r\n                   OpenSSL::SSL::SSLError\r\n              licensing_warning(\"Can not download license file '#{license_file}' for software '#{software_name}'.\")\r\n              raise_if_warnings_fatal!\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end","code-length":414,"reference":"Collect the license files for the software.","result":"Collect the licenses for a software.","score":[0.2748,0.3623]}
{"code":"# is used to<extra_id_0>\r\ndef write_prototype_file\r\n      shellout! \"cd #{install_dirname} && find #{install_basename} -print > #{staging_dir_path('files')}\"\r\n      File.open staging_dir_path(\"files.clean\"), \"w+\" do |fout|\r\n        File.open staging_dir_path(\"files\") do |fin|\r\n          fin.each_line do |line|\r\n            if line.chomp =~ \/\\s\/\r\n              log.warn(log_key) { \"Skipping packaging '#{line}' file due to whitespace in filename\" }\r\n            else\r\n              fout.write(line)\r\n            end\r\n          end\r\n        end\r\n      end\r\n      File.open staging_dir_path(\"Prototype\"), \"w+\" do |f|\r\n        f.write <<-EOF.gsub(\/^ {10}\/, \"\")\r\n          i pkginfo\r\n          i postinstall\r\n          i postremove\r\n        EOF\r\n      end\r\n      shellout! \"cd #{install_dirname} && pkgproto < #{staging_dir_path('files.clean')} > #{staging_dir_path('Prototype.files')}\"\r\n      shellout! \"awk '{ $5 = \\\"root\\\"; $6 = \\\"root\\\"; print }' < #{staging_dir_path('Prototype.files')} >> #{staging_dir_path('Prototype')}\"\r\n    end","code-length":344,"reference":"Generate a Prototype file for solaris build","result":"Write the prototype file.","score":[0,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef content\r\n      @content ||= IO.read(path)\r\n    rescue Errno::ENOENT\r\n      raise NoPackageFile.new(path)\r\n    end","code-length":48,"reference":"The actual contents of the package.","result":"Escape the string.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef validate!\r\n      unless File.exist?(path)\r\n        raise NoPackageFile.new(path)\r\n      end\r\n      unless File.exist?(metadata.path)\r\n        raise NoPackageMetadataFile.new(metadata.path)\r\n      end\r\n      true\r\n    end","code-length":79,"reference":"Validate the presence of the required components for the package.","result":"Validate the package.","score":[0.0686,0.2748]}
{"code":"# is used to<extra_id_0>\r\ndef key_for(package, *stuff)\r\n      File.join(\r\n        Config.s3_publish_pattern % package.metadata,\r\n        *stuff\r\n      )\r\n    end","code-length":57,"reference":"The unique upload key for this package.","result":"Generate the key.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef semver\r\n      build_tag = version_tag\r\n      if prerelease_version?\r\nelease = prerelease_tag.tr(\"-\", \".\")\r\n        build_tag << \"-\" << prerelease\r\n      end\r\n      build_version_items = []\r\n      if Config.append_timestamp\r\n        build_version_items << build_start_time\r\n      end\r\n      unless commits_since_tag == 0\r\n        build_version_items << [\"git\", commits_since_tag, git_sha_tag].join(\".\")\r\n      end\r\n      unless build_version_items.empty?\r\n        build_tag << \"+\" << build_version_items.join(\".\")\r\n      end\r\n      build_tag\r\n    end","code-length":186,"reference":"Create a new BuildVersion ","result":"Build a semver tag.","score":[0.3195,0.125]}
{"code":"# is used to<extra_id_0>\r\ndef build_start_time\r\n      @build_start_time ||= begin\r\n                              if ENV[\"BUILD_TIMESTAMP\"]\r\n                                begin\r\n                                  Time.strptime(ENV[\"BUILD_TIMESTAMP\"], \"%Y-%m-%d_%H-%M-%S\")\r\n                                rescue ArgumentError\r\n                                  error_message =  \"BUILD_TIMESTAMP environment variable \"\r\n                                  error_message << \"should be in YYYY-MM-DD_hh-mm-ss \"\r\n                                  error_message << \"format.\"\r\n                                  raise ArgumentError, error_message\r\n                                end\r\n                              elsif ENV[\"BUILD_ID\"]\r\n                                begin\r\n                                  Time.strptime(ENV[\"BUILD_ID\"], \"%Y-%m-%d_%H-%M-%S\")\r\n                                rescue ArgumentError\r\n                                  error_message =  \"BUILD_ID environment variable \"\r\n                                  error_message << \"should be in YYYY-MM-DD_hh-mm-ss \"\r\n                                  error_message << \"format.\"\r\n                                  raise ArgumentError, error_message\r\n                                end\r\n                              else\r\n                                Time.now.utc\r\n                              end\r\n                            end.strftime(TIMESTAMP_FORMAT)\r\n    end","code-length":274,"reference":"We'll attempt to retrieve the timestamp from the Jenkin's set BUILD_TIMESTAMP or fall back to BUILD_ID environment variable.","result":"Determine build start time.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef save\r\n      File.open(path, \"w+\") do |f|\r\n        f.write(FFI_Yajl::Encoder.encode(to_hash, pretty: true))\r\n      end\r\n      true\r\n    end","code-length":66,"reference":"Save the file to disk.","result":"Save the object.","score":[0.2964,0.3906]}
{"code":"# is used to<extra_id_0>\r\ndef vendor(val = NULL)\r\n      if null?(val)\r\n        @vendor || \"Omnibus <omnibus@getchef.com>\"\r\n      else\r\n        unless val.is_a?(String)\r\n          raise InvalidValue.new(:vendor, \"be a String\")\r\n        end\r\n        @vendor = val\r\n      end\r\n    end","code-length":100,"reference":"Set or return the vendor who made this package.","result":"Define the method.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef license(val = NULL)\r\n      if null?(val)\r\n        @license || project.license\r\n      else\r\n        unless val.is_a?(String)\r\n          raise InvalidValue.new(:license, \"be a String\")\r\n        end\r\n        @license = val\r\n      end\r\n    end","code-length":86,"reference":"Set or return the license for this package.","result":"Define the project.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef build_filepath(path)\r\n      filepath = rpm_safe(\"\/\" + path.gsub(\"#{build_dir}\/\", \"\"))\r\n      return if config_files.include?(filepath)\r\n      full_path = build_dir + filepath.gsub(\"[%]\", \"%\")\r\n      full_path.delete!('\"')\r\n      return mark_filesystem_directories(filepath) if !File.symlink?(full_path) && File.directory?(full_path)\r\n      filepath\r\n    end","code-length":128,"reference":"Convert the path of a file in the staging directory to an entry for use in the spec file.","result":"Build the build filepath.","score":[0.0075,0.0286]}
{"code":"# is used to<extra_id_0>\r\ndef with_rpm_signing(&block)\r\n      directory   = Dir.mktmpdir\r\n      destination = \"#{directory}\/sign-rpm\"\r\n      render_template(resource_path(\"signing.erb\"),\r\n        destination: destination,\r\n        mode: 0700,\r\n        variables: {\r\n          passphrase: signing_passphrase,\r\n        }\r\n      )\r\n      yield(destination)\r\n    ensure\r\n      remove_file(destination)\r\n      remove_directory(directory)\r\n    end","code-length":133,"reference":"Render the rpm signing script with secure permissions, call the given block with the path to the script, and ensure deletion of the script from disk since it contains sensitive information.","result":"Sign RPM files.","score":[0,0.0355]}
{"code":"# is used to<extra_id_0>\r\ndef publish(klass, pattern, options)\r\n      if options[:platform_mappings]\r\n        options[:platform_mappings] = FFI_Yajl::Parser.parse(File.read(File.expand_path(options[:platform_mappings])))\r\n      end\r\n      klass.publish(pattern, options) do |package|\r\n        say(\"Published '#{package.name}' for #{package.metadata[:platform]}-#{package.metadata[:platform_version]}\", :green)\r\n      end\r\n    end","code-length":126,"reference":"Shortcut method for executing a publisher.","result":"Publish packages.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef build_version(val = NULL, &block)\r\n      if block && !null?(val)\r\n        raise Error, \"You cannot specify additional parameters to \" \\\r\n          \"\r\n      end\r\n      if block\r\n        @build_version_dsl = BuildVersionDSL.new(&block)\r\n      else\r\n        if null?(val)\r\n          @build_version_dsl.build_version\r\n        else\r\n          @build_version_dsl = BuildVersionDSL.new(val)\r\n        end\r\n      end\r\n    end","code-length":140,"reference":"Set or retrieve the version of the project.","result":"Build the version.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef package(id, &block)\r\n      unless block\r\n        raise InvalidValue.new(:package, \"have a block\")\r\n      end\r\n      packagers[id] << block\r\n    end","code-length":57,"reference":"Add or override a customization for the packager with the given +id+.","result":"Define the package.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef compress(id, &block)\r\n      if block\r\n        compressors[id] << block\r\n      else\r\n        compressors[id] << Proc.new {}\r\n      end\r\n    end","code-length":57,"reference":"Add or override a customization for the compressor with the given +id+.","result":"Compress the code.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef override(name, val = NULL)\r\n      if null?(val)\r\n        overrides[name.to_sym]\r\n      else\r\n        overrides[name.to_sym] = val\r\n      end\r\n    end","code-length":63,"reference":"Set or retrieve the overrides hash for one piece of software being overridden.","result":"Override the value of a variable.","score":[0.0715,0.122]}
{"code":"# is used to<extra_id_0>\r\ndef license_file_path(path = NULL)\r\n      if null?(path)\r\n        @license_file_path || File.join(install_dir, \"LICENSE\")\r\n      else\r\n        @license_file_path = File.join(install_dir, path)\r\n      end\r\n    end","code-length":83,"reference":"Location of license file that omnibus will create and that will contain the information about the license of the project plus the details about the licenses of the software components included in the project.","result":"Store the path to the license file.","score":[0.0053,0.0479]}
{"code":"# is used to<extra_id_0>\r\ndef dependency?(software)\r\n      name = software.is_a?(Software) ? software.name : software\r\n      dependencies.include?(name)\r\n    end","code-length":50,"reference":"Indicates whether the given  +software+ is defined as a software component of this project.","result":"Define the method.","score":[0.0104,0.0775]}
{"code":"# is used to<extra_id_0>\r\ndef built_manifest\r\n      log.info(log_key) { \"Building version manifest\" }\r\n      m = Omnibus::Manifest.new(build_version, build_git_revision, license)\r\n      softwares.each do |software|\r\n        m.add(software.name, software.manifest_entry)\r\n      end\r\n      m\r\n    end","code-length":99,"reference":"Generate a version manifest of the loaded software sources.","result":"Build the manifest.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef write_text_manifest\r\n      File.open(text_manifest_path, \"w\") do |f|\r\n        f.puts \"#{name} #{build_version}\"\r\n        f.puts \"\"\r\n        f.puts Omnibus::Reports.pretty_version_map(self)\r\n      end\r\n    end","code-length":85,"reference":"Writes a text manifest to the text_manifest_path.","result":"Generate the text manifest.","score":[0.1795,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef write_conffiles_file\r\n      return if project.config_files.empty?\r\n      render_template(resource_path(\"conffiles.erb\"),\r\n        destination: File.join(debian_dir, \"conffiles\"),\r\n        variables: {\r\n          config_files: project.config_files,\r\n        }\r\n      )\r\n    end","code-length":100,"reference":"Render the list of config files into the conffile.","result":"Write the conffiles file.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef package_size\r\n      @package_size ||= begin\r\n        path  = \"#{project.install_dir}\/**\/*\"\r\n        total = FileSyncer.glob(path).inject(0) do |size, path|\r\n          unless File.directory?(path) || File.symlink?(path)\r\n            size += File.size(path)\r\n          end\r\n          size\r\n        end\r\n        total \/ 1024\r\n      end\r\n    end","code-length":117,"reference":"The size of this Debian package.","result":"Calculate the package size.","score":[0,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef dir_empty?(dir)\r\n      Dir.entries(dir).reject { |d| [\".\", \"..\"].include?(d) }.empty?\r\n    end","code-length":49,"reference":"Determine if a directory is empty ","result":"Detect empty directories.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef force_recreate_project_dir!\r\n      log.warn(log_key) { \"Removing existing directory #{project_dir} before cloning\" }\r\n      FileUtils.rm_rf(project_dir)\r\n      Dir.mkdir(project_dir)\r\n    end","code-length":73,"reference":"Forcibly remove and recreate the project directory","result":"Create a new project directory.","score":[0.1611,0.0735]}
{"code":"# is used to<extra_id_0>\r\ndef current_revision\r\n      cmd = git(\"rev-parse HEAD\")\r\n      cmd.stdout.strip\r\n    rescue CommandFailed\r\n      log.debug(log_key) { \"unable to determine current revision\" }\r\n      nil\r\n    end","code-length":67,"reference":"The current revision for the cloned checkout.","result":"Determine the current revision.","score":[0.1795,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef contains_revision?(rev)\r\n      cmd = git(\"cat-file -t #{rev}\")\r\n      cmd.stdout.strip == \"commit\"\r\n    rescue CommandFailed\r\n      log.debug(log_key) { \"unable to determine presence of commit #{rev}\" }\r\n      false\r\n    end","code-length":82,"reference":"Check if the current clone has the requested commit id.","result":"Detect if a revision is contained in a commit.","score":[0.109,0.101]}
{"code":"# is used to<extra_id_0>\r\ndef to_ssh\r\n      if zero?\r\n        return [0].pack(\"N\")\r\n      else\r\n        buf = to_s(2)\r\n        if buf.getbyte(0)[7] == 1\r\n          return [buf.length + 1, 0, buf].pack(\"NCA*\")\r\n        else\r\n          return [buf.length, buf].pack(\"NA*\")\r\n        end\r\n      end\r\n    end","code-length":113,"reference":"Converts a BN object to a string.","result":"Convert to SSH.","score":[0.1076,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef compute_need_bits\r\n      need_bits = data[:need_bytes] * 8 * 2 + 1\r\n      data[:minimum_dh_bits] ||= MINIMUM_BITS\r\n      if need_bits < data[:minimum_dh_bits]\r\n        need_bits = data[:minimum_dh_bits]\r\n      elsif need_bits > MAXIMUM_BITS\r\n        need_bits = MAXIMUM_BITS\r\n      end\r\n      data[:need_bits] = need_bits\r\n      data[:need_bytes] = need_bits \/ 8\r\n    end","code-length":140,"reference":"Compute the number of bits needed for the given number of bytes.","result":"Compute the need bits.","score":[0.0611,0.1339]}
{"code":"# is used to<extra_id_0>\r\ndef get_parameters\r\n      compute_need_bits\r\n      buffer = Net::SSH::Buffer.from(:byte, KEXDH_GEX_REQUEST, :long, data[:minimum_dh_bits],\r\n        :long, data[:need_bits], :long, MAXIMUM_BITS)\r\n      connection.send_message(buffer)\r\n      buffer = connection.next_message\r\n      raise Net::SSH::Exception, \"expected KEXDH_GEX_GROUP, got #{buffer.type}\" unless buffer.type == KEXDH_GEX_GROUP\r\n      p = buffer.read_bignum\r\n      g = buffer.read_bignum\r\n      [p, g]\r\n    end","code-length":173,"reference":"Returns the DH key parameters for the given session.","result":"Compute the parameters.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef build_signature_buffer(result)\r\n      response = Net::SSH::Buffer.new\r\n      response.write_string data[:client_version_string],\r\n                            data[:server_version_string],\r\n                            data[:client_algorithm_packet],\r\n                            data[:server_algorithm_packet],\r\n                            result[:key_blob]\r\n      response.write_long MINIMUM_BITS,\r\n                          data[:need_bits],\r\n                          MAXIMUM_BITS\r\n      response.write_bignum dh.p, dh.g, dh.pub_key,\r\n                            result[:server_dh_pubkey],\r\n                            result[:shared_secret]\r\n      response\r\n    end","code-length":169,"reference":"Build the signature buffer to use when verifying a signature from the server.","result":"Build the signature buffer.","score":[0.0694,0.124]}
{"code":"# is used to<extra_id_0>\r\ndef when_loaded\r\n      previously_loaded = loaded\r\n      self.loaded = loaded?\r\n      raise SitePrism::FailedLoadValidationError, load_error unless loaded\r\n      yield self if block_given?\r\n    ensure\r\n      self.loaded = previously_loaded\r\n    end","code-length":75,"reference":"Executes the given block after the page is loaded.","result":"Define the block to be called when the page is loaded.","score":[0.3391,0.6114]}
{"code":"# is used to<extra_id_0>\r\ndef load_validations_pass?\r\n      self.class.load_validations.all? do |validation|\r\n        passed, message = instance_eval(&validation)\r\n        self.load_error = message if message && !passed\r\n        passed\r\n      end\r\n    end","code-length":76,"reference":"If any load validations from page subclasses returns false, immediately return false.","result":"Check if load_validations pass?.","score":[0,0.0446]}
{"code":"# is used to<extra_id_0>\r\ndef raise_if_block(obj, name, has_block, type)\r\n      return unless has_block\r\n      SitePrism.logger.debug(\"Type passed in: #{type}\")\r\n      SitePrism.logger.warn('section \/ iFrame can only accept blocks.')\r\n      SitePrism.logger.error(\"#{obj.class}\r\n      raise SitePrism::UnsupportedBlockError\r\n    end","code-length":105,"reference":"Prevent users from calling methods with blocks when they shouldn't be.","result":"Raise if block is not found.","score":[0,0.0476]}
{"code":"# is used to<extra_id_0>\r\ndef merge_args(find_args, runtime_args, visibility_args = {})\r\n      find_args = find_args.dup\r\n      runtime_args = runtime_args.dup\r\n      options = visibility_args.dup\r\n      SitePrism.logger.debug(\"Initial args: #{find_args}, #{runtime_args}.\")\r\n      recombine_args(find_args, runtime_args, options)\r\n      return [*find_args, *runtime_args] if options.empty?\r\n      [*find_args, *runtime_args, options]\r\n    end","code-length":145,"reference":"Sanitize method called before calling any SitePrism DSL method or meta-programmed method.","result":"Merge arguments.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef recombine_args(find_args, runtime_args, options)\r\n      options.merge!(find_args.pop) if find_args.last.is_a? Hash\r\n      options.merge!(runtime_args.pop) if runtime_args.last.is_a? Hash\r\n      options[:wait] = wait_time unless wait_key_present?(options)\r\n    end","code-length":102,"reference":"Options re-combiner.","result":"Recombine arguments.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef elements_to_check\r\n      if _expected_items\r\n        SitePrism.logger.debug('Expected Items has been set.')\r\n        _mapped_items.select { |item_name| _expected_items.include?(item_name) }\r\n      else\r\n        _mapped_items\r\n      end\r\n    end","code-length":88,"reference":"If the page or section has expected_items set, return expected_items","result":"Check if the element has been found.","score":[0.1251,0.2635]}
{"code":"# is used to<extra_id_0>\r\ndef matches?(url, expected_mappings = {})\r\n      actual_mappings = mappings(url)\r\n      return false unless actual_mappings\r\n      expected_mappings.empty? ||\r\n        all_expected_mappings_match?(expected_mappings, actual_mappings)\r\n    end","code-length":75,"reference":"Determine whether URL matches our pattern, and optionally whether the extracted mappings match a hash of expected values.","result":"Match URLs.","score":[0,0.0305]}
{"code":"# is used to<extra_id_0>\r\ndef component_matches(component, uri)\r\n      component_template = component_templates[component]\r\n      return {} unless component_template\r\n      component_url = uri.public_send(component).to_s\r\n      mappings = component_template.extract(component_url)\r\n      return mappings if mappings\r\n      prefix = component_prefixes[component]\r\n      return nil unless prefix\r\n      component_template.extract(prefix + component_url)\r\n    end","code-length":117,"reference":"Returns empty hash if the template omits the component or a set of substitutions if the provided URI component matches the template component or nil if the match fails.","result":"Match component URIs.","score":[0.0001,0.0379]}
{"code":"# is used to<extra_id_0>\r\ndef to_substituted_uri\r\n      url = pattern\r\n      substitutions.each_pair { |slug, value| url = url.sub(slug, value) }\r\n      begin\r\n        Addressable::URI.parse(url)\r\n      rescue Addressable::URI::InvalidURIError\r\n        SitePrism.logger.warn(\"Ensure you don't use templated port numbers.\")\r\n        raise SitePrism::InvalidUrlMatcherError\r\n      end\r\n    end","code-length":118,"reference":"Convert the pattern into an Addressable URI by substituting the template slugs with nonsense strings.","result":"Create a URI object.","score":[0.0204,0.036]}
{"code":"# is used to<extra_id_0>\r\ndef substitution_value(index)\r\n      sha = Digest::SHA1.digest(index.to_s)\r\n      Base64.urlsafe_encode64(sha).gsub(\/[^A-Za-z]\/, '')[0..5]\r\n    end","code-length":69,"reference":"Generate a repeatable 5 character uniform alphabetical nonsense string to allow parsing as a URI","result":"Substitute values.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef build_times_enumerator(number, cursor:)\r\n      raise ArgumentError, \"First argument must be an Integer\" unless number.is_a?(Integer)\r\n      wrap(self, build_array_enumerator(number.times.to_a, cursor: cursor))\r\n    end","code-length":76,"reference":"Builds Enumerator objects that iterates N times and yields number starting from zero.","result":"Build the times enumerator.","score":[0.0337,0.0826]}
{"code":"# is used to<extra_id_0>\r\ndef build_array_enumerator(enumerable, cursor:)\r\n      unless enumerable.is_a?(Array)\r\n        raise ArgumentError, \"enumerable must be an Array\"\r\n      end\r\n      if enumerable.any? { |i| defined?(ActiveRecord) && i.is_a?(ActiveRecord::Base) }\r\n        raise ArgumentError, \"array cannot contain ActiveRecord objects\"\r\n      end\r\n      drop =\r\n        if cursor.nil?\r\n          0\r\n        else\r\n          cursor + 1\r\n        end\r\n      wrap(self, enumerable.each_with_index.drop(drop).to_enum { enumerable.size })\r\n    end","code-length":166,"reference":"Builds Enumerator object from a given array, using +cursor+ as an offset.","result":"Build an array enumerator.","score":[0.0432,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef build_lock_queue_enumerator(lock_queue, at_most_once:)\r\n      unless lock_queue.is_a?(BackgroundQueue::LockQueue::RedisQueue) ||\r\n          lock_queue.is_a?(BackgroundQueue::LockQueue::RolloutRedisQueue)\r\n        raise ArgumentError, \"an argument to\r\n      end\r\n      wrap(self, BackgroundQueue::LockQueueEnumerator.new(lock_queue, at_most_once: at_most_once).to_enum)\r\n    end","code-length":131,"reference":"Builds Enumerator from a lock queue instance that belongs to a job.","result":"Build the lock queue enumerator.","score":[0.0838,0.2262]}
{"code":"# is used to<extra_id_0>\r\ndef build_active_record_enumerator_on_records(scope, cursor:, **args)\r\n      enum = build_active_record_enumerator(\r\n        scope,\r\n        cursor: cursor,\r\n        **args\r\n      ).records\r\n      wrap(self, enum)\r\n    end","code-length":81,"reference":"Builds Enumerator from Active Record Relation.","result":"Build the active record enumerator.","score":[0,0.4331]}
{"code":"# is used to<extra_id_0>\r\ndef build_active_record_enumerator_on_batches(scope, cursor:, **args)\r\n      enum = build_active_record_enumerator(\r\n        scope,\r\n        cursor: cursor,\r\n        **args\r\n      ).batches\r\n      wrap(self, enum)\r\n    end","code-length":81,"reference":"Builds Enumerator from Active Record Relation and enumerates on batches.","result":"Build the active record enumerator.","score":[0,0.269]}
{"code":"# is used to<extra_id_0>\r\ndef batches(batch_size:, cursor:)\r\n      @csv.lazy\r\n        .each_slice(batch_size)\r\n        .each_with_index\r\n        .drop(cursor.to_i)\r\n        .to_enum { (count_rows_in_file.to_f \/ batch_size).ceil }\r\n    end","code-length":92,"reference":"Constructs a enumerator on batches of CSV rows ","result":"Create batches.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef reify(options = {})\r\n      unless self.class.column_names.include? \"object\"\r\n        raise \"reify can't be called without an object column\"\r\n      end\r\n      return nil if object.nil?\r\n      ::PaperTrail::Reifier.reify(self, options)\r\n    end","code-length":85,"reference":"Restore the item from this version.","result":"Create a new object.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef version_limit\r\n      if self.class.item_subtype_column_present?\r\n        klass = (item_subtype || item_type).constantize\r\n        if klass&.paper_trail_options&.key?(:limit)\r\n          return klass.paper_trail_options[:limit]\r\n        end\r\n      end\r\n      PaperTrail.config.version_limit\r\n    end","code-length":101,"reference":"The version limit can be global or per-model.","result":"Set the version limit.","score":[0.1175,0.3363]}
{"code":"# is used to<extra_id_0>\r\ndef on_create\r\n      @model_class.after_create { |r|\r\n        r.paper_trail.record_create if r.paper_trail.save_version?\r\n      }\r\n      return if @model_class.paper_trail_options[:on].include?(:create)\r\n      @model_class.paper_trail_options[:on] << :create\r\n    end","code-length":101,"reference":"Adds a callback that records a version after a \"create\" event.","result":"Create a new paper_trail.","score":[0.0555,0.0485]}
{"code":"# is used to<extra_id_0>\r\ndef on_destroy(recording_order = \"before\")\r\n      unless %w[after before].include?(recording_order.to_s)\r\n        raise ArgumentError, 'recording order can only be \"after\" or \"before\"'\r\n      end\r\n      if recording_order.to_s == \"after\" && cannot_record_after_destroy?\r\n        raise E_CANNOT_RECORD_AFTER_DESTROY\r\n      end\r\n      @model_class.send(\r\n        \"#{recording_order}_destroy\",\r\n        lambda do |r|\r\n          return unless r.paper_trail.save_version?\r\n          r.paper_trail.record_destroy(recording_order)\r\n        end\r\n      )\r\n      return if @model_class.paper_trail_options[:on].include?(:destroy)\r\n      @model_class.paper_trail_options[:on] << :destroy\r\n    end","code-length":228,"reference":"Adds a callback that records a version before or after a \"destroy\" event.","result":"Set the on_destroy method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef on_update\r\n      @model_class.before_save { |r|\r\n        r.paper_trail.reset_timestamp_attrs_for_update_if_needed\r\n      }\r\n      @model_class.after_update { |r|\r\n        if r.paper_trail.save_version?\r\n          r.paper_trail.record_update(\r\n            force: false,\r\n            in_after_callback: true,\r\n            is_touch: false\r\n          )\r\n        end\r\n      }\r\n      @model_class.after_update { |r|\r\n        r.paper_trail.clear_version_instance\r\n      }\r\n      return if @model_class.paper_trail_options[:on].include?(:update)\r\n      @model_class.paper_trail_options[:on] << :update\r\n    end","code-length":213,"reference":"Adds a callback that records a version after an \"update\" event.","result":"Trigger the update of the paper_trail.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef on_touch\r\n      @model_class.after_touch { |r|\r\n        r.paper_trail.record_update(\r\n          force: true,\r\n          in_after_callback: true,\r\n          is_touch: true\r\n        )\r\n      }\r\n    end","code-length":79,"reference":"Adds a callback that records a version after a \"touch\" event.","result":"Trigger the on_touch callback.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef check_presence_of_item_subtype_column(options)\r\n      return unless options.key?(:limit)\r\n      return if version_class.item_subtype_column_present?\r\n      raise format(E_MODEL_LIMIT_REQUIRES_ITEM_SUBTYPE, @model_class.name)\r\n    end","code-length":85,"reference":"Some options require the presence of the `item_subtype` column.","result":"Check the presence of item_subtype_column.","score":[0.2224,0.2972]}
{"code":"# is used to<extra_id_0>\r\ndef save_version?\r\n      if_condition = @record.paper_trail_options[:if]\r\n      unless_condition = @record.paper_trail_options[:unless]\r\n      (if_condition.blank? || if_condition.call(@record)) && !unless_condition.try(:call, @record)\r\n    end","code-length":86,"reference":"AR callback.","result":"Save the version.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef _squash_changes(changes)\r\n      changes = changes.map { |change, dir, path| [change, dir + path] }\r\n      actions = changes.group_by(&:last).map do |path, action_list|\r\n        [_logical_action_for(path, action_list.map(&:first)), path.to_s]\r\n      end\r\n      config.debug(\"listen: raw changes: #{actions.inspect}\")\r\n      { modified: [], added: [], removed: [] }.tap do |squashed|\r\n        actions.each do |type, path|\r\n          squashed[type] << path unless type.nil?\r\n        end\r\n        config.debug(\"listen: final changes: #{squashed.inspect}\")\r\n      end\r\n    end","code-length":202,"reference":"groups changes into the expected structure expected by clients","result":"Squash the changes.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef to_node object\r\n      if object.is_a?(self.ancestry_base_class) then object else unscoped_where{|scope| scope.find object} end\r\n    end","code-length":55,"reference":"Fetch tree node if necessary","result":"Create a node.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef scope_depth depth_options, depth\r\n      depth_options.inject(self.ancestry_base_class) do |scope, option|\r\n        scope_name, relative_depth = option\r\n        if [:before_depth, :to_depth, :at_depth, :from_depth, :after_depth].include? scope_name\r\n          scope.send scope_name, depth + relative_depth\r\n        else\r\n          raise Ancestry::AncestryException.new(\"Unknown depth option: #{scope_name}.\")\r\n        end\r\n      end\r\n    end","code-length":143,"reference":"Scope on relative depth options","result":"Define the scope_depth method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef orphan_strategy= orphan_strategy\r\n      if [:rootify, :adopt, :restrict, :destroy].include? orphan_strategy\r\n        class_variable_set :@@orphan_strategy, orphan_strategy\r\n      else\r\n        raise Ancestry::AncestryException.new(\"Invalid orphan strategy, valid ones are :rootify,:adopt, :restrict and :destroy.\")\r\n      end\r\n    end","code-length":106,"reference":"Orphan strategy writer","result":"Set the orphan_strategy.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef arrange options = {}\r\n      if (order = options.delete(:order))\r\n        arrange_nodes self.ancestry_base_class.order(order).where(options)\r\n      else\r\n        arrange_nodes self.ancestry_base_class.where(options)\r\n      end\r\n    end","code-length":84,"reference":"Get all nodes and sorting them into an empty hash","result":"Generate the code.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef arrange_serializable options={}, nodes=nil, &block\r\n      nodes = arrange(options) if nodes.nil?\r\n      nodes.map do |parent, children|\r\n        if block_given?\r\n          yield parent, arrange_serializable(options, children, &block)\r\n        else\r\n          parent.serializable_hash.merge 'children' => arrange_serializable(options, children)\r\n        end\r\n      end\r\n    end","code-length":118,"reference":"Arrangement to nested array","result":"Serialize the array.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef build_ancestry_from_parent_ids! parent_id = nil, ancestry = nil\r\n      unscoped_where do |scope|\r\n        scope.where(:parent_id => parent_id).find_each do |node|\r\n          node.without_ancestry_callbacks do\r\n            node.update_attribute ancestry_column, ancestry\r\n          end\r\n          build_ancestry_from_parent_ids! node.id, if ancestry.nil? then \"#{node.id}\" else \"#{ancestry}\/#{node.id}\" end\r\n        end\r\n      end\r\n    end","code-length":147,"reference":"Build ancestry from parent id's for migration purposes","result":"Build an ancestry.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef rebuild_depth_cache!\r\n      raise Ancestry::AncestryException.new(\"Cannot rebuild depth cache for model without depth caching.\") unless respond_to? :depth_cache_column\r\n      self.ancestry_base_class.transaction do\r\n        unscoped_where do |scope|\r\n          scope.find_each do |node|\r\n            node.update_attribute depth_cache_column, node.depth\r\n          end\r\n        end\r\n      end\r\n    end","code-length":121,"reference":"Rebuild depth cache if it got corrupted or if depth caching was just turned on","result":"Rebuild the depth cache.","score":[0.0243,0.0719]}
{"code":"# is used to<extra_id_0>\r\ndef indirect_conditions(object)\r\n      t = arel_table\r\n      node = to_node(object)\r\n      if ActiveRecord::VERSION::MAJOR >= 5\r\n        t[ancestry_column].matches(\"#{node.child_ancestry}\/%\", nil, true)\r\n      else\r\n        t[ancestry_column].matches(\"#{node.child_ancestry}\/%\")\r\n      end\r\n    end","code-length":108,"reference":"indirect = anyone who is a descendant, but not a child","result":"Generate the conditions.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef request_defaults(sudo = nil)\r\n      self.class.default_params sudo: sudo\r\n      raise Error::MissingCredentials, 'Please set an endpoint to API' unless @endpoint\r\n      self.class.default_params.delete(:sudo) if sudo.nil?\r\n    end","code-length":75,"reference":"Sets a base_uri and default_params for requests.","result":"Set the default params.","score":[0,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef options\r\n      VALID_OPTIONS_KEYS.inject({}) do |option, key|\r\n        option.merge!(key => send(key))\r\n      end\r\n    end","code-length":51,"reference":"Creates a hash of options and their values.","result":"Generate the options.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef reset\r\n      self.endpoint       = ENV['GITLAB_API_ENDPOINT']\r\n      self.private_token  = ENV['GITLAB_API_PRIVATE_TOKEN'] || ENV['GITLAB_API_AUTH_TOKEN']\r\n      self.httparty       = get_httparty_config(ENV['GITLAB_API_HTTPARTY_OPTIONS'])\r\n      self.sudo           = nil\r\n      self.user_agent     = DEFAULT_USER_AGENT\r\n    end","code-length":126,"reference":"Resets all configuration options to the defaults.","result":"Reset the instance variables.","score":[0.1509,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef get_httparty_config(options)\r\n      return if options.nil?\r\n      httparty = Gitlab::CLI::Helpers.yaml_load(options)\r\n      raise ArgumentError, 'HTTParty config should be a Hash.' unless httparty.is_a? Hash\r\n      Gitlab::CLI::Helpers.symbolize_keys httparty\r\n    end","code-length":89,"reference":"Allows HTTParty config to be specified in ENV using YAML hash.","result":"Get the HTTParty config.","score":[0.0555,0.0485]}
{"code":"# is used to<extra_id_0>\r\ndef start_timer(timer = DEFAULT_TIMER.new)\r\n      raise Socketry::InternalError, \"timer already started\" if defined?(@timer)\r\n      raise Socketry::InternalError, \"deadline already set\"  if defined?(@deadline)\r\n      @deadline = nil\r\n      @timer = timer\r\n      @timer.start\r\n      true\r\n    end","code-length":96,"reference":"Start a timer in the included object ","result":"Set the deadline.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef set_timeout(timeout)\r\n      raise Socketry::InternalError, \"deadline already set\" if @deadline\r\n      return unless timeout\r\n      raise Socketry::TimeoutError, \"time expired\" if timeout < 0\r\n      @deadline = lifetime + timeout\r\n    end","code-length":73,"reference":"Set a timeout.","result":"Set the deadline.","score":[0.4082,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef time_remaining(timeout)\r\n      return unless timeout\r\n      raise Socketry::InternalError, \"no deadline set\" unless @deadline\r\n      remaining = @deadline - lifetime\r\n      raise Socketry::TimeoutError, \"time expired\" if remaining <= 0\r\n      remaining\r\n    end","code-length":76,"reference":"Calculate number of seconds remaining until we hit the timeout ","result":"Set the deadline.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef build_schemas(parent_schema)\r\n      schema = parent_schema.schema\r\n      if schema[\"$ref\"]\r\n        load_ref_schema(parent_schema, schema[\"$ref\"])\r\n      end\r\n      case schema[\"extends\"]\r\n      when String\r\n        load_ref_schema(parent_schema, schema[\"extends\"])\r\n      when Array\r\n        schema['extends'].each do |type|\r\n          handle_schema(parent_schema, type)\r\n        end\r\n      end\r\n      [\"type\", \"disallow\"].each do |key|\r\n        if schema[key].is_a?(Array)\r\n          schema[key].each do |type|\r\n            if type.is_a?(Hash)\r\n              handle_schema(parent_schema, type)\r\n            end\r\n          end\r\n        end\r\n      end\r\n      %w[definitions properties patternProperties].each do |key|\r\n        next unless value = schema[key]\r\n        value.each do |k, inner_schema|\r\n          handle_schema(parent_schema, inner_schema)\r\n        end\r\n      end\r\n      %w[additionalProperties additionalItems dependencies extends].each do |key|\r\n        next unless schema[key].is_a?(Hash)\r\n        handle_schema(parent_schema, schema[key])\r\n      end\r\n      %w[allOf anyOf oneOf not].each do |key|\r\n        next unless value = schema[key]\r\n        Array(value).each do |inner_schema|\r\n          handle_schema(parent_schema, inner_schema)\r\n        end\r\n      end\r\n      if schema[\"items\"]\r\n        items = schema[\"items\"].clone\r\n        items = [items] unless items.is_a?(Array)\r\n        items.each do |item|\r\n          handle_schema(parent_schema, item)\r\n        end\r\n      end\r\n      if schema[\"enum\"].is_a?(Array)\r\n        schema[\"enum\"] = ArraySet.new(schema[\"enum\"])\r\n      end\r\n    end","code-length":508,"reference":"Build all schemas with IDs, mapping out the namespace","result":"Build the schemas for the given parent schema.","score":[0.1613,0.1685]}
{"code":"# is used to<extra_id_0>\r\ndef handle_schema(parent_schema, obj)\r\n      if obj.is_a?(Hash)\r\n        schema_uri = parent_schema.uri.dup\r\n        schema = JSON::Schema.new(obj, schema_uri, parent_schema.validator)\r\n        if obj['id']\r\n          self.class.add_schema(schema)\r\n        end\r\n        build_schemas(schema)\r\n      end\r\n    end","code-length":112,"reference":"Either load a reference schema or create a new schema","result":"Handle the schema.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef matches_conditions?(action, subject, extra_args)\r\n      if @match_all\r\n        call_block_with_all(action, subject, extra_args)\r\n      elsif @block && !subject_class?(subject)\r\n        @block.call(subject, *extra_args)\r\n      elsif @conditions.kind_of?(Hash) && subject.class == Hash\r\n        nested_subject_matches_conditions?(subject)\r\n      elsif @conditions.kind_of?(Hash) && !subject_class?(subject)\r\n        matches_conditions_hash?(subject)\r\n      else\r\n        @conditions.empty? ? true : @base_behavior\r\n      end\r\n    end","code-length":176,"reference":"Matches the block or conditions hash","result":"Determine if the subject matches the conditions.","score":[0.1615,0.3074]}
{"code":"# is used to<extra_id_0>\r\ndef alias_action(*args)\r\n      target = args.pop[:to]\r\n      validate_target(target)\r\n      aliased_actions[target] ||= []\r\n      aliased_actions[target] += args\r\n    end","code-length":62,"reference":"Alias one or more actions into another one.","result":"Define actions.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef expand_actions(actions)\r\n      actions.map do |action|\r\n        aliased_actions[action] ? [action, *expand_actions(aliased_actions[action])] : action\r\n      end.flatten\r\n    end","code-length":64,"reference":"Accepts an array of actions and returns an array of actions which match.","result":"Expand aliased actions.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef aliases_for_action(action)\r\n      results = [action]\r\n      aliased_actions.each do |aliased_action, actions|\r\n        results += aliases_for_action(aliased_action) if actions.include? action\r\n      end\r\n      results\r\n    end","code-length":77,"reference":"Given an action, it will try to find all of the actions which are aliased to it.","result":"Generate the action alias.","score":[0.0124,0.1194]}
{"code":"# is used to<extra_id_0>\r\ndef relevant_rules(action, subject)\r\n      rules.reverse.select do |rule|\r\n        rule.expanded_actions = expand_actions(rule.actions)\r\n        rule.relevant? action, subject\r\n      end\r\n    end","code-length":65,"reference":"Returns an array of Rule instances which match the action and subject","result":"Filter relevant rules.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef create_missing_file\r\n      raise Errno::EISDIR, path.to_s if File.directory?(@path)\r\n      return if File.exist?(@path)\r\n      dirname = RealFile.dirname @path\r\n      unless dirname == '.'\r\n        dir = FileSystem.find dirname\r\n        raise Errno::ENOENT, path.to_s unless dir.is_a? FakeDir\r\n      end\r\n      @file = FileSystem.add(path, FakeFile.new)\r\n    end","code-length":126,"reference":"Create a missing file if the path is valid.","result":"Create a missing file.","score":[0.1885,0.3464]}
{"code":"# is used to<extra_id_0>\r\ndef each_filename\r\n      return to_enum(__method__) unless block_given?\r\n      _prefix, names = split_names(@path)\r\n      names.each { |filename| yield filename }\r\n      nil\r\n    end","code-length":65,"reference":"Iterates over each component of the path.","result":"Iterate over filenames.","score":[0.1076,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef descend\r\n      vs = []\r\n      ascend { |v| vs << v }\r\n      vs.reverse_each { |v| yield v }\r\n      nil\r\n    end","code-length":53,"reference":"Iterates over and yields a new Pathname object for each element in the given path in descending order.","result":"Generate the code.","score":[0.0028,0.0303]}
{"code":"# is used to<extra_id_0>\r\ndef ascend\r\n      path = @path\r\n      yield self\r\n      while (r = chop_basename(path))\r\n        path, _name = r\r\n        break if path.empty?\r\n        yield self.class.new(del_trailing_separator(path))\r\n      end\r\n    end","code-length":81,"reference":"Iterates over and yields a new Pathname object for each element in the given path in ascending order.","result":"Ascend the path.","score":[0.0028,0.0606]}
{"code":"# is used to<extra_id_0>\r\ndef c_checksum\r\n      sum = 0\r\n      checksum_values.each_with_index do |value, index|\r\n        sum += ((index % 20) + 1) * value\r\n      end\r\n      sum % 47\r\n    end","code-length":66,"reference":"Calculates the C checksum based on checksum_values","result":"Calculate the checksum.","score":[0.1076,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef k_checksum\r\n      sum = 0\r\n      checksum_values_with_c_checksum.each_with_index do |value, index|\r\n        sum += ((index % 15) + 1) * value\r\n      end\r\n      sum % 47\r\n    end","code-length":72,"reference":"Calculates the K checksum based on checksum_values_with_c_checksum","result":"Calculate the checksum.","score":[0.1076,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef annotate_pdf(pdf, options={})\r\n      with_options options do\r\n        xpos, ypos = x, y\r\n        orig_xpos = xpos\r\n        if barcode.two_dimensional?\r\n          boolean_groups.reverse_each do |groups|\r\n            groups.each do |bar,amount|\r\n              if bar\r\n                pdf.move_to(xpos, ypos).\r\n                  line_to(xpos, ypos+xdim).\r\n                  line_to(xpos+(xdim*amount), ypos+xdim).\r\n                  line_to(xpos+(xdim*amount), ypos).\r\n                  line_to(xpos, ypos).\r\n                  fill\r\n              end\r\n              xpos += (xdim*amount)\r\n            end\r\n            xpos = orig_xpos\r\n            ypos += xdim\r\n          end\r\n        else\r\n          boolean_groups.each do |bar,amount|\r\n            if bar\r\n              pdf.move_to(xpos, ypos).\r\n                line_to(xpos, ypos+height).\r\n                line_to(xpos+(xdim*amount), ypos+height).\r\n                line_to(xpos+(xdim*amount), ypos).\r\n                line_to(xpos, ypos).\r\n                fill\r\n            end\r\n            xpos += (xdim*amount)\r\n          end\r\n        end\r\n      end\r\n      pdf\r\n    end","code-length":350,"reference":"Annotate a PDFWriter document with the barcodex, y   - The point in the document to start rendering fromheight - The height of the bars in PDF unitsxdim   - The X dimension in PDF units","result":"Annotate the barcode.","score":[0.0,0.0324]}
{"code":"# is used to<extra_id_0>\r\ndef characters\r\n      chars = raw_characters\r\n      extended ? chars.map{|c| EXTENDED_ENCODINGS[c].split(\/\/) }.flatten : chars\r\n    end","code-length":52,"reference":"Returns the encodable characters.","result":"Identify the character set.","score":[0.3195,0.125]}
{"code":"# is used to<extra_id_0>\r\ndef characters\r\n      chars = data.split(\/\/n)\r\n      if type == 'C'\r\n        result = []\r\n        count = 0\r\n        while count < chars.size\r\n          if chars[count] =~ \/^\\d$\/\r\n            result << \"#{chars[count]}#{chars[count+1]}\"\r\n            count += 2\r\n          else\r\n            result << chars[count]\r\n            count += 1\r\n          end\r\n        end\r\n        result\r\n      else\r\n        chars\r\n      end\r\n    end","code-length":136,"reference":"Get an array of the individual characters for this barcode.","result":"Split data.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef checksum\r\n      pos = 0\r\n      (numbers+extra_numbers).inject(start_num) do |sum,number|\r\n        pos += 1\r\n        sum + (number * pos)\r\n      end % 103\r\n    end","code-length":66,"reference":"Calculate the checksum for the data in this barcode.","result":"Calculate the checksum.","score":[0.0781,0.119]}
{"code":"# is used to<extra_id_0>\r\ndef encoding_for_bars(*bars)\r\n      wide, narrow, space = wide_encoding, narrow_encoding, space_encoding\r\n      bars.flatten.inject '' do |enc,bar|\r\n        enc + (bar == WIDE ? wide : narrow) + space\r\n      end\r\n    end","code-length":78,"reference":"Generate encoding for an array of W,N","result":"Encode the code.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef render_to_cairo_context(context, options={})\r\n      if context.respond_to?(:have_current_point?) and\r\n          context.have_current_point?\r\n        current_x, current_y = context.current_point\r\n      else\r\n        current_x = x(options) || margin(options)\r\n        current_y = y(options) || margin(options)\r\n      end\r\n      _xdim = xdim(options)\r\n      _height = height(options)\r\n      original_current_x = current_x\r\n      context.save do\r\n        context.set_source_color(:black)\r\n        context.fill do\r\n          if barcode.two_dimensional?\r\n            boolean_groups.each do |groups|\r\n              groups.each do |bar,amount|\r\n                current_width = _xdim * amount\r\n                if bar\r\n                  context.rectangle(current_x, current_y, current_width, _xdim)\r\n                end\r\n                current_x += current_width\r\n              end\r\n              current_x = original_current_x\r\n              current_y += _xdim\r\n            end\r\n          else\r\n            boolean_groups.each do |bar,amount|\r\n              current_width = _xdim * amount\r\n              if bar\r\n                context.rectangle(current_x, current_y, current_width, _height)\r\n              end\r\n              current_x += current_width\r\n            end\r\n          end\r\n        end\r\n      end\r\n      context\r\n    end","code-length":385,"reference":"Render the barcode onto a Cairo context","result":"Render the barcode to a cairo context.","score":[0.3575,0.6914]}
{"code":"# is used to<extra_id_0>\r\ndef to_png(options={})\r\n      output_to_string_io do |io|\r\n        Cairo::ImageSurface.new(options[:format],\r\n                                full_width(options),\r\n                                full_height(options)) do |surface|\r\n          render(surface, options)\r\n          surface.write_to_png(io)\r\n        end\r\n      end\r\n    end","code-length":103,"reference":"Render the barcode to a PNG image","result":"Render the output.","score":[0.1522,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef to_ps(options={})\r\n      output_to_string_io do |io|\r\n        Cairo::PSSurface.new(io,\r\n                             full_width(options),\r\n                             full_height(options)) do |surface|\r\n          surface.eps = options[:eps] if surface.respond_to?(:eps=)\r\n          render(surface, options)\r\n        end\r\n      end\r\n    end","code-length":112,"reference":"Render the barcode to a PS document","result":"Convert the output to a PSSurface.","score":[0.2558,0.3704]}
{"code":"# is used to<extra_id_0>\r\ndef to_pdf(options={})\r\n      output_to_string_io do |io|\r\n        Cairo::PDFSurface.new(io,\r\n                              full_width(options),\r\n                              full_height(options)) do |surface|\r\n          render(surface, options)\r\n        end\r\n      end\r\n    end","code-length":88,"reference":"Render the barcode to a PDF document","result":"Render the output.","score":[0.1522,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef to_svg(options={})\r\n      output_to_string_io do |io|\r\n        Cairo::SVGSurface.new(io,\r\n                              full_width(options),\r\n                              full_height(options)) do |surface|\r\n          render(surface, options)\r\n        end\r\n      end\r\n    end","code-length":88,"reference":"Render the barcode to an SVG document","result":"Generate the output.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef max_threads=(number)\r\n      @max_threads = number.to_i.positive? && throttle.zero? ? number.to_i : 1\r\n      hydra.max_concurrency = @max_threads\r\n    end","code-length":64,"reference":"Set the threads attribute and update hydra accordinly ","result":"Set the max threads.","score":[0.1662,0.2467]}
{"code":"# is used to<extra_id_0>\r\ndef online?(path = nil)\r\n      NS::Browser.get(url(path)).code.nonzero? ? true : false\r\n    end","code-length":43,"reference":"Checks if the remote website is up.","result":"Detect if a variable is defined.","score":[0.1943,0.1449]}
{"code":"# is used to<extra_id_0>\r\ndef head_and_get(path, codes = [200], params = {})\r\n      url_to_get  = url(path)\r\n      head_params = (params[:head] || {}).merge(head_or_get_params)\r\n      head_res = NS::Browser.forge_request(url_to_get, head_params).run\r\n      codes.include?(head_res.code) ? NS::Browser.get(url_to_get, params[:get] || {}) : head_res\r\n    end","code-length":135,"reference":"Perform a HEAD request to the path provided, then if its response code is in the array of codes given, a GET is done and the response returned.","result":"Make the head and get requests.","score":[0.0059,0.0775]}
{"code":"# is used to<extra_id_0>\r\ndef db\r\n      return @db unless @db.nil?\r\n      Sequel.single_threaded = true\r\n      @db = Sequel.connect(config(:sql_url), :encoding => 'utf8')\r\n      if @db.tables.empty?\r\n        dir = File.join(File.dirname(__FILE__), 'migrations')\r\n        puts \"Database empty, running migrations from #{dir}\"\r\n        Sequel.extension :migration\r\n        Sequel::Migrator.apply(@db, dir)\r\n      end\r\n      @db\r\n    end","code-length":145,"reference":"Get a connection to the database","result":"Create a database.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_commit(repo, sha, user, comments = true)\r\n      ensure_repo(user, repo)\r\n      c = retrieve_commit(repo, sha, user)\r\n      if c.nil?\r\n        warn \"Commit #{user}\/#{repo} -> #{sha} does not exist\"\r\n        return\r\n      end\r\n      stored = store_commit(c, repo, user)\r\n      ensure_parents(c)\r\n      if not c['commit']['comment_count'].nil? \\\r\n         and c['commit']['comment_count'] > 0\r\n        ensure_commit_comments(user, repo, sha) if comments\r\n      end\r\n      ensure_repo_commit(user, repo, sha)\r\n      stored\r\n    end","code-length":183,"reference":"Make sure a commit exists","result":"Ensure that the commit is stored.","score":[0.193,0.3676]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_parents(commit)\r\n      commits = db[:commits]\r\n      parents = db[:commit_parents]\r\n      commit['parents'].map do |p|\r\n        save do\r\n          url = p['url'].split(\/\\\/\/)\r\n          this = commits.first(:sha => commit['sha'])\r\n          parent = commits.first(:sha => url[7])\r\n          if parent.nil?\r\n            c = retrieve_commit(url[5], url[7], url[4])\r\n            if c.nil?\r\n              warn \"Could not retrieve commit_parent #{url[4]}\/#{url[5]} -> #{url[7]} to #{this[:sha]}\"\r\n              next\r\n            end\r\n            parent = store_commit(c, url[5], url[4])\r\n          end\r\n          if parent.nil?\r\n            warn \"Could not find #{url[4]}\/#{url[5]} -> #{url[7]}, parent to commit #{this[:sha]}\"\r\n            next\r\n          end\r\n          if parents.first(:commit_id => this[:id],\r\n                           :parent_id => parent[:id]).nil?\r\n            parents.insert(:commit_id => this[:id],\r\n                           :parent_id => parent[:id])\r\n            info \"Added commit_parent #{parent[:sha]} to commit #{this[:sha]}\"\r\n          else\r\n            debug \"Parent #{parent[:sha]} for commit #{this[:sha]} exists\"\r\n          end\r\n          parents.first(:commit_id => this[:id], :parent_id => parent[:id])\r\n        end\r\n      end.select{|x| !x.nil?}\r\n    end","code-length":402,"reference":"Get the parents for a specific commit.","result":"In the template.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_user_followers(followed)\r\n      curuser = ensure_user(followed, false, false)\r\n      followers = db.from(:followers, :users).\\\r\n          where(Sequel.qualify('followers', 'follower_id') => Sequel.qualify('users', 'id')).\\\r\n          where(Sequel.qualify('followers', 'user_id') => curuser[:id]).select(:login).all\r\n      retrieve_user_followers(followed).reduce([]) do |acc, x|\r\n        if followers.find {|y| y[:login] == x['login']}.nil?\r\n          acc << x\r\n        else\r\n          acc\r\n        end\r\n      end.map { |x| save{ensure_user_follower(followed, x['login']) }}.select{|x| !x.nil?}\r\n    end","code-length":229,"reference":"Get all followers for a user.","result":"Ensure the user is a follower.","score":[0.193,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_user_follower(followed, follower, date_added = nil)\r\n      follower_user = ensure_user(follower, false, false)\r\n      followed_user = ensure_user(followed, false, false)\r\n      if followed_user.nil? or follower_user.nil?\r\n        warn \"Could not find follower #{follower} or user #{followed}\"\r\n        return\r\n      end\r\n      followers = db[:followers]\r\n      follower_id = follower_user[:id]\r\n      followed_id = followed_user[:id]\r\n      follower_exists = followers.first(:user_id => followed_id,\r\n                                        :follower_id => follower_id)\r\n      if follower_exists.nil?\r\n        added = if date_added.nil?\r\n                  max(follower_user[:created_at], followed_user[:created_at])\r\n                else\r\n                  date_added\r\n                end\r\n        retrieved = retrieve_user_follower(followed, follower)\r\n        if retrieved.nil?\r\n          warn \"Could not retrieve follower #{follower} for #{followed}\"\r\n          return\r\n        end\r\n        followers.insert(:user_id => followed_id,\r\n                         :follower_id => follower_id,\r\n                         :created_at => added)\r\n        info \"Added follower #{follower} to #{followed}\"\r\n      else\r\n        debug \"Follower #{follower} for user #{followed} exists\"\r\n      end\r\n      unless date_added.nil?\r\n        followers.filter(:user_id => followed_id, :follower_id => follower_id)\r\n                 .update(:created_at => date(date_added))\r\n        info \"Updated follower #{followed} -> #{follower}, created_at -> #{date(date_added)}\"\r\n      end\r\n      followers.first(:user_id => followed_id, :follower_id => follower_id)\r\n    end","code-length":499,"reference":"Make sure that a user follows another one","result":"Ensure the user is a follower.","score":[0.1645,0.3276]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_user_byemail(email, name)\r\n      users = db[:users]\r\n      usr = users.first(:email => email)\r\n      if usr.nil?\r\n        u = retrieve_user_byemail(email, name)\r\n        if u.nil? or u['login'].nil?\r\n          warn \"Could not retrieve user #{email} through search API query\"\r\n          login = (0...8).map { 65.+(rand(25)).chr }.join\r\n          users.insert(:email => email,\r\n                       :name => name,\r\n                       :login => login,\r\n                       :fake => true,\r\n                       :deleted => false,\r\n                       :created_at => Time.now)\r\n          info \"Added user fake #{login} -> #{email}\"\r\n          users.first(:login => login)\r\n        else\r\n          in_db = users.first(:login => u['login'])\r\n          geo = geolocate(location: u['location'])\r\n          if in_db.nil?\r\n            users.insert(:login => u['login'],\r\n                         :name => u['name'],\r\n                         :company => u['company'],\r\n                         :email => u['email'],\r\n                         :long => geo[:long],\r\n                         :lat => geo[:lat],\r\n                         :country_code => geo[:country_code],\r\n                         :state => geo[:state],\r\n                         :city => geo[:city],\r\n                         :fake => false,\r\n                         :deleted => false,\r\n                         :created_at => date(u['created_at']))\r\n            info \"Added user #{u['login']} (#{email}) through search API query\"\r\n          else\r\n            in_db.update(:name => u['name'],\r\n                         :company => u['company'],\r\n                         :email => u['email'],\r\n                         :long => geo[:long],\r\n                         :lat => geo[:lat],\r\n                         :country_code => geo[:country_code],\r\n                         :state => geo[:state],\r\n                         :city => geo[:city],\r\n                         :fake => false,\r\n                         :deleted => false,\r\n                         :created_at => date(u['created_at']))\r\n            debug \"User #{u['login']} with email #{email} exists\"\r\n          end\r\n          users.first(:login => u['login'])\r\n        end\r\n      else\r\n        debug \"User with email #{email} exists\"\r\n        usr\r\n      end\r\n    end","code-length":595,"reference":"Try to retrieve a user by email.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_repo(user, repo, recursive = false)\r\n      repos = db[:projects]\r\n      curuser = ensure_user(user, false, false)\r\n      if curuser.nil?\r\n        warn \"Could not find user #{user}\"\r\n        return\r\n      end\r\n      currepo = repos.first(:owner_id => curuser[:id], :name => repo)\r\n      unless currepo.nil?\r\n        debug \"Repo #{user}\/#{repo} exists\"\r\n        return refresh_repo(user, repo, currepo)\r\n      end\r\n      r = retrieve_repo(user, repo, true)\r\n      if r.nil?\r\n        warn \"Could not retrieve repo #{user}\/#{repo}\"\r\n        return\r\n      end\r\n      if r['owner']['login'] != curuser[:login]\r\n        info \"Repo changed owner from #{curuser[:login]} to #{r['owner']['login']}\"\r\n        curuser = ensure_user(r['owner']['login'], false, false)\r\n      end\r\n      repos.insert(:url => r['url'],\r\n                   :owner_id => curuser[:id],\r\n                   :name => r['name'],\r\n                   :description => unless r['description'].nil? then r['description'][0..254] else nil end,\r\n                   :language => r['language'],\r\n                   :created_at => date(r['created_at']),\r\n                   :updated_at => date(Time.now),\r\n                   :etag => unless r['etag'].nil? then r['etag'] end)\r\n      unless r['parent'].nil?\r\n        parent_owner = r['parent']['owner']['login']\r\n        parent_repo = r['parent']['name']\r\n        parent = ensure_repo(parent_owner, parent_repo)\r\n        if parent.nil?\r\n          warn \"Could not find repo #{parent_owner}\/#{parent_repo}, parent of: #{user}\/#{repo}\"\r\n          repos.filter(:owner_id => curuser[:id], :name => repo).update(:forked_from => -1)\r\n        else\r\n          repos.filter(:owner_id => curuser[:id], :name => repo).update(:forked_from => parent[:id])\r\n          info \"Repo #{user}\/#{repo} is a fork of #{parent_owner}\/#{parent_repo}\"\r\n          unless ensure_fork_point(user, repo).nil?\r\n            warn \"Could not find fork point for #{user}\/#{repo}, fork of #{parent_owner}\/#{parent_repo}\"\r\n          end\r\n        end\r\n      end\r\n      if recursive and not ensure_repo_recursive(user, repo)\r\n        warn \"Could retrieve #{user}\/#{repo} recursively\"\r\n        return nil\r\n      end\r\n      info \"Added repo #{user}\/#{repo}\"\r\n      return repos.first(:owner_id => curuser[:id], :name => repo)\r\n    end","code-length":686,"reference":"Ensure that a repo exists, or fetch its latest state from Github [user]  The email or login name to which this repo belongs [repo]  The repo name","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_languages(owner, repo)\r\n      currepo = ensure_repo(owner, repo)\r\n      langs = retrieve_languages(owner, repo)\r\n      if langs.nil? or langs.empty?\r\n        warn \"Could not find languages for repo #{owner}\/#{repo}\"\r\n        return\r\n      end\r\n      ts = Time.now\r\n      langs.keys.each do |lang|\r\n        db[:project_languages].insert(\r\n          :project_id => currepo[:id],\r\n          :language   => lang.downcase,\r\n          :bytes      => langs[lang],\r\n          :created_at => ts\r\n        )\r\n        info \"Added project_language #{owner}\/#{repo} -> #{lang} (#{langs[lang]} bytes)\"\r\n      end\r\n      db[:project_languages].where(:project_id => currepo[:id]).where(:created_at => ts).all\r\n    end","code-length":226,"reference":"Get details about the languages used in the repository","result":"Ensure that the project_languages table exists.","score":[0.1171,0.0575]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_fork_commits(owner, repo, parent_owner, parent_repo)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find repo #{owner}\/#{repo}\"\r\n        return\r\n      end\r\n      parent = ensure_repo(parent_owner, parent_repo)\r\n      if parent.nil?\r\n        warn \"Could not find repo #{parent_owner}\/#{parent_repo}, parent of #{owner}\/#{repo}\"\r\n        return\r\n      end\r\n      strategy = case\r\n                   when config(:fork_commits).match(\/all\/i)\r\n                     :all\r\n                   when config(:fork_commits).match(\/fork_point\/i)\r\n                     :fork_point\r\n                   when config(:fork_commits).match(\/none\/i)\r\n                     :none\r\n                   else\r\n                     :fork_point\r\n                 end\r\n      fork_commit = ensure_fork_point(owner, repo)\r\n      if fork_commit.nil? or fork_commit.empty?\r\n        warn \"Could not find fork commit for repo #{owner}\/#{repo}. Retrieving all commits.\"\r\n        return ensure_commits(owner, repo, fork_all: true)\r\n      end\r\n      debug \"Retrieving commits for fork #{owner}\/#{repo}: strategy is #{strategy}\"\r\n      return if strategy == :none\r\n      if strategy == :fork_point\r\n        info \"Retrieving commits for #{owner}\/#{repo} until fork commit #{fork_commit[:sha]}\"\r\n        master_branch = retrieve_default_branch(parent_owner, parent_repo)\r\n        return if master_branch.nil?\r\n        sha   = master_branch\r\n        found = false\r\n        while not found\r\n          commits = retrieve_commits(repo, sha, owner, 1)\r\n          if commits.size == 0\r\n            break\r\n          end\r\n          if commits.size == 1 and commits[0]['sha'] == sha\r\n            break\r\n          end\r\n          for c in commits\r\n            ensure_commit(repo, c['sha'], owner)\r\n            sha = c['sha']\r\n            if c['sha'] == fork_commit[:sha]\r\n              found = true\r\n              break\r\n            end\r\n          end\r\n        end\r\n      end\r\n      if strategy == :all\r\n        shared_commit = db[:commits].first(:sha => fork_commit)\r\n        copied        = 0\r\n        to_copy = db.from(:project_commits, :commits).\\\r\n                  where(Sequel.qualify('project_commits', 'commit_id') => Sequel.qualify('commits', 'id')).\\\r\n                  where(Sequel.qualify('project_commits', 'project_id') => parent[:id]).\\\r\n                  where('commits.created_at < ?', shared_commit[:created_at]).\\\r\n                  select(Sequel.qualify('commits','id'))\r\n        to_copy.each do |c|\r\n          copied += 1\r\n          begin\r\n            db[:project_commits].insert(\r\n                :project_id => currepo[:id],\r\n                :commit_id  => c[:id]\r\n            )\r\n            debug \"Copied commit #{c[:sha]} #{parent_owner}\/#{parent_repo} -> #{owner}\/#{repo} (#{copied} total)\"\r\n          rescue StandardError => e\r\n            warn \"Could not copy commit #{c[:sha]} #{parent_owner}\/#{parent_repo} -> #{owner}\/#{repo} : #{e.message}\"\r\n          end\r\n        end\r\n        info \"Finished copying commits from #{parent_owner}\/#{parent_repo} -> #{owner}\/#{repo}: #{copied} total\"\r\n      end\r\n    end","code-length":885,"reference":"Fast path to project forking.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_fork_point(owner, repo)\r\n      fork = ensure_repo(owner, repo, false)\r\n      if fork[:forked_from].nil?\r\n        warn \"Repo #{owner}\/#{repo} is not a fork\"\r\n        return nil\r\n      end\r\n      unless fork[:forked_commit_id].nil?\r\n        commit = db[:commits].where(:id => fork[:forked_commit_id]).first\r\n        return commit unless commit.nil?\r\n      end\r\n      parent = db.from(:projects, :users).\\\r\n                where(Sequel.qualify('projects', 'owner_id') => Sequel.qualify('users', 'id')).\\\r\n                where(Sequel.qualify('projects', 'id') => fork[:forked_from]).\\\r\n                select(Sequel.qualify('users', 'login'), Sequel.qualify('projects','name')).first\r\n      if parent.nil?\r\n        warn \"Unknown parent for repo #{owner}\/#{repo}\"\r\n        return nil\r\n      end\r\n      default_branch = retrieve_default_branch(parent[:login], parent[:name])\r\n      diff = retrieve_master_branch_diff(owner, repo, default_branch, parent[:login], parent[:name], default_branch)\r\n      if diff.nil? or diff.empty?\r\n        default_branch = retrieve_default_branch(parent[:login], parent[:name], true)\r\n        diff = retrieve_master_branch_diff(owner, repo, default_branch, parent[:login], parent[:name], default_branch)\r\n      end\r\n      if diff.nil? or diff.empty?\r\n        warn \"No common ancestor between #{parent[:login]}\/#{parent[:name]} and #{owner}\/#{repo}\"\r\n        return nil\r\n      else\r\n        debug \"Fork #{owner}\/#{repo} is #{diff['ahead_by']} commits ahead and #{diff['behind_by']} commits behind #{parent[:login]}\/#{parent[:name]}\"\r\n      end\r\n      if diff['ahead_by'].to_i > 0\r\n        earliest_diverging = diff['commits'].sort_by{|x| x['commit']['author']['date']}.first\r\n        if earliest_diverging['parents'].nil?\r\n          likely_fork_point = ensure_commit(parent[:name], earliest_diverging['sha'], parent['login'])\r\n        else\r\n          likely_fork_point = earliest_diverging['parents'].\\\r\n              map{ |x| ensure_commit(parent[:name], x['sha'], parent[:login])}.\\\r\n              select{|x| !x.nil?}.\\\r\n              sort_by { |x| x[:created_at]}.\\\r\n              last\r\n        end\r\n        forked_sha  = likely_fork_point[:sha]\r\n      else\r\n        forked_sha = diff['merge_base_commit']['sha']\r\n      end\r\n      forked_commit = ensure_commit(repo, forked_sha, owner);\r\n      debug \"Fork commit for #{owner}\/#{repo} is #{forked_sha}\"\r\n      unless forked_commit.nil?\r\n        db[:projects].filter(:id => fork[:id]).update(:forked_commit_id => forked_commit[:id])\r\n        info \"Repo #{owner}\/#{repo} was forked at #{parent[:login]}\/#{parent[:name]}:#{forked_sha}\"\r\n      end\r\n      db[:commits].where(:sha => forked_sha).first\r\n    end","code-length":844,"reference":"Retrieve and return the commit at which the provided fork was forked at","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_orgs(user)\r\n      retrieve_orgs(user).map{|o| save{ensure_participation(user, o['login'])}}.select{|x| !x.nil?}\r\n    end","code-length":63,"reference":"Make sure that the organizations the user participates into exist [user]  The login name of the user to check the organizations for","result":"Ensure the user is a valid user.","score":[0.0268,0.0732]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_participation(user, organization, members = true)\r\n      org = ensure_org(organization, members)\r\n      if org.nil?\r\n        warn \"Could not find organization #{organization}\"\r\n        return\r\n      end\r\n      usr = ensure_user(user, false, false)\r\n      org_members = db[:organization_members]\r\n      participates = org_members.first(:user_id => usr[:id], :org_id => org[:id])\r\n      if participates.nil?\r\n        org_members.insert(:user_id => usr[:id],\r\n                           :org_id => org[:id])\r\n        info \"Added participation #{organization} -> #{user}\"\r\n        org_members.first(:user_id => usr[:id], :org_id => org[:id])\r\n      else\r\n        debug \"Participation #{organization} -> #{user} exists\"\r\n        participates\r\n      end\r\n    end","code-length":235,"reference":"Make sure that a user participates to the provided organization [user] The login name of the user to check the organizations for [org]  The login name of the organization to check whether the user        belongs in","result":"Ensure the presence of a class.","score":[0.0017,0.0455]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_org(organization, members = true)\r\n      org = db[:users].first(:login => organization, :type => 'org')\r\n      if org.nil?\r\n        org = ensure_user(organization, false, false)\r\n        if org[:type] != 'ORG'\r\n          warn \"User #{organization} is not an organization\"\r\n          return nil\r\n        end\r\n      end\r\n      if members\r\n        retrieve_org_members(organization).map do |x|\r\n          ensure_participation(ensure_user(x['login'], false, false)[:login],\r\n                               organization, false)\r\n        end\r\n      end\r\n      org\r\n    end","code-length":172,"reference":"Make sure that an organization exists [organization]  The login name of the organization","result":"Create a new organization.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_commit_comments(user, repo, sha)\r\n      commit_id = db[:commits].first(:sha => sha)[:id]\r\n      stored_comments = db[:commit_comments].filter(:commit_id => commit_id)\r\n      commit_comments = retrieve_commit_comments(user, repo, sha)\r\n      not_saved = commit_comments.reduce([]) do |acc, x|\r\n        if stored_comments.find{|y| y[:comment_id] == x['id']}.nil?\r\n          acc << x\r\n        else\r\n          acc\r\n        end\r\n      end\r\n      not_saved.map{|x| save{ensure_commit_comment(user, repo, sha, x['id'])}}.select{|x| !x.nil?}\r\n    end","code-length":200,"reference":"Get all comments for a commit [user]  The login name of the organization [user]  The repository containing the commit whose comments will be retrieved [sha]  The commit sha to retrieve comments for","result":"Ensure that the commit comments are saved.","score":[0.0071,0.107]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_watchers(owner, repo)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find repo #{owner}\/#{repo} for retrieving watchers\"\r\n        return\r\n      end\r\n      watchers = db.from(:watchers, :users).\\\r\n          where(Sequel.qualify('watchers', 'user_id') => Sequel.qualify('users', 'id')).\\\r\n          where(Sequel.qualify('watchers', 'repo_id') => currepo[:id]).select(:login).all\r\n      retrieve_watchers(owner, repo).reduce([]) do |acc, x|\r\n        if watchers.find { |y|\r\n          y[:login] == x['login']\r\n        }.nil?\r\n          acc << x\r\n        else\r\n          acc\r\n        end\r\n      end.map { |x| save{ensure_watcher(owner, repo, x['login']) }}.select{|x| !x.nil?}\r\n    end","code-length":261,"reference":"Make sure that all watchers exist for a repository","result":"Ensure the watchers for a given repo.","score":[0.1899,0.3587]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_pull_requests(owner, repo, refresh = false)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find repo #{owner}\/#{repo} for retrieving pull requests\"\r\n        return\r\n      end\r\n      raw_pull_reqs = if refresh\r\n                        retrieve_pull_requests(owner, repo, refresh = true)\r\n                      else\r\n                        pull_reqs = db[:pull_requests].filter(:base_repo_id => currepo[:id]).all\r\n                        retrieve_pull_requests(owner, repo).reduce([]) do |acc, x|\r\n                          if pull_reqs.find { |y| y[:pullreq_id] == x['number'] }.nil?\r\n                            acc << x\r\n                          else\r\n                            acc\r\n                          end\r\n                        end\r\n                      end\r\n      raw_pull_reqs.map { |x| save { ensure_pull_request(owner, repo, x['number']) } }.select { |x| !x.nil? }\r\n    end","code-length":259,"reference":"Process all pull requests","result":"Ensure that the pull request is created.","score":[0.1615,0.436]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_pull_request_history(id, ts, act, actor)\r\n      user = unless actor.nil?\r\n               ensure_user(actor, false, false)\r\n             end\r\n      pull_req_history = db[:pull_request_history]\r\n      entry =  if ['opened', 'merged'].include? act\r\n                  pull_req_history.first(:pull_request_id => id,\r\n                                         :action => act)\r\n               else\r\n                 pull_req_history.first(:pull_request_id => id,\r\n                                        :created_at => (ts - 3)..(ts + 3),\r\n                                        :action => act)\r\n               end\r\n      if entry.nil?\r\n        pull_req_history.insert(:pull_request_id => id,\r\n                                :created_at => ts,\r\n                                :action => act,\r\n                                :actor_id => unless user.nil? then user[:id] end)\r\n        info \"Added pullreq_event (#{id}) -> (#{act}) by (#{actor}) timestamp #{ts}\"\r\n      else\r\n        debug \"Pull request (#{id}) event (#{act}) by (#{actor}) timestamp #{ts} exists\"\r\n        if entry[:actor_id].nil? and not user.nil?\r\n          pull_req_history.where(:pull_request_id => id,\r\n                               :created_at => (ts - 3)..(ts + 3),\r\n                               :action => act)\\\r\n                          .update(:actor_id => user[:id])\r\n          info \"Updated pull request (#{id}) event (#{act}) timestamp #{ts}, actor -> #{user[:login]}\"\r\n        end\r\n      end\r\n    end","code-length":405,"reference":"Adds a pull request history event","result":"Ensure the pull request history is valid.","score":[0.3327,0.4827]}
{"code":"# is used to<extra_id_0>\r\ndef pr_is_intra_branch(req)\r\n      return false unless pr_has_head_repo(req)\r\n      if req['head']['repo']['owner']['login'] ==\r\n          req['base']['repo']['owner']['login'] and\r\n          req['head']['repo']['full_name'] == req['base']['repo']['full_name']\r\n        true\r\n      else\r\n        false\r\n      end\r\n    end","code-length":110,"reference":"Checks whether a pull request concerns two branches of the same repository","result":"Determine if a PR is intra branch.","score":[0.0791,0.0435]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_forks(owner, repo)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find repo #{owner}\/#{repo} for retrieving forks\"\r\n        return\r\n      end\r\n      existing_forks = db.from(:projects, :users).\\\r\n          where(Sequel.qualify('users', 'id') => Sequel.qualify('projects', 'owner_id')). \\\r\n          where(Sequel.qualify('projects', 'forked_from') => currepo[:id]).\\\r\n          select(Sequel.qualify('projects', 'name'), :login).all\r\n      retrieve_forks(owner, repo).reduce([]) do |acc, x|\r\n        if existing_forks.find do |y|\r\n          forked_repo_owner = x['url'].split(\/\\\/\/)[4]\r\n          forked_repo_name = x['url'].split(\/\\\/\/)[5]\r\n          y[:login] == forked_repo_owner && y[:name] == forked_repo_name\r\n        end.nil?\r\n          acc << x\r\n        else\r\n          acc\r\n        end\r\n      end.map { |x| save{ensure_fork(owner, repo, x['id']) }}.select{|x| !x.nil?}\r\n    end","code-length":339,"reference":"Get all forks for a project.","result":"Ensure the forked repo exists.","score":[0,0.0847]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_fork(owner, repo, fork_id)\r\n      fork = retrieve_fork(owner, repo, fork_id)\r\n      if fork.nil?\r\n        warn \"Could not retrieve fork #{owner}\/#{repo} -> #{fork_id}\"\r\n        return\r\n      end\r\n      fork_name = if fork['full_name'].nil? then fork['url'].split(\/\\\/\/)[4..5].join('\/') else fork['full_name'] end\r\n      fork_owner = fork_name.split(\/\\\/\/)[0]\r\n      fork_name = fork_name.split(\/\\\/\/)[1]\r\n      r = ensure_repo(fork_owner, fork_name, true)\r\n      if r.nil?\r\n        warn \"Could not add #{fork_owner}\/#{fork_name} as fork of #{owner}\/#{repo}\"\r\n      else\r\n        info \"Added fork #{fork_owner}\/#{fork_name} of #{owner}\/#{repo}\"\r\n      end\r\n      r\r\n    end","code-length":243,"reference":"Make sure that a fork is retrieved for a project","result":"Ensure the fork exists.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_issues(owner, repo)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find repo #{owner}\/#{repo} for retrieving issues\"\r\n        return\r\n      end\r\n      issues = db[:issues].filter(:repo_id => currepo[:id]).all\r\n      raw_issues = retrieve_issues(owner, repo).reduce([]) do |acc, x|\r\n                     if issues.find { |y| y[:issue_id] == x['number'] }.nil?\r\n                       acc << x\r\n                     else\r\n                         acc\r\n                     end\r\n                   end\r\n      raw_issues.map { |x| save { ensure_issue(owner, repo, x['number']) } }.select { |x| !x.nil? }\r\n    end","code-length":205,"reference":"Make sure all issues exist for a project","result":"Ensure issues for a given repo.","score":[0.2165,0.4046]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_issue(owner, repo, issue_id, events = true,\r\n                     comments = true, labels = true)\r\n      issues = db[:issues]\r\n      repository = ensure_repo(owner, repo)\r\n      if repository.nil?\r\n        warn \"Could not find repo #{owner}\/#{repo} for retrieving issue #{issue_id}\"\r\n        return\r\n      end\r\n      cur_issue = issues.first(:issue_id => issue_id,\r\n                               :repo_id => repository[:id])\r\n      retrieved = retrieve_issue(owner, repo, issue_id)\r\n      if retrieved.nil?\r\n        warn \"Could not retrieve issue #{owner}\/#{repo} -> #{issue_id}\"\r\n        return\r\n      end\r\n      pull_req = unless retrieved['pull_request'].nil? or\r\n          retrieved['pull_request']['patch_url'].nil?\r\n                   debug \"Issue #{owner}\/#{repo}->#{issue_id} is a pull request\"\r\n                   ensure_pull_request(owner, repo, issue_id, false, false, false)\r\n                 end\r\n      if cur_issue.nil?\r\n        reporter = ensure_user(retrieved['user']['login'], false, false)\r\n        assignee = unless retrieved['assignee'].nil?\r\n                     ensure_user(retrieved['assignee']['login'], false, false)\r\n                   end\r\n        issues.insert(:repo_id => repository[:id],\r\n                     :assignee_id => unless assignee.nil? then assignee[:id] end,\r\n                     :reporter_id => reporter[:id],\r\n                     :issue_id => issue_id,\r\n                     :pull_request => if pull_req.nil? then false else true end,\r\n                     :pull_request_id => unless pull_req.nil? then pull_req[:id] end,\r\n                     :created_at => date(retrieved['created_at']))\r\n        info \"Added issue #{owner}\/#{repo} -> #{issue_id}\"\r\n      else\r\n        debug \"Issue #{owner}\/#{repo}->#{issue_id} exists\"\r\n        if cur_issue[:pull_request] == false and not pull_req.nil?\r\n          info \"Updated issue #{owner}\/#{repo}->#{issue_id} as pull request\"\r\n          issues.filter(:issue_id => issue_id, :repo_id => repository[:id]).update(\r\n              :pull_request => true,\r\n              :pull_request_id => pull_req[:id])\r\n        end\r\n      end\r\n      ensure_issue_events(owner, repo, issue_id) if events\r\n      ensure_issue_comments(owner, repo, issue_id) if comments\r\n      ensure_issue_labels(owner, repo, issue_id) if labels\r\n      issues.first(:issue_id => issue_id,\r\n                   :repo_id => repository[:id])\r\n    end","code-length":692,"reference":"Make sure that the issue exists","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_issue_events(owner, repo, issue_id)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find repository #{owner}\/#{repo} for retrieving events for issue #{issue_id}\"\r\n        return\r\n      end\r\n      issue = ensure_issue(owner, repo, issue_id, false, false, false)\r\n      if issue.nil?\r\n        warn \"Could not find issue #{owner}\/#{repo} -> #{issue_id} for retrieving events\"\r\n        return\r\n      end\r\n      retrieve_issue_events(owner, repo, issue_id).reduce([]) do |acc, x|\r\n        if db[:issue_events].first(:issue_id => issue[:id],\r\n                                    :event_id => x['id']).nil?\r\n          acc << x\r\n        else\r\n          acc\r\n        end\r\n      end.map { |x|\r\n        save{ensure_issue_event(owner, repo, issue_id, x['id'])}\r\n      }.select{|x| !x.nil?}\r\n    end","code-length":276,"reference":"Retrieve and process all events for an issue","result":"Ensure that the issue events are created.","score":[0.1665,0.1266]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_issue_event(owner, repo, issue_id, event_id)\r\n      issue = ensure_issue(owner, repo, issue_id, false, false, false)\r\n      if issue.nil?\r\n        warn \"Could not find issue #{owner}\/#{repo} -> #{issue_id} for retrieving event #{event_id}\"\r\n        return\r\n      end\r\n      issue_event_str = \"#{owner}\/#{repo} -> #{issue_id}\/#{event_id}\"\r\n      curevent = db[:issue_events].first(:issue_id => issue[:id],\r\n                                          :event_id => event_id)\r\n      if curevent.nil?\r\n        retrieved = retrieve_issue_event(owner, repo, issue_id, event_id)\r\n        if retrieved.nil?\r\n          warn \"Could not retrieve issue_event #{owner}\/#{repo} -> #{issue_id}\/#{issue_event_str}\"\r\n          return\r\n        elsif retrieved['actor'].nil?\r\n          warn \"Could not find issue_event_actor #{owner}\/#{repo} -> #{issue_id}\/#{issue_event_str}\"\r\n          return\r\n        end\r\n        actor = ensure_user(retrieved['actor']['login'], false, false)\r\n        action_specific = case retrieved['event']\r\n                            when \"referenced\" then retrieved['commit_id']\r\n                            when \"merged\" then retrieved['commit_id']\r\n                            when \"closed\" then retrieved['commit_id']\r\n                            else nil\r\n                          end\r\n        if retrieved['event'] == 'assigned'\r\n          def update_assignee(owner, repo, issue, actor)\r\n            db[:issues].first(:id => issue[:id]).update(:assignee_id => actor[:id])\r\n            info \"Updated #{owner}\/#{repo} -> #{issue[:id]}, assignee -> #{actor[:id]}\"\r\n          end\r\n          if issue[:assignee_id].nil? then\r\n            update_assignee(owner, repo, issue, actor)\r\n          else\r\n            existing = db[:issue_events].\\\r\n                        filter(:issue_id => issue[:id],:action => 'assigned').\\\r\n                        order(Sequel.desc(:created_at)).first\r\n            if existing.nil?\r\n              update_assignee(owner, repo, issue, actor)\r\n            elsif date(existing[:created_at]) < date(retrieved['created_at'])\r\n              update_assignee(owner, repo, issue, actor)\r\n            end\r\n          end\r\n        end\r\n        db[:issue_events].insert(\r\n            :event_id => event_id,\r\n            :issue_id => issue[:id],\r\n            :actor_id => unless actor.nil? then actor[:id] end,\r\n            :action => retrieved['event'],\r\n            :action_specific => action_specific,\r\n            :created_at => date(retrieved['created_at']))\r\n        info \"Added issue_event #{owner}\/#{repo} -> #{issue_id}\/#{issue_event_str}\"\r\n        db[:issue_events].first(:issue_id => issue[:id],\r\n                                 :event_id => event_id)\r\n      else\r\n        debug \"Issue event #{owner}\/#{repo} -> #{issue_id}\/#{issue_event_str} exists\"\r\n        curevent\r\n      end\r\n    end","code-length":798,"reference":"Retrieve and process +event_id+ for an +issue_id+","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_issue_comments(owner, repo, issue_id, pull_req_id = nil)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find repository #{owner}\/#{repo} for retrieving issue comments for issue #{issue_id}\"\r\n        return\r\n      end\r\n      issue = if pull_req_id.nil?\r\n                ensure_issue(owner, repo, issue_id, false, false, false)\r\n              else\r\n                db[:issues].first(:pull_request_id => pull_req_id)\r\n              end\r\n      if issue.nil?\r\n        warn \"Could not find issue #{owner}\/#{repo} -> #{issue_id} for retrieving issue comments\"\r\n        return\r\n      end\r\n      retrieve_issue_comments(owner, repo, issue_id).reduce([]) do |acc, x|\r\n        if db[:issue_comments].first(:issue_id => issue[:id],\r\n                                    :comment_id => x['id']).nil?\r\n          acc << x\r\n        else\r\n          acc\r\n        end\r\n      end.map { |x|\r\n        save{ensure_issue_comment(owner, repo, issue_id, x['id'], pull_req_id)}\r\n      }.select{|x| !x.nil?}\r\n    end","code-length":332,"reference":"Retrieve and process all comments for an issue.","result":"Ensure that the comments are created.","score":[0.1383,0.0641]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_issue_comment(owner, repo, issue_id, comment_id, pull_req_id = nil)\r\n      issue = if pull_req_id.nil?\r\n                ensure_issue(owner, repo, issue_id, false, false, false)\r\n              else\r\n                db[:issues].first(:pull_request_id => pull_req_id)\r\n              end\r\n      if issue.nil?\r\n        warn \"Could not find issue #{owner}\/#{repo} -> #{issue_id} for retrieving comment #{comment_id}\"\r\n        return\r\n      end\r\n      issue_comment_str = \"#{owner}\/#{repo} -> #{issue_id}\/#{comment_id}\"\r\n      curcomment = db[:issue_comments].first(:issue_id => issue[:id],\r\n                                          :comment_id => comment_id)\r\n      if curcomment.nil?\r\n        retrieved = retrieve_issue_comment(owner, repo, issue_id, comment_id)\r\n        if retrieved.nil?\r\n          warn \"Could not retrieve issue_comment #{issue_comment_str}\"\r\n          return\r\n        end\r\n        user = ensure_user(retrieved['user']['login'], false, false)\r\n        db[:issue_comments].insert(\r\n            :comment_id => comment_id,\r\n            :issue_id => issue[:id],\r\n            :user_id => unless user.nil? then user[:id] end,\r\n            :created_at => date(retrieved['created_at'])\r\n        )\r\n        info \"Added issue_comment #{issue_comment_str}\"\r\n        db[:issue_comments].first(:issue_id => issue[:id],\r\n                                   :comment_id => comment_id)\r\n      else\r\n        debug \"Issue comment #{issue_comment_str} exists\"\r\n        curcomment\r\n      end\r\n    end","code-length":446,"reference":"Retrieve and process +comment_id+ for an +issue_id+","result":"Ensure the issue is created.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_labels(owner, repo)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find #{owner}\/#{repo} for retrieving issue labels\"\r\n        return\r\n      end\r\n      repo_labels = db[:repo_labels].filter(:repo_id => currepo[:id]).all\r\n      retrieve_repo_labels(owner, repo).reduce([]) do |acc, x|\r\n        if repo_labels.find {|y| y[:name] == x['name']}.nil?\r\n          acc << x\r\n        else\r\n          acc\r\n        end\r\n      end.map { |x| save { ensure_repo_label(owner, repo, x['name']) } }.select { |x| !x.nil? }\r\n    end","code-length":202,"reference":"Retrieve repository issue labels","result":"Ensure labels for the given issue.","score":[0.193,0.119]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_repo_label(owner, repo, name)\r\n      currepo = ensure_repo(owner, repo)\r\n      if currepo.nil?\r\n        warn \"Could not find #{owner}\/#{repo} for retrieving label #{name}\"\r\n        return\r\n      end\r\n      label = db[:repo_labels].first(:repo_id => currepo[:id], :name => name)\r\n      if label.nil?\r\n        retrieved = retrieve_repo_label(owner, repo, name)\r\n        if retrieved.nil?\r\n          warn \"Could not retrieve repo_label #{owner}\/#{repo} -> #{name}\"\r\n          return\r\n        end\r\n        db[:repo_labels].insert(\r\n            :repo_id => currepo[:id],\r\n            :name => name\r\n        )\r\n        info \"Added repo_label #{owner}\/#{repo} -> #{name}\"\r\n        db[:repo_labels].first(:repo_id => currepo[:id], :name => name)\r\n      else\r\n        label\r\n      end\r\n    end","code-length":254,"reference":"Retrieve a single repository issue label by name","result":"Ensure that the label exists.","score":[0.1319,0.0649]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_issue_labels(owner, repo, issue_id)\r\n      issue = ensure_issue(owner, repo, issue_id, false, false, false)\r\n      if issue.nil?\r\n        warn \"Could not find issue #{owner}\/#{repo} -> #{issue_id} for retrieving labels\"\r\n        return\r\n      end\r\n      issue_labels = db.from(:issue_labels, :repo_labels)\\\r\n                        .where(Sequel.qualify('issue_labels', 'label_id') => Sequel.qualify('repo_labels', 'id'))\\\r\n                        .where(Sequel.qualify('issue_labels', 'issue_id') => issue[:id])\\\r\n                        .select(Sequel.qualify('repo_labels', 'name')).all\r\n      retrieve_issue_labels(owner, repo, issue_id).reduce([]) do |acc, x|\r\n        if issue_labels.find {|y| y[:name] == x['name']}.nil?\r\n          acc << x\r\n        else\r\n          acc\r\n        end\r\n      end.map { |x| save{ensure_issue_label(owner, repo, issue[:issue_id], x['name']) }}.select{|x| !x.nil?}\r\n    end","code-length":313,"reference":"Ensure that all labels have been assigned to the issue","result":"Ensure that the issue has labels.","score":[0.1845,0.3906]}
{"code":"# is used to<extra_id_0>\r\ndef ensure_issue_label(owner, repo, issue_id, name)\r\n      issue = ensure_issue(owner, repo, issue_id, false, false, false)\r\n      if issue.nil?\r\n        warn \"Could not find issue #{owner}\/#{repo} -> #{issue_id} to assign label #{name}\"\r\n        return\r\n      end\r\n      label = ensure_repo_label(owner, repo, name)\r\n      if label.nil?\r\n        warn \"Could not find repo label #{owner}\/#{repo} -> #{name}\"\r\n        return\r\n      end\r\n      issue_lbl = db[:issue_labels].first(:label_id => label[:id],\r\n                                           :issue_id => issue[:id])\r\n      if issue_lbl.nil?\r\n        db[:issue_labels].insert(\r\n            :label_id => label[:id],\r\n            :issue_id => issue[:id],\r\n        )\r\n        info \"Added issue_label #{name} to issue #{owner}\/#{repo} -> #{issue_id}\"\r\n        db[:issue_labels].first(:label_id => label[:id],\r\n                                 :issue_id => issue[:id])\r\n      else\r\n        debug \"Issue label #{name} to issue #{owner}\/#{repo} -> #{issue_id} exists\"\r\n        issue_lbl\r\n      end\r\n    end","code-length":327,"reference":"Ensure that a specific label has been assigned to the issue","result":"Ensure the issue_id is valid.","score":[0.0861,0.0962]}
{"code":"# is used to<extra_id_0>\r\ndef transaction(&block)\r\n      db\r\n      persister\r\n      result = nil\r\n      start_time = Time.now\r\n      begin\r\n        db.transaction(:rollback => :reraise, :isolation => :repeatable,\r\n                        :retry_on => @retry_on_error, :num_retries => 3) do\r\n          result = yield block\r\n        end\r\n        total = Time.now.to_ms - start_time.to_ms\r\n        debug \"Transaction committed (#{total} ms)\"\r\n        result\r\n      rescue StandardError => e\r\n        total = Time.now.to_ms - start_time.to_ms\r\n        warn \"Transaction failed (#{total} ms)\"\r\n        raise e\r\n      ensure\r\n        GC.start\r\n      end\r\n    end","code-length":197,"reference":"Run a block in a DB transaction.","result":"Run a block in a transaction.","score":[0.7118,0.8535]}
{"code":"# is used to<extra_id_0>\r\ndef store_commit(c, repo, user)\r\n      commits = db[:commits]\r\n      commit = commits.first(:sha => c['sha'])\r\n      if commit.nil?\r\n        author = commit_user(c['author'], c['commit']['author'])\r\n        commiter = commit_user(c['committer'], c['commit']['committer'])\r\n        repository = ensure_repo(user, repo)\r\n        if repository.nil?\r\n          warn \"Could not find repo #{user}\/#{repo} for storing commit #{c['sha']}\"\r\n        end\r\n        commits.insert(:sha => c['sha'],\r\n                       :author_id => author[:id],\r\n                       :committer_id => commiter[:id],\r\n                       :project_id => if repository.nil? then nil else repository[:id] end ,\r\n                       :created_at => date(c['commit']['author']['date'])\r\n        )\r\n        info \"Added commit #{user}\/#{repo} -> #{c['sha']} \"\r\n        commits.first(:sha => c['sha'])\r\n      else\r\n        debug \"Commit #{user}\/#{repo} -> #{c['sha']} exists\"\r\n        commit\r\n      end\r\n    end","code-length":290,"reference":"Store a commit contained in a hash. First check whether the commit exists.","result":"Store the commit.","score":[0.0173,0.0833]}
{"code":"# is used to<extra_id_0>\r\ndef log(level, msg)\r\n      case level\r\n        when :fatal then\r\n          loggerr.fatal (retrieve_caller + msg)\r\n        when :error then\r\n          loggerr.error (retrieve_caller + msg)\r\n        when :warn then\r\n          loggerr.warn  (retrieve_caller + msg)\r\n        when :info then\r\n          loggerr.info  (retrieve_caller + msg)\r\n        when :debug then\r\n          loggerr.debug (retrieve_caller + msg)\r\n        else\r\n          loggerr.debug (retrieve_caller + msg)\r\n      end\r\n    end","code-length":154,"reference":"Log a message at the given level.","result":"Log to the logger.","score":[0.1795,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef paged_api_request(url, pages = config(:mirror_history_pages_back),\r\n                          last = nil)\r\n      url = ensure_max_per_page(url)\r\n      data = api_request_raw(url)\r\n      return [] if data.nil?\r\n      unless data.meta['link'].nil?\r\n        links = parse_links(data.meta['link'])\r\n        last = links['last'] if last.nil?\r\n        if pages > 0\r\n          pages = pages - 1\r\n          if pages == 0\r\n            return parse_request_result(data)\r\n          end\r\n        end\r\n        if links['next'].nil?\r\n          parse_request_result(data)\r\n        else\r\n          parse_request_result(data) | paged_api_request(links['next'], pages, last)\r\n        end\r\n      else\r\n        parse_request_result(data)\r\n      end\r\n    end","code-length":238,"reference":"A paged request.","result":"Parse the API request.","score":[0.3195,0.1613]}
{"code":"# is used to<extra_id_0>\r\ndef last_updated(url, etag)\r\n      begin\r\n        ts = Time.now\r\n        response = do_request(url, '', etag)\r\n        info \"Successful etag request. URL: #{url}, Etag: #{etag}, Remaining: #{@remaining}, Total: #{Time.now.to_ms - ts.to_ms} ms\"\r\n      rescue OpenURI::HTTPError => e\r\n        response = e.io\r\n        if response.status.first != '304'\r\n          etag_request_error_message(url, e, etag)\r\n          raise e\r\n        end\r\n      end\r\n      return Time.parse(response.meta['last-modified']) unless response.meta['last-modified'].nil?\r\n      return Time.at(86400)\r\n    end","code-length":195,"reference":"Check whether the resource identified by the provided url has changed","result":"Determine the last_updated time of a resource.","score":[0.0912,0.0472]}
{"code":"# is used to<extra_id_0>\r\ndef num_pages(url)\r\n      url = ensure_max_per_page(url)\r\n      data = api_request_raw(url)\r\n      if data.nil? or data.meta.nil? or data.meta['link'].nil?\r\n        return 1\r\n      end\r\n      links = parse_links(data.meta['link'])\r\n      if links.nil? or links['last'].nil?\r\n        return 1\r\n      end\r\n      params = CGI::parse(URI::parse(links['last']).query)\r\n      params['page'][0].to_i\r\n    end","code-length":154,"reference":"Determine the number of pages contained in a multi-page API response","result":"Determine the number of pages.","score":[0.2265,0.3816]}
{"code":"# is used to<extra_id_0>\r\ndef parse_links(links)\r\n      links.split(\/,\/).reduce({}) do |acc, x|\r\n        matches = x.strip.match(\/<(.*)>; rel=\\\"(.*)\\\"\/)\r\n        acc[matches[2]] = matches[1]\r\n        acc\r\n      end\r\n    end","code-length":82,"reference":"Parse a Github link header","result":"Parse links.","score":[0.1116,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef parse_request_result(result)\r\n      if result.nil?\r\n        []\r\n      else\r\n        json = result.read\r\n        if json.nil?\r\n          []\r\n        else\r\n          r = JSON.parse(json)\r\n          if result.meta['etag'] and r.class != Array\r\n            r['etag'] = result.meta['etag']\r\n          end\r\n          r\r\n        end\r\n      end\r\n    end","code-length":119,"reference":"Parse the JSON result array","result":"Parse the request result.","score":[0.3519,0.3827]}
{"code":"# is used to<extra_id_0>\r\ndef api_request_raw(url, media_type = '')\r\n      begin\r\n        start_time = Time.now\r\n        contents = do_request(url, media_type)\r\n        total = Time.now.to_ms - start_time.to_ms\r\n        info \"Successful request. URL: #{url}, Remaining: #{@remaining}, Total: #{total} ms\"\r\n        contents\r\n      rescue OpenURI::HTTPError => e\r\n        @remaining = e.io.meta['x-ratelimit-remaining'].to_i\r\n        @reset = e.io.meta['x-ratelimit-reset'].to_i\r\n        case e.io.status[0].to_i\r\n          when 400,\r\n              403,\r\n              404,\r\n              409,\r\n              422 then\r\n            warn request_error_msg(url, e)\r\n            return nil\r\n          when 401\r\n            warn request_error_msg(url, e)\r\n            warn \"Unauthorised request with token: #{@token}\"\r\n            raise e\r\n          when 451\r\n            warn request_error_msg(url, e)\r\n            warn \"Repo was taken down (DMCA)\"\r\n            return nil\r\n          else\r\n            warn request_error_msg(url, e)\r\n            raise e\r\n        end\r\n      rescue StandardError => e\r\n        warn error_msg(url, e)\r\n        raise e\r\n      ensure\r\n        if @remaining < @req_limit\r\n          to_sleep = @reset - Time.now.to_i + 2\r\n          warn \"Request limit reached, reset in: #{to_sleep} secs\"\r\n          t = Thread.new do\r\n            slept = 0\r\n            while true do\r\n              debug \"Sleeping for #{to_sleep - slept} seconds\"\r\n              sleep 1\r\n              slept += 1\r\n            end\r\n          end\r\n          sleep([0, to_sleep].max)\r\n          t.exit\r\n        end\r\n      end\r\n    end","code-length":492,"reference":"Do the actual request and return the result object","result":"Make the request.","score":[0.0553,0.119]}
{"code":"# is used to<extra_id_0>\r\ndef attach_to(ip)\r\n      TCPSocket.instance_eval do\r\n        (class << self; self; end).instance_eval do\r\n          alias_method :original_open, :open\r\n          case RUBY_VERSION\r\n            when \/1.8\/, \/1.9\/\r\n              define_method(:open) do |conn_address, conn_port|\r\n                original_open(conn_address, conn_port, ip)\r\n              end\r\n            else\r\n              define_method(:open) do |conn_address, conn_port, local_host, local_port|\r\n                original_open(conn_address, conn_port, ip, local_port)\r\n              end\r\n          end\r\n        end\r\n      end\r\n      result = begin\r\n        yield\r\n      rescue StandardError => e\r\n        raise e\r\n      ensure\r\n        TCPSocket.instance_eval do\r\n          (class << self; self; end).instance_eval do\r\n            alias_method :open, :original_open\r\n            remove_method :original_open\r\n          end\r\n        end\r\n      end\r\n      result\r\n    end","code-length":282,"reference":"Attach to a specific IP address if the machine has multiple","result":"Attach a socket to a specific IP.","score":[0.2019,0.3538]}
{"code":"# is used to<extra_id_0>\r\ndef connect(adapter, settings)\r\n      driver = ADAPTERS[adapter.intern]\r\n      driver.new(settings)\r\n    end","code-length":44,"reference":"Factory method for retrieving persistence connections.","result":"Connect to the database.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef retrieve_commit(repo, sha, user)\r\n      commit = persister.find(:commits, {'sha' => \"#{sha}\"})\r\n      if commit.empty?\r\n        url = ghurl \"repos\/#{user}\/#{repo}\/commits\/#{sha}\"\r\n        c = api_request(url)\r\n        if c.nil? or c.empty?\r\n          return\r\n        end\r\n        if config(:commit_handling) == 'trim'\r\n          c['files'].each { |file| file.delete('patch') }\r\n        end\r\n        persister.store(:commits, c)\r\n        info \"Added commit #{user}\/#{repo} -> #{sha}\"\r\n        c\r\n      else\r\n        debug \"Commit #{user}\/#{repo} -> #{sha} exists\"\r\n        commit.first\r\n      end\r\n    end","code-length":200,"reference":"Retrieve a single commit from a repo","result":"Retrieve the commit for a given user.","score":[0.2125,0.2143]}
{"code":"# is used to<extra_id_0>\r\ndef retrieve_commits(repo, sha, user, pages = -1)\r\n      url = if sha.nil?\r\n              ghurl \"repos\/#{user}\/#{repo}\/commits\"\r\n            else\r\n              ghurl \"repos\/#{user}\/#{repo}\/commits?sha=#{sha}\"\r\n            end\r\n      commits = restricted_page_request(url, pages)\r\n      commits.map do |c|\r\n        retrieve_commit(repo, c['sha'], user)\r\n      end.select{|x| not x.nil?}\r\n    end","code-length":135,"reference":"Retrieve commits starting from the provided +sha+","result":"Retrieve commits.","score":[0.041,0.0769]}
{"code":"# is used to<extra_id_0>\r\ndef retrieve_orgs(user)\r\n      url = ghurl \"users\/#{user}\/orgs\"\r\n      orgs = paged_api_request(url)\r\n      orgs.map{|o| retrieve_org(o['login'])}\r\n    end","code-length":69,"reference":"Retrieve organizations the provided user participates into","result":"Escape the line.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef retrieve_watchers(user, repo)\r\n      repo_bound_items(user, repo, :watchers,\r\n                       [\"repos\/#{user}\/#{repo}\/stargazers\"],\r\n                       {'repo' => repo, 'owner' => user},\r\n                       'login', item = nil, refresh = false, order = :desc)\r\n    end","code-length":90,"reference":"Retrieve all watchers for a repository","result":"Retrieve the list of watchers.","score":[0.1967,0.0847]}
{"code":"# is used to<extra_id_0>\r\ndef retrieve_watcher(user, repo, watcher)\r\n      repo_bound_item(user, repo, watcher, :watchers,\r\n                      [\"repos\/#{user}\/#{repo}\/stargazers\"],\r\n                      {'repo' => repo, 'owner' => user},\r\n                      'login', order = :desc)\r\n    end","code-length":85,"reference":"Retrieve a single watcher for a repository","result":"Retrieve the watcher.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef get_repo_events(owner, repo)\r\n      url = ghurl(\"repos\/#{owner}\/#{repo}\/events\")\r\n      r = paged_api_request(url)\r\n      r.each do |e|\r\n        unless get_event(e['id']).empty?\r\n          debug \"Repository event #{owner}\/#{repo} -> #{e['type']}-#{e['id']} already exists\"\r\n        else\r\n          persister.store(:events, e)\r\n          info \"Added event for repository #{owner}\/#{repo} -> #{e['type']}-#{e['id']}\"\r\n        end\r\n      end\r\n      persister.find(:events, {'repo.name' => \"#{owner}\/#{repo}\"})\r\n    end","code-length":176,"reference":"Get all events for the specified repo.","result":"Get the list of events for a given repository.","score":[0.2049,0.4384]}
{"code":"# is used to<extra_id_0>\r\ndef retrieve_master_branch_diff(owner, repo, branch, parent_owner, parent_repo, parent_branch)\r\n      branch   = retrieve_default_branch(owner, repo) if branch.nil?\r\n      parent_branch = retrieve_default_branch(parent_owner, parent_repo) if parent_branch.nil?\r\n      return nil if branch.nil? or parent_branch.nil?\r\n      cmp_url = \"https:\/\/api.github.com\/repos\/#{parent_owner}\/#{parent_repo}\/compare\/#{parent_branch}...#{owner}:#{branch}\"\r\n      api_request(cmp_url)\r\n    end","code-length":156,"reference":"Retrieve diff between two branches.","result":"Retrieve the master branch diff.","score":[0.2403,0.1]}
{"code":"# is used to<extra_id_0>\r\ndef retrieve_default_branch(owner, repo, refresh = false)\r\n      retrieved = retrieve_repo(owner, repo, refresh)\r\n      return nil if retrieved.nil?\r\n      master_branch = 'master'\r\n      if retrieved['default_branch'].nil?\r\n        retrieved = retrieve_repo(owner, repo, true)\r\n        return nil if retrieved.nil?\r\n      end\r\n      master_branch = retrieved['default_branch'] unless retrieved.nil?\r\n      master_branch\r\n    end","code-length":128,"reference":"Retrieve the default branch for a repo. If nothing is retrieved, 'master' is returned","result":"Retrieve the default branch of a repo.","score":[0.2176,0.4428]}
{"code":"# is used to<extra_id_0>\r\ndef process_options\r\n      command = self\r\n      @options = Trollop::options(command.args) do\r\n        command.prepare_options(self)\r\n        banner <<-END\r\nStandard options:\r\n        END\r\n        opt :config, 'config.yaml file location', :short => 'c',\r\n            :default => 'config.yaml'\r\n        opt :verbose, 'verbose mode', :short => 'v'\r\n        opt :addr, 'IP address to use for performing requests', :short => 'a',\r\n            :type => String\r\n        opt :token, 'GitHub OAuth token',\r\n            :type => String, :short => 't'\r\n        opt :req_limit, 'Number or requests to leave on any provided account (in reqs\/hour)',\r\n            :type => Integer, :short => 'l'\r\n        opt :uniq, 'Unique name for this command. Will appear in logs.',\r\n            :type => String, :short => 'u'\r\n      end\r\n    end","code-length":248,"reference":"Specify and parse top-level command line options.","result":"Detect if a command is a command.","score":[0.1615,0.0714]}
{"code":"# is used to<extra_id_0>\r\ndef validate\r\n      if options[:config].nil?\r\n        unless (File.exist?(\"config.yaml\"))\r\n          Trollop::die \"No config file in default location (#{Dir.pwd}). You\r\n                        need to specify the #{:config} parameter. Read the\r\n                        documentation on how to create a config.yaml file.\"\r\n        end\r\n      else\r\n        Trollop::die \"Cannot find file #{options[:config]}\" \\\r\n          unless File.exist?(options[:config])\r\n      end\r\n      unless @options[:user].nil?\r\n        if not Process.uid == 0\r\n          Trollop::die \"Option --user (-u) can only be specified by root\"\r\n        end\r\n          begin\r\n            Etc.getpwnam(@options[:user])\r\n          rescue ArgumentError\r\n            Trollop::die \"No such user: #{@options[:user]}\"\r\n          end\r\n      end\r\n    end","code-length":234,"reference":"Examine the validity of the provided options in the context of the executed command.","result":"Validate the configuration.","score":[0.0104,0.0775]}
{"code":"# is used to<extra_id_0>\r\ndef queue_client(queue, key = queue, ack = :after, block)\r\n      stopped = false\r\n      while not stopped\r\n        begin\r\n          conn = Bunny.new(:host => config(:amqp_host),\r\n                           :port => config(:amqp_port),\r\n                           :username => config(:amqp_username),\r\n                           :password => config(:amqp_password))\r\n          conn.start\r\n          ch  = conn.create_channel\r\n          debug \"Queue setting prefetch to #{config(:amqp_prefetch)}\"\r\n          ch.prefetch(config(:amqp_prefetch))\r\n          debug \"Queue connection to #{config(:amqp_host)} succeeded\"\r\n          x = ch.topic(config(:amqp_exchange), :durable => true,\r\n                       :auto_delete => false)\r\n          q = ch.queue(queue, :durable => true)\r\n          q.bind(x, :routing_key => key)\r\n          q.subscribe(:block => true,\r\n                      :manual_ack => true) do |delivery_info, properties, msg|\r\n            if ack == :before\r\n              ch.acknowledge(delivery_info.delivery_tag)\r\n            end\r\n            begin\r\n              block.call(msg)\r\n            ensure\r\n              if ack != :before\r\n                ch.acknowledge(delivery_info.delivery_tag)\r\n              end\r\n            end\r\n          end\r\n        rescue Bunny::TCPConnectionFailed => e\r\n          warn \"Connection to #{config(:amqp_host)} failed. Retrying in 1 sec\"\r\n          sleep(1)\r\n        rescue Bunny::PossibleAuthenticationFailureError => e\r\n          warn \"Could not authenticate as #{conn.username}\"\r\n        rescue Bunny::NotFound, Bunny::AccessRefused, Bunny::PreconditionFailed => e\r\n          warn \"Channel error: #{e}. Retrying in 1 sec\"\r\n          sleep(1)\r\n        rescue Interrupt => _\r\n          stopped = true\r\n        rescue StandardError => e\r\n          raise e\r\n        end\r\n      end\r\n      ch.close unless ch.nil?\r\n      conn.close unless conn.nil?\r\n    end","code-length":530,"reference":"Specify a handler to incoming messages from a connection to a queue.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef read_value(from, key)\r\n      return from if key.nil? or key == \"\"\r\n      key.split(\/\\.\/).reduce({}) do |acc, x|\r\n        unless acc.nil?\r\n          if acc.empty?\r\n            acc = from[x]\r\n          else\r\n            if acc.has_key?(x)\r\n              acc = acc[x]\r\n            else\r\n              return nil\r\n            end\r\n          end\r\n        else\r\n          return nil\r\n        end\r\n      end\r\n    end","code-length":140,"reference":"map, where a dot represents one level deep in the hierarchy.","result":"Read a value from a hash.","score":[0.0839,0.0476]}
{"code":"# is used to<extra_id_0>\r\ndef location_filter(location)\r\n      return nil if location.nil?\r\n      location.\\\r\n        strip.\\\r\n        downcase.\\\r\n        tr('\r\n        gsub(\/^[0-9,\\\/().:]*\/, '').\\\r\n        gsub(\/ +\/, ' ').\\\r\n        gsub(\/,([a-z]*)\/, '\\1')\r\n    end","code-length":97,"reference":"Standard filtering on all locations used by GHTorrent","result":"Filter locations.","score":[0,0.0676]}
{"code":"# is used to<extra_id_0>\r\ndef validate_usage!\r\n      registered_topics = self.class.topics.map do |name, topic|\r\n        topic.to_h.merge!(\r\n          usage_count: messages_buffer[name]&.count || 0\r\n        )\r\n      end\r\n      used_topics = messages_buffer.map do |name, usage|\r\n        topic = self.class.topics[name] || Responders::Topic.new(name, registered: false)\r\n        topic.to_h.merge!(usage_count: usage.count)\r\n      end\r\n      result = Karafka::Schemas::ResponderUsage.call(\r\n        registered_topics: registered_topics,\r\n        used_topics: used_topics\r\n      )\r\n      return if result.success?\r\n      raise Karafka::Errors::InvalidResponderUsageError, result.errors\r\n    end","code-length":213,"reference":"Checks if we met all the topics requirements.","result":"Validate the usage of the responder.","score":[0.1383,0.0641]}
{"code":"# is used to<extra_id_0>\r\ndef validate_options!\r\n      return true unless self.class.options_schema\r\n      messages_buffer.each_value do |messages_set|\r\n        messages_set.each do |message_data|\r\n          result = self.class.options_schema.call(message_data.last)\r\n          next if result.success?\r\n          raise Karafka::Errors::InvalidResponderMessageOptionsError, result.errors\r\n        end\r\n      end\r\n    end","code-length":118,"reference":"Checks if we met all the options requirements before sending them to the producer.","result":"Validate options.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef deliver!\r\n      messages_buffer.each_value do |data_elements|\r\n        data_elements.each do |data, options|\r\n          mapped_topic = Karafka::App.config.topic_mapper.outgoing(options[:topic])\r\n          external_options = options.merge(topic: mapped_topic)\r\n          producer(options).call(data, external_options)\r\n        end\r\n      end\r\n    end","code-length":111,"reference":"Takes all the messages from the buffer and delivers them one by one ","result":"Deliver messages.","score":[0,0.042]}
{"code":"# is used to<extra_id_0>\r\ndef notice_signal(signal)\r\n      Thread.new do\r\n        Karafka.monitor.instrument('process.notice_signal', caller: self, signal: signal)\r\n      end\r\n    end","code-length":56,"reference":"Informs monitoring about trapped signal ","result":"Detect signals.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef embedding_lookup(params, ids, partition_strategy: \"mod\", name: nil, validate_indices: true, max_norm: nil)\r\n      _embedding_lookup_and_transform(params, ids, partition_strategy: partition_strategy, name: name, max_norm: max_norm, transform_fn: nil)\r\n    end","code-length":87,"reference":"Looks up `ids` in a list of embedding tensors.","result":"Perform the embedding lookup.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef _embedding_lookup_and_transform(params, ids, partition_strategy: \"mod\", name: nil, max_norm: nil, transform_fn: nil)\r\n      raise TensorStream::ValueError, \"Need at least one param\" if params.nil?\r\n      params = [params] unless params.is_a?(Array)\r\n      TensorStream.name_scope(name, \"embedding_lookup\", values: params + [ids]) do |name|\r\n        np = params.size\r\n        ids = TensorStream.convert_to_tensor(ids, name: \"ids\")\r\n        if (np == 1) && (transform_fn.nil? || (ids.shape.size == 1))\r\n          result = nil\r\n          TensorStream.colocate_with(params[0]) do\r\n            result = _clip(TensorStream.gather(params[0], ids, name: name), ids, max_norm)\r\n            result = transform_fn.call(result) if transform_fn\r\n          end\r\n          return TensorStream.identity(result)\r\n        else\r\n          flat_ids = TensorStream.reshape(ids, [-1])\r\n          original_indices = TensorStream.range(TensorStream.size(flat_ids))\r\n          p_assignments = nil\r\n          new_ids = nil\r\n          if partition_strategy == \"mod\"\r\n            p_assignments = flat_ids % np\r\n            new_ids = floor_div(flat_ids, np)\r\n          elsif partition_strategy == \"div\"\r\n            raise \"not yet supported!\"\r\n          else\r\n            raise TensorStream::ValueError, \"Unrecognized partition strategy: \" + partition_strategy\r\n          end\r\n          p_assignments = TensorStream.cast(p_assignments, :int32)\r\n          gather_ids = TensorStream.dynamic_partition(new_ids, p_assignments, np)\r\n          pindices = TensorStream.dynamic_partition(original_indices, p_assignments, np)\r\n          partitioned_result = []\r\n          (0...np).each do |p|\r\n            pids = gather_ids[p]\r\n            result = nil\r\n            TensorStream.colocate_with(params[p]) do\r\n              result = TensorStream.gather(params[p], pids)\r\n              if transform_fn\r\n                result = transform_fn.call(_clip(result, pids, max_norm))\r\n              end\r\n            end\r\n            partitioned_result << result\r\n          end\r\n          ret = TensorStream.dynamic_stitch(pindices, partitioned_result, name: name)\r\n          if transform_fn.nil?\r\n            element_shape_s = params[0].shape[1..-1]\r\n            params[1..-1].each { |p| element_shape_s = element_shape_s.merge_with(p.shape[1..-1]) }\r\n          else\r\n            element_shape_s = ret.shape[1..-1]\r\n          end\r\n          element_shape_d = if element_shape_s.fully_defined?\r\n                               element_shape_s\r\n                            elsif transform_fn.nil?\r\n                              TensorStream.colocate_with(params[0]) do\r\n                                params_shape = TensorStream.shape(params[0])\r\n                                params_shape[1..-1]\r\n                              end\r\n                            else\r\n                              TensorStream.shape(ret)[1..-1]\r\n                            end\r\n          ret = TensorStream.reshape(ret, TensorStream.concat([TensorStream.shape(ids), element_shape_d], 0))\r\n          ret = _clip(ret, ids, max_norm) unless transform_fn\r\n          ret\r\n        end\r\n      end\r\n    end","code-length":891,"reference":"Helper function for embedding_lookup and _compute_sampled_logits.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef load(pbfile)\r\n      f = File.new(pbfile, \"r\")\r\n      lines = []\r\n      while !f.eof? && (str = f.readline.strip)\r\n        lines << str\r\n      end\r\n      evaluate_lines(lines)\r\n    end","code-length":79,"reference":"parsers a protobuf file and spits out a ruby hash","result":"Load a pbfile.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef assert_equal(x, y, data: nil, summarize: nil, message: nil, name: nil)\r\n      _op(:assert_equal, x, y, data: data, summarize: summarize, message: message, name: name)\r\n    end","code-length":68,"reference":"Assert the condition x == y holds element-wise.","result":"Assert equality.","score":[0.0249,0.0676]}
{"code":"# is used to<extra_id_0>\r\ndef gradients(tensor_ys, wrt_xs, name: \"gradients\", stop_gradients: nil)\r\n      tensor_ys = tensor_ys.op\r\n      gs = wrt_xs.map(&:op).collect { |x|\r\n        stops = stop_gradients ? stop_gradients.map(&:name).join(\"_\") : \"\"\r\n        gradient_program_name = \"grad_#{tensor_ys.name}_#{x.name}_#{stops}\".to_sym\r\n        tensor_graph = tensor_ys.graph\r\n        tensor_program = if tensor_graph.node_added?(gradient_program_name)\r\n          tensor_graph.get_node(gradient_program_name)\r\n        else\r\n          tensor_graph.name_scope(\"gradient_wrt_#{x.name}\") do\r\n            derivative_ops = TensorStream::MathGradients.derivative(tensor_ys, x, graph: tensor_graph,\r\n                                                                                  stop_gradients: stop_gradients)\r\n            tensor_graph.add_node!(gradient_program_name, derivative_ops)\r\n          end\r\n        end\r\n        tensor_program\r\n      }\r\n      gs\r\n    end","code-length":292,"reference":"ys and xs are each a Tensor or a list of tensors.","result":"Compute gradients.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef random_normal(shape, dtype: :float32, mean: 0.0, stddev: 1.0, seed: nil, name: nil)\r\n      options = {dtype: dtype, mean: mean, stddev: stddev, seed: seed, name: name}\r\n      _op(:random_standard_normal, shape, options)\r\n    end","code-length":88,"reference":"Outputs random values from a normal distribution.","result":"Initialize random_standard_normal.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef eye(num_rows, num_columns: nil, dtype: :float32, name: nil)\r\n      _op(:eye, num_rows, num_columns || num_rows, data_type: dtype, name: name)\r\n    end","code-length":67,"reference":"Construct an identity matrix","result":"Create the eye function.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef glorot_uniform_initializer(seed: nil, dtype: nil)\r\n      TensorStream::Initializer.new(-> { _op(:glorot_uniform, seed: seed, data_type: dtype) })\r\n    end","code-length":63,"reference":"The Glorot uniform initializer, also called Xavier uniform initializer.","result":"Initialize uniform distribution.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef random_uniform_initializer(minval: 0, maxval: 1, seed: nil, dtype: nil)\r\n      TensorStream::Initializer.new(-> { _op(:random_uniform, minval: 0, maxval: 1, seed: seed, data_type: dtype) })\r\n    end","code-length":77,"reference":"Initializer that generates tensors with a uniform distribution.","result":"Initialize random_uniform_initializer.","score":[0,0.0676]}
{"code":"# is used to<extra_id_0>\r\ndef slice(input, start, size, name: nil)\r\n      _op(:slice, input, start, size: size, name: name)\r\n    end","code-length":46,"reference":"Extracts a slice from a tensor.","result":"Slice an array.","score":[0,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef ones(shape, dtype: :float32, name: nil)\r\n      _op(:ones, shape, data_type: dtype, name: name)\r\n    end","code-length":48,"reference":"Creates a tensor with all elements set to 1.","result":"Create the array.","score":[0,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef logical_and(input_a, input_b, name: nil)\r\n      check_data_types(input_a, input_b)\r\n      _op(:logical_and, input_a, input_b, name: name)\r\n    end","code-length":69,"reference":"Returns the truth value of x AND y element-wise.","result":"Define the op.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef reduce_mean(input_tensor, axis = nil, keepdims: false, name: nil)\r\n      reduce(:mean, input_tensor, axis, keepdims: keepdims, name: name)\r\n    end","code-length":58,"reference":"Computes the mean of elements across dimensions of a tensor.","result":"Reduce the mean of a tensor.","score":[0.2917,0.5042]}
{"code":"# is used to<extra_id_0>\r\ndef concat(values, axis, name: \"concat\")\r\n      if values.is_a?(Array)\r\n        _op(:concat, axis, *values, name: name)\r\n      else\r\n        _op(:concat, axis, values, name: name)\r\n      end\r\n    end","code-length":79,"reference":"Concatenates tensors along one dimension.","result":"Concatenate arrays.","score":[0,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef dynamic_partition(data, partitions, num_partitions, name: nil)\r\n      result = _op(:dynamic_partition, data, partitions, num_partitions: num_partitions, name: nil)\r\n      num_partitions.times.map do |index|\r\n        result[index]\r\n      end\r\n    end","code-length":83,"reference":"Partitions data into num_partitions tensors using indices from partitions","result":"Create dynamic partitions.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef where(condition, true_t = nil, false_t = nil, name: nil)\r\n      _op(:where, condition, true_t, false_t, name: name)\r\n    end","code-length":56,"reference":"Return the elements, either from x or y, depending on the condition.","result":"Define the where statement.","score":[0.0432,0.0446]}
{"code":"# is used to<extra_id_0>\r\ndef asin(input, name: nil)\r\n      check_allowed_types(input, FLOATING_POINT_TYPES)\r\n      _op(:asin, input, name: name)\r\n    end","code-length":56,"reference":"Computes asin of input element-wise","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef acos(input, name: nil)\r\n      check_allowed_types(input, FLOATING_POINT_TYPES)\r\n      _op(:acos, input, name: name)\r\n    end","code-length":56,"reference":"Computes acos of input element-wise","result":"Calculate the acos.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef atan(input, name: nil)\r\n      check_allowed_types(input, FLOATING_POINT_TYPES)\r\n      _op(:atan, input, name: name)\r\n    end","code-length":55,"reference":"Computes atan of input element-wise","result":"Define the operator.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef cast(input, dtype, name: nil)\r\n      input = convert_to_tensor(input)\r\n      return input if input.data_type == dtype\r\n      _op(:cast, input, data_type: dtype, name: name)\r\n    end","code-length":70,"reference":"Casts a tensor to a new type, if needed","result":"Cast tensor.","score":[0,0.0602]}
{"code":"# is used to<extra_id_0>\r\ndef print(input, data, message: nil, name: nil)\r\n      _op(:print, input, data, message: message, name: name)\r\n    end","code-length":48,"reference":"Prints a list of tensors.","result":"Print the input.","score":[0,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef sec(input, name: nil)\r\n      check_allowed_types(input, FLOATING_POINT_TYPES)\r\n      _op(:sec, input, name: name)\r\n    end","code-length":54,"reference":"Computes sec of input element-wise.","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef sqrt(input, name: nil)\r\n      check_allowed_types(input, FLOATING_POINT_TYPES)\r\n      _op(:sqrt, input, name: name)\r\n    end","code-length":54,"reference":"Computes sqrt of input element-wise.","result":"Calculate the square root of the input.","score":[0.1615,0.0962]}
{"code":"# is used to<extra_id_0>\r\ndef log(input, name: nil)\r\n      check_allowed_types(input, FLOATING_POINT_TYPES)\r\n      _op(:log, input, name: name)\r\n    end","code-length":54,"reference":"Computes natural logarithm of x element-wise.","result":"Define the log method.","score":[0,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef exp(input, name: nil)\r\n      check_allowed_types(input, FLOATING_POINT_TYPES)\r\n      _op(:exp, input, name: name)\r\n    end","code-length":54,"reference":"Computes exponential of x element-wise.","result":"Evaluate the expression.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef pad(tensor, paddings, mode: \"CONSTANT\", name: nil)\r\n      _op(:pad, tensor, paddings, mode: mode, name: name)\r\n    end","code-length":53,"reference":"Pads a tensor.","result":"Pad a tensor.","score":[0.5774,0.9815]}
{"code":"# is used to<extra_id_0>\r\ndef gather(params, indices, validate_indices: nil,\r\n      name: nil,\r\n      axis: 0)\r\n      _op(:gather, params, indices, validate_indices: validate_indices, name: name, axis: axis)\r\n    end","code-length":69,"reference":"Gather slices from params and axis according to indices.","result":"Gather data.","score":[0.0151,0.0602]}
{"code":"# is used to<extra_id_0>\r\ndef pack(values, axis: 0, name: \"pack\")\r\n      _op(:stack, *values, axis: axis, name: name)\r\n    end","code-length":46,"reference":"Same as stack","result":"Pack the values.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef unpack(value, num: nil, axis: 0, name: \"unpack\")\r\n      unstack(value, num: num, axis: axis, name: name)\r\n    end","code-length":51,"reference":"Same as unstack","result":"Unpack a value.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef case(args = {})\r\n      args = args.dup\r\n      default = args.delete(:default)\r\n      exclusive = args.delete(:exclusive)\r\n      strict = args.delete(:strict)\r\n      name = args.delete(:name)\r\n      predicates = []\r\n      functions = []\r\n      args.each do |k, v|\r\n        raise \"Invalid argment or option #{k}\" unless k.is_a?(Tensor)\r\n        predicates << k\r\n        functions << (v.is_a?(Proc) ? v.call : v)\r\n      end\r\n      _op(:case, predicates, default, *functions, exclusive: exclusive, strict: strict, name: name)\r\n    end","code-length":178,"reference":"Create a case operation.","result":"Define the case operator.","score":[0.3195,0.125]}
{"code":"# is used to<extra_id_0>\r\ndef i_op(code, *args)\r\n      options = if args.last.is_a?(Hash)\r\n        args.pop\r\n      else\r\n        {}\r\n      end\r\n      args << options.merge(internal: true)\r\n      Graph.get_default_graph.add_op!(code.to_sym, *args)\r\n    end","code-length":96,"reference":"same as op but with a marker that it was internal generated","result":"Define the op.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef broadcast_dimensions(input, dims = [])\r\n      return input if dims.empty?\r\n      d = dims.shift\r\n      if input.is_a?(Array) && (get_rank(input) - 1) == dims.size\r\n        row_to_dup = input.collect { |item|\r\n          broadcast_dimensions(item, dims.dup)\r\n        }\r\n        row_to_dup + Array.new(d) { row_to_dup }.flatten(1)\r\n      elsif input.is_a?(Array)\r\n        Array.new(d) { broadcast_dimensions(input, dims.dup) }\r\n      else\r\n        Array.new(d + 1) { input }\r\n      end\r\n    end","code-length":186,"reference":"explicit broadcasting helper","result":"Broadcast arrays.","score":[0,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef vector_op(vector, vector2, switch = false, safe = true, &block)\r\n      if get_rank(vector) < get_rank(vector2)\r\n        duplicated = Array.new(vector2.size) {\r\n          vector\r\n        }\r\n        return vector_op(duplicated, vector2, switch, &block)\r\n      end\r\n      return yield(vector, vector2) unless vector.is_a?(Array)\r\n      vector.each_with_index.collect { |input, index|\r\n        next vector_op(input, vector2, switch, &block) if input.is_a?(Array) && get_rank(vector) > get_rank(vector2)\r\n        if safe && vector2.is_a?(Array)\r\n          next nil if vector2.size != 1 && index >= vector2.size\r\n        end\r\n        z = if vector2.is_a?(Array)\r\n          if index < vector2.size\r\n            vector2[index]\r\n          else\r\n            raise \"incompatible tensor shapes used during op\" if vector2.size != 1\r\n            vector2[0]\r\n          end\r\n        else\r\n          vector2\r\n        end\r\n        if input.is_a?(Array)\r\n          vector_op(input, z, switch, &block)\r\n        else\r\n          switch ? yield(z, input) : yield(input, z)\r\n        end\r\n      }.compact\r\n    end","code-length":363,"reference":"handle 2 tensor math operations","result":"Perform the operation on a vector.","score":[0,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef transpose_with_perm(arr, new_arr, shape, new_shape, perm)\r\n      arr_size = shape.reduce(:*)\r\n      divisors = shape.dup.drop(1).reverse.inject([1]) { |a, s|\r\n        a << s * a.last\r\n      }.reverse\r\n      multipliers = new_shape.dup.drop(1).reverse.inject([1]) { |a, s|\r\n        a << s * a.last\r\n      }.reverse\r\n      arr_size.times do |p|\r\n        ptr = p\r\n        index = []\r\n        divisors.each_with_object(index) do |div, a|\r\n          a << (ptr \/ div.to_f).floor\r\n          ptr = ptr % div\r\n        end\r\n        remaped = perm.map { |x| index[x] }\r\n        ptr2 = 0\r\n        multipliers.each_with_index do |m, idx|\r\n          ptr2 += remaped[idx] * m\r\n        end\r\n        new_arr[ptr2] = arr[p]\r\n      end\r\n      [new_arr, new_shape]\r\n    end","code-length":298,"reference":"general case transposition with flat arrays","result":"Transpose a 2d array.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add(input_a, input_b, name: nil)\r\n      input_a, input_b = apply_data_type_coercion(input_a, input_b)\r\n      _op(:add, input_a, input_b, name: name)\r\n    end","code-length":77,"reference":"Returns x + y element-wise.","result":"Create a new object.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef argmax(input_a, axis = nil, name: nil, dimension: nil, output_type: :int32)\r\n      check_allowed_types(input_a, TensorStream::Ops::NUMERIC_TYPES)\r\n      check_allowed_types(axis, TensorStream::Ops::INTEGER_TYPES)\r\n      _op(:argmax, input_a, axis, name: name, dimension: dimension, output_type: output_type)\r\n    end","code-length":113,"reference":"Returns the index with the largest value across axes of a tensor.","result":"Compute the argmax of a numeric array.","score":[0.1237,0.2222]}
{"code":"# is used to<extra_id_0>\r\ndef ceil(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:ceil, input_a, name: name)\r\n    end","code-length":66,"reference":"Returns element-wise smallest integer in not less than x ","result":"Compute the ceil operator.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef cos(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:cos, input_a, name: name)\r\n    end","code-length":65,"reference":"Computes cos of input element-wise.","result":"Evaluate the cos operator.","score":[0.2488,0.102]}
{"code":"# is used to<extra_id_0>\r\ndef floor(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:floor, input_a, name: name)\r\n    end","code-length":66,"reference":"Returns element-wise largest integer not greater than x.","result":"Store the input.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef mod(input_a, input_b, name: nil)\r\n      input_a, input_b = apply_data_type_coercion(input_a, input_b)\r\n      _op(:mod, input_a, input_b, name: name)\r\n    end","code-length":77,"reference":"Returns element-wise remainder of division.","result":"Calculate the mod.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef pow(input_a, input_b, name: nil)\r\n      input_a, input_b = apply_data_type_coercion(input_a, input_b)\r\n      _op(:pow, input_a, input_b, name: name)\r\n    end","code-length":77,"reference":"Computes the power of one value to another X^Y element wise","result":"Define the operator.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef prod(input_a, axis = nil, name: nil, keepdims: false)\r\n      check_allowed_types(axis, TensorStream::Ops::INTEGER_TYPES)\r\n      input_a = TensorStream.convert_to_tensor(input_a)\r\n      return input_a if input_a.shape.scalar?\r\n      axis = cast_axis(input_a, axis)\r\n      _op(:prod, input_a, axis, name: name, keepdims: keepdims)\r\n    end","code-length":128,"reference":"Computes the product of elements across dimensions of a tensor.","result":"Create a new function.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef random_uniform(shape, name: nil, dtype: :float32, minval: 0, maxval: 1, seed: nil)\r\n      _op(:random_uniform, shape, name: name, dtype: dtype, minval: minval, maxval: maxval, seed: seed)\r\n    end","code-length":77,"reference":"Outputs random values from a uniform distribution.","result":"Create random uniform distribution.","score":[0.2362,0.3814]}
{"code":"# is used to<extra_id_0>\r\ndef range(start = 0, limit = 0, delta = 1, name: \"range\", dtype: nil, output_type: :int32)\r\n      _op(:range, start, limit, delta, name: name, dtype: dtype, output_type: output_type)\r\n    end","code-length":75,"reference":"Creates a sequence of numbers.","result":"Define the range operator.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef rank(input, name: nil)\r\n      input = convert_to_tensor(input)\r\n      return cons(input.shape.ndims) if input.shape.known?\r\n      _op(:rank, input, name: name)\r\n    end","code-length":69,"reference":"Returns the rank of a tensor ","result":"Define the rank op.","score":[0.274,0.3233]}
{"code":"# is used to<extra_id_0>\r\ndef round(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:round, input_a, name: name)\r\n    end","code-length":65,"reference":"Rounds the values of a tensor to the nearest integer, element-wise ","result":"Compute the round function.","score":[0.0555,0.0971]}
{"code":"# is used to<extra_id_0>\r\ndef rsqrt(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:rsqrt, input_a, name: name)\r\n    end","code-length":69,"reference":"Computes reciprocal of square root of x element-wise.","result":"Evaluate the operator.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef shape(input, name: nil, out_type: :int32)\r\n      return constant(shape_eval(input, out_type), dtype: out_type, name: \"Shape\/#{name}\") if input.is_a?(Array) && !input[0].is_a?(Tensor)\r\n      return constant(input.shape.shape, dtype: out_type, name: \"Shape\/#{input.name}_c\") if shape_full_specified(input)\r\n      _op(:shape, input, name: name, out_type: out_type)\r\n    end","code-length":143,"reference":"This operation returns a 1-D integer tensor representing the shape of input ","result":"Evaluate shape operations.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef sigmoid(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:sigmoid, input_a, name: name)\r\n    end","code-length":67,"reference":"Computes sigmoid of x element-wise.","result":"Compute the sigmoid function.","score":[0.2488,0.2041]}
{"code":"# is used to<extra_id_0>\r\ndef sin(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:sin, input_a, name: name)\r\n    end","code-length":65,"reference":"Computes sin of input element-wise.","result":"Create the TensorStream.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef sub(input_a, input_b, name: nil)\r\n      input_a, input_b = apply_data_type_coercion(input_a, input_b)\r\n      _op(:sub, input_a, input_b, name: name)\r\n    end","code-length":77,"reference":"Returns x - y element-wise.","result":"Evaluate the sub operator.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef sum(input_a, axis_p = nil, axis: nil, name: nil, keepdims: false)\r\n      check_allowed_types(axis_p, TensorStream::Ops::INTEGER_TYPES)\r\n      input_a = TensorStream.convert_to_tensor(input_a)\r\n      return input_a if input_a.shape.scalar?\r\n      axis_p = axis_p || axis\r\n      axis_p = cast_axis(input_a, axis_p)\r\n      _op(:sum, input_a, axis_p, name: name, keepdims: keepdims)\r\n    end","code-length":154,"reference":"Computes the sum of elements across dimensions of a tensor.","result":"Sum the dimensions of an array.","score":[0.1551,0.3288]}
{"code":"# is used to<extra_id_0>\r\ndef tan(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:tan, input_a, name: name)\r\n    end","code-length":66,"reference":"Computes tan of input element-wise.","result":"Define the variables that.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef tanh(input_a, name: nil)\r\n      check_allowed_types(input_a, TensorStream::Ops::FLOATING_POINT_TYPES)\r\n      _op(:tanh, input_a, name: name)\r\n    end","code-length":68,"reference":"Computes tanh of input element-wise.","result":"Define the variables that.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef top_k(input, k = 1, sorted: true, name: nil)\r\n      result = _op(:top_k, input, k, sorted: sorted, name: name)\r\n      [result[0], result[1]]\r\n    end","code-length":68,"reference":"Finds values and indices of the `k` largest entries for the last dimension.","result":"Return the top k values.","score":[0.0485,0.041]}
{"code":"# is used to<extra_id_0>\r\ndef zeros(shape, dtype: :float32, name: nil)\r\n      _op(:zeros, shape, dtype: dtype, name: name)\r\n    end","code-length":46,"reference":"Creates a tensor with all elements set to zero ","result":"Create the array.","score":[0,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef convert(session, checkpoint_folder, output_file)\r\n      model_file = File.join(checkpoint_folder, \"model.yaml\")\r\n      TensorStream.graph.as_default do |current_graph|\r\n        YamlLoader.new.load_from_string(File.read(model_file))\r\n        saver = TensorStream::Train::Saver.new\r\n        saver.restore(session, checkpoint_folder)\r\n        remove_nodes = Set.new(current_graph.nodes.values.select { |op| op.is_a?(TensorStream::Operation) && op.operation == :assign }.map { |op| op.consumers.to_a }.flatten.uniq)\r\n        output_buffer = TensorStream::Yaml.new.get_string(current_graph) { |graph, node_key|\r\n          node = graph.get_tensor_by_name(node_key)\r\n          case node.operation\r\n          when :variable_v2\r\n            value = node.container\r\n            options = {\r\n              value: value,\r\n              data_type: node.data_type,\r\n              shape: shape_eval(value),\r\n            }\r\n            const_op = TensorStream::Operation.new(current_graph, inputs: [], options: options)\r\n            const_op.name = node.name\r\n            const_op.operation = :const\r\n            const_op.data_type = node.data_type\r\n            const_op.shape = TensorShape.new(shape_eval(value))\r\n            const_op\r\n          when :assign\r\n            nil\r\n          else\r\n            remove_nodes.include?(node.name) ? nil : node\r\n          end\r\n        }\r\n        File.write(output_file, output_buffer)\r\n      end\r\n    end","code-length":442,"reference":"Utility class to convert variables to constants for production deployment","result":"Convert TensorStream to TensorFlow.","score":[0.0713,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef device(device_name)\r\n      Thread.current[\"ts_graph_#{object_id}\"] ||= {}\r\n      Thread.current[\"ts_graph_#{object_id}\"][:default_device] ||= []\r\n      Thread.current[\"ts_graph_#{object_id}\"][:default_device] << device_name\r\n      begin\r\n        yield\r\n      ensure\r\n        Thread.current[\"ts_graph_#{object_id}\"][:default_device].pop\r\n      end\r\n    end","code-length":124,"reference":"Returns a context manager that specifies the default device to use.","result":"Set the default device.","score":[0.0785,0.182]}
{"code":"# is used to<extra_id_0>\r\ndef load_from_string(buffer)\r\n      serialized_ops = YAML.safe_load(buffer, [Symbol], [], true)\r\n      serialized_ops.each do |op_def|\r\n        inputs = op_def[:inputs].map { |i| @graph.get_tensor_by_name(i) }\r\n        options = {}\r\n        new_var = nil\r\n        if op_def.dig(:attrs, :container)\r\n          new_var = Variable.new(op_def.dig(:attrs, :data_type))\r\n          var_shape = op_def.dig(:attrs, :container, :shape)\r\n          var_options = op_def.dig(:attrs, :container, :options)\r\n          var_options[:name] = op_def[:name]\r\n          new_var.prepare(var_shape.size, var_shape, TensorStream.get_variable_scope, var_options)\r\n          options[:container] = new_var\r\n          @graph.add_variable(new_var, var_options)\r\n        end\r\n        new_op = Operation.new(@graph, inputs: inputs, options: op_def[:attrs].merge(options))\r\n        new_op.operation = op_def[:op].to_sym\r\n        new_op.name = op_def[:name]\r\n        new_op.shape = TensorShape.new(TensorStream::InferShape.infer_shape(new_op))\r\n        new_op.rank = new_op.shape.rank\r\n        new_op.data_type = new_op.set_data_type(op_def.dig(:attrs, :data_type))\r\n        new_op.is_const = new_op.infer_const\r\n        new_op.given_name = new_op.name\r\n        new_var.op = new_op if new_var\r\n        @graph.add_node(new_op)\r\n      end\r\n      @graph\r\n    end","code-length":478,"reference":"Loads a model Yaml file and builds the model from it","result":"Load operations from a YAML file.","score":[0.0998,0.1905]}
{"code":"# is used to<extra_id_0>\r\ndef variable(value, name: nil, initializer: nil, graph: nil, dtype: nil, trainable: true)\r\n      op = Graph.get_default_graph.add_op(:assign, nil, value)\r\n      common_options = {\r\n        initializer: initializer || op,\r\n        name: name,\r\n        graph: graph,\r\n        dtype: dtype,\r\n        trainable: trainable,\r\n      }\r\n      tensor = if value.is_a?(String)\r\n        i_var(dtype || :string, 0, [], get_variable_scope, common_options)\r\n      elsif value.is_a?(Integer)\r\n        i_var(dtype || :int32, 0, [], get_variable_scope, common_options)\r\n      elsif value.is_a?(Float)\r\n        i_var(dtype || :float32, 0, [], get_variable_scope, common_options)\r\n      else\r\n        i_var(dtype || :float32, 0, nil, get_variable_scope, common_options)\r\n      end\r\n      op.set_input(0, tensor.op)\r\n      Graph.get_default_graph.add_node(op)\r\n      tensor\r\n    end","code-length":302,"reference":"Creates a variable","result":"Define a variable.","score":[0.4082,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef variable_scope(scope = nil, default_name = nil, reuse: nil, initializer: nil)\r\n      Thread.current[:tensor_stream_variable_scope] ||= [VariableScope.new]\r\n      if scope.nil? && default_name\r\n        same_names = get_variable_scope.used_names.select { |s| s.start_with?(default_name) }\r\n        new_name = default_name\r\n        index = 1\r\n        while same_names.include?(new_name)\r\n          new_name = \"#{default_name}_#{index}\"\r\n          index += 1\r\n        end\r\n        scope = new_name\r\n      end\r\n      variable_scope = VariableScope.new(name: scope, reuse: reuse, initializer: initializer)\r\n      get_variable_scope.register_name(scope || \"\")\r\n      Thread.current[:tensor_stream_variable_scope] << variable_scope\r\n      scope_name = __v_scope_name\r\n      if block_given?\r\n        begin\r\n          TensorStream.get_default_graph.name_scope(scope) do\r\n            yield(scope_name)\r\n          end\r\n        ensure\r\n          Thread.current[:tensor_stream_variable_scope].pop\r\n        end\r\n      else\r\n        variable_scope\r\n      end\r\n    end","code-length":327,"reference":"Defines a variable context manager","result":"Define the variable scope.","score":[0.2488,0.2041]}
{"code":"# is used to<extra_id_0>\r\ndef session(evaluator = nil, thread_pool_class: Concurrent::ImmediateExecutor, log_device_placement: false, profile_enabled: false)\r\n      session = TensorStream::Session.new(evaluator, thread_pool_class: thread_pool_class, log_device_placement: log_device_placement, profile_enabled: profile_enabled)\r\n      yield session if block_given?\r\n      session\r\n    end","code-length":107,"reference":"Creates a session context where operations can be executed","result":"Initialize the session.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef placeholder(dtype, shape: nil, name: nil)\r\n      TensorStream::Placeholder.new(dtype, nil, shape, name: name)\r\n    end","code-length":46,"reference":"Inserts a placeholder for a tensor that will be always fed.","result":"Create placeholder tensors.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef check_if_dense(value, expected_shape = nil)\r\n      return unless value.is_a?(Array)\r\n      return if value.empty?\r\n      expected_shape ||= shape_eval(value)\r\n      s = expected_shape.shift\r\n      raise TensorStream::ValueError, \"Argument must be a dense tensor: #{value}, expected size #{s} got #{value.size}\" if value.size != s\r\n      return if expected_shape.empty?\r\n      value.each do |item|\r\n        check_if_dense(item, expected_shape.dup)\r\n      end\r\n    end","code-length":153,"reference":"Check to make sure passed array is dense","result":"Check if a dense tensor is a dense tensor.","score":[0.1604,0.1852]}
{"code":"# is used to<extra_id_0>\r\ndef apply_data_type_coercion(*args)\r\n      coerced_type = check_data_types(*args)\r\n      args.map { |a| a.is_a?(Tensor) ? a : convert_to_tensor(a, dtype: coerced_type) }\r\n    end","code-length":80,"reference":"Auto cast ruby constant data types to the same tensor types of other operands","result":"Coercion data types.","score":[0.0104,0.0388]}
{"code":"# is used to<extra_id_0>\r\ndef add_audio(customization_id:, audio_name:, audio_resource:, contained_content_type: nil, allow_overwrite: nil, content_type: nil)\r\n      raise ArgumentError.new(\"customization_id must be provided\") if customization_id.nil?\r\n      raise ArgumentError.new(\"audio_name must be provided\") if audio_name.nil?\r\n      raise ArgumentError.new(\"audio_resource must be provided\") if audio_resource.nil?\r\n      headers = {\r\n        \"Contained-Content-Type\" => contained_content_type,\r\n        \"Content-Type\" => content_type\r\n      }\r\n      sdk_headers = Common.new.get_sdk_headers(\"speech_to_text\", \"V1\", \"add_audio\")\r\n      headers.merge!(sdk_headers)\r\n      params = {\r\n        \"allow_overwrite\" => allow_overwrite\r\n      }\r\n      data = audio_resource\r\n      method_url = \"\/v1\/acoustic_customizations\/%s\/audio\/%s\" % [ERB::Util.url_encode(customization_id), ERB::Util.url_encode(audio_name)]\r\n      request(\r\n        method: \"POST\",\r\n        url: method_url,\r\n        headers: headers,\r\n        params: params,\r\n        data: data,\r\n        accept_json: true\r\n      )\r\n      nil\r\n    end","code-length":349,"reference":"Custom audio resources","result":"Create a new audio resource.","score":[0.2403,0.1562]}
{"code":"# is used to<extra_id_0>\r\ndef create_event(type:, data:)\r\n      raise ArgumentError.new(\"type must be provided\") if type.nil?\r\n      raise ArgumentError.new(\"data must be provided\") if data.nil?\r\n      headers = {\r\n      }\r\n      sdk_headers = Common.new.get_sdk_headers(\"discovery\", \"V1\", \"create_event\")\r\n      headers.merge!(sdk_headers)\r\n      params = {\r\n        \"version\" => @version\r\n      }\r\n      data = {\r\n        \"type\" => type,\r\n        \"data\" => data\r\n      }\r\n      method_url = \"\/v1\/events\"\r\n      response = request(\r\n        method: \"POST\",\r\n        url: method_url,\r\n        headers: headers,\r\n        params: params,\r\n        json: data,\r\n        accept_json: true\r\n      )\r\n      response\r\n    end","code-length":230,"reference":"Events and feedback","result":"Create an event.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef zero_pad(n, message)\r\n      len = message.bytesize\r\n      if len == n\r\n        message\r\n      elsif len > n\r\n        raise LengthError, \"String too long for zero-padding to #{n} bytes\"\r\n      else\r\n        message + zeros(n - len)\r\n      end\r\n    end","code-length":89,"reference":"Pad a string out to n characters with zeros ","result":"Zero-pad strings.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef check_length(string, length, description)\r\n      if string.nil?\r\nLengthError,\r\n              \"#{description} was nil (Expected #{length.to_int})\",\r\n              caller\r\n      end\r\n      if string.bytesize != length.to_int\r\n        raise LengthError,\r\n              \"#{description} was #{string.bytesize} bytes (Expected #{length.to_int})\",\r\n              caller\r\n      end\r\n      true\r\n    end","code-length":120,"reference":"Check the length of the passed in string","result":"Check the length of a string.","score":[0.433,0.4046]}
{"code":"# is used to<extra_id_0>\r\ndef check_string(string, length, description)\r\n      check_string_validation(string)\r\n      string = string.to_s\r\n      check_length(string, length, description)\r\n      string\r\n    end","code-length":62,"reference":"Check a passed in string, converting the argument if necessary","result":"Check string validation.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef check_hmac_key(string, _description)\r\n      check_string_validation(string)\r\n      string = string.to_str\r\n      if string.bytesize.zero?\r\n        raise LengthError,\r\n              \"#{Description} was #{string.bytesize} bytes (Expected more than 0)\",\r\n              caller\r\n      end\r\n      string\r\n    end","code-length":97,"reference":"Check a passed in string, convertion if necessary","result":"Validate the HMAC key.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef check_string_validation(string)\r\n      raise TypeError, \"can't convert #{string.class} into String with\r\n      string = string.to_str\r\n      raise EncodingError, \"strings must use BINARY encoding (got #{string.encoding})\" if string.encoding != Encoding::BINARY\r\n    end","code-length":78,"reference":"Check a passed string is it valid","result":"Validate the string.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef auth(message)\r\n      authenticator = Util.zeros(tag_bytes)\r\n      message = message.to_str\r\n      compute_authenticator(authenticator, message)\r\n      authenticator\r\n    end","code-length":58,"reference":"Compute authenticator for message ","result":"Escape the line.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef verify(authenticator, message)\r\n      auth = authenticator.to_s\r\n      Util.check_length(auth, tag_bytes, \"Provided authenticator\")\r\n      verify_message(auth, message) || raise(BadAuthenticatorError, \"Invalid authenticator provided, message is corrupt\")\r\n    end","code-length":77,"reference":"Verifies the given authenticator with the message.","result":"Verify the message.","score":[0.1522,0.3872]}
{"code":"# is used to<extra_id_0>\r\ndef box(message)\r\n      nonce = generate_nonce\r\n      cipher_text = @box.box(nonce, message)\r\n      nonce + cipher_text\r\n    end","code-length":50,"reference":"Encrypts the message with a random nonce","result":"Escape the message.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef open(enciphered_message)\r\n      nonce, ciphertext = extract_nonce(enciphered_message.to_s)\r\n      @box.open(nonce, ciphertext)\r\n    end","code-length":55,"reference":"Decrypts the ciphertext with a random nonce","result":"Identify the box.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef reopen\r\n      each do |appender|\r\n        begin\r\n          next unless appender.respond_to?(:reopen)\r\n          logger.trace \"Reopening appender: #{appender.name}\"\r\n          appender.reopen\r\n        rescue Exception => exc\r\n          logger.error \"Failed to re-open appender: #{appender.inspect}\", exc\r\n        end\r\n      end\r\n      logger.trace 'All appenders re-opened'\r\n    end","code-length":119,"reference":"After a fork the appender thread is not running, start it if it is not running.","result":"Re-open all appenders.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef logger\r\n      @logger ||= begin\r\n        logger      = SemanticLogger::Processor.logger.clone\r\n        logger.name = self.class.name\r\n        logger\r\n      end\r\n    end","code-length":56,"reference":"Give each appender its own logger for logging.","result":"Format the error message.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef measure(level, message, params = {}, &block)\r\n      index = Levels.index(level)\r\n      if level_index <= index\r\n        measure_internal(level, index, message, params, &block)\r\n      elsif block\r\n        yield(params)\r\n      end\r\n    end","code-length":81,"reference":"Dynamically supply the log level with every measurement call","result":"Measure the message.","score":[0.0553,0.119]}
{"code":"# is used to<extra_id_0>\r\ndef backtrace(thread: Thread.current,\r\n                  level: :warn,\r\n                  message: 'Backtrace:',\r\n                  payload: nil,\r\n                  metric: nil,\r\n                  metric_amount: nil)\r\n      log = Log.new(name, level)\r\n      return false unless meets_log_level?(log)\r\n      backtrace =\r\n        if thread == Thread.current\r\n          Utils.extract_backtrace\r\n        else\r\n          log.thread_name = thread.name\r\n          log.tags        = (thread[:semantic_logger_tags] || []).clone\r\n          log.named_tags  = (thread[:semantic_logger_named_tags] || {}).clone\r\n          thread.backtrace\r\n        end\r\n      if backtrace\r\n        message += \"\\n\"\r\n        message << backtrace.join(\"\\n\")\r\n      end\r\n      if log.assign(message:       message,\r\n                    backtrace:     backtrace,\r\n                    payload:       payload,\r\n                    metric:        metric,\r\n                    metric_amount: metric_amount) && !filtered?(log)\r\n        self.log(log)\r\n      else\r\n        false\r\n      end\r\n    end","code-length":292,"reference":"Log a thread backtrace","result":"Capture backtrace.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef tagged(*tags, &block)\r\n      if tags.size == 1\r\n        tag = tags[0]\r\n        return yield if tag.nil? || tag == ''\r\n        return tag.is_a?(Hash) ? SemanticLogger.named_tagged(tag, &block) : SemanticLogger.fast_tag(tag.to_s, &block)\r\n      end\r\n      new_tags = tags.flatten.collect(&:to_s).reject(&:empty?)\r\n      SemanticLogger.tagged(*new_tags, &block)\r\n    end","code-length":140,"reference":"Add the tags or named tags to the list of tags to log for this thread whilst the supplied block is active.","result":"Create a new instance of the class.","score":[0.0225,0.0488]}
{"code":"# is used to<extra_id_0>\r\ndef push_tags(*tags)\r\n      new_tags = tags.flatten.collect(&:to_s).reject(&:empty?)\r\n      SemanticLogger.push_tags(*new_tags)\r\n    end","code-length":59,"reference":"Returns the list of tags pushed after flattening them out and removing blanks","result":"Push tags to the logger.","score":[0.0577,0.123]}
{"code":"# is used to<extra_id_0>\r\ndef filtered?(log)\r\n      return false if @filter.nil?\r\n      @filter.is_a?(Regexp) ? (@filter =~ log.name).nil? : @filter.call(log) != true\r\n    end","code-length":64,"reference":"Whether to log the supplied message based on the current filter if any","result":"Filter logs.","score":[0,0.042]}
{"code":"# is used to<extra_id_0>\r\ndef log_internal(level, index, message = nil, payload = nil, exception = nil, &block)\r\n      log        = Log.new(name, level, index)\r\n      should_log =\r\n        if payload.nil? && exception.nil? && message.is_a?(Hash)\r\n          if message.key?(:message) || message.key?(:payload) || message.key?(:exception) || message.key?(:metric)\r\n            log.assign(message)\r\n          else\r\n            log.assign_positional(nil, message, nil, &block)\r\n          end\r\n        else\r\n          log.assign_positional(message, payload, exception, &block)\r\n        end\r\n      self.log(log) if should_log && should_log?(log)\r\n    end","code-length":202,"reference":"Log message at the specified level","result":"Log the message.","score":[0.1786,0.1754]}
{"code":"# is used to<extra_id_0>\r\ndef measure_internal(level, index, message, params)\r\n      exception = nil\r\n      result    = nil\r\n      if params.empty? && message.is_a?(Hash)\r\n        params  = message\r\n        message = nil\r\n      end\r\n      start = Process.clock_gettime(Process::CLOCK_MONOTONIC)\r\n      begin\r\n        if block_given?\r\n          result =\r\n            if (silence_level = params[:silence])\r\n              silence_level = :error if silence_level == true\r\n              silence(silence_level) { yield(params) }\r\n            else\r\n              yield(params)\r\n            end\r\n        end\r\n      rescue Exception => exc\r\n        exception = exc\r\n      ensure\r\n        log       = Log.new(name, level, index)\r\n        exception ||= params[:exception]\r\n        message   = params[:message] if params[:message]\r\n        duration  =\r\n          if block_given?\r\n            1_000.0 * (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start)\r\n          else\r\n            params[:duration] || raise('Mandatory block missing when :duration option is not supplied')\r\n          end\r\n        payload = params[:payload]\r\n        should_log = log.assign(\r\n          message:            message,\r\n          payload:            payload,\r\n          min_duration:       params[:min_duration] || 0.0,\r\n          exception:          exception,\r\n          metric:             params[:metric],\r\n          metric_amount:      params[:metric_amount],\r\n          duration:           duration,\r\n          log_exception:      params[:log_exception] || :partial,\r\n          on_exception_level: params[:on_exception_level]\r\n        )\r\n        self.log(log) if should_log && should_log?(log)\r\n        raise exception if exception\r\n        result\r\n      end\r\n    end","code-length":479,"reference":"Measure the supplied block and log the message","result":"Measure the log level.","score":[0.1839,0.1974]}
{"code":"# is used to<extra_id_0>\r\ndef measure_method(index:,\r\n                       level:,\r\n                       message:,\r\n                       min_duration:,\r\n                       metric:,\r\n                       log_exception:,\r\n                       on_exception_level:)\r\n      exception = nil\r\n      start     = Process.clock_gettime(Process::CLOCK_MONOTONIC)\r\n      begin\r\n        yield\r\n      rescue Exception => exc\r\n        exception = exc\r\n      ensure\r\n        log = Log.new(name, level, index)\r\n        should_log = log.assign(\r\n          message:            message,\r\n          min_duration:       min_duration,\r\n          exception:          exception,\r\n          metric:             metric,\r\n          duration:           1_000.0 * (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start),\r\n          log_exception:      log_exception,\r\n          on_exception_level: on_exception_level\r\n        )\r\n        log(log) if should_log && should_log?(log)\r\n        raise exception if exception\r\n      end\r\n    end","code-length":274,"reference":"For measuring methods and logging their duration.","result":"Measure the value of a method.","score":[0,0.0725]}
{"code":"# is used to<extra_id_0>\r\ndef log(log, message = nil, progname = nil, &block)\r\n      return add(log, message, progname, &block) unless log.is_a?(SemanticLogger::Log)\r\n      Logger.call_subscribers(log)\r\n      Logger.processor.log(log)\r\n    end","code-length":83,"reference":"Returns a Logger instance","result":"Add a log message to the logger.","score":[0.1615,0.1163]}
{"code":"# is used to<extra_id_0>\r\ndef assign(message: nil,\r\n               payload: nil,\r\n               min_duration: 0.0,\r\n               exception: nil,\r\n               metric: nil,\r\n               metric_amount: nil,\r\n               duration: nil,\r\n               backtrace: nil,\r\n               log_exception: :full,\r\n               on_exception_level: nil,\r\n               dimensions: nil)\r\n      if duration\r\n        self.duration = duration\r\n        return false if (duration < min_duration) && exception.nil?\r\n      end\r\n      self.message = message\r\n      if payload && payload.is_a?(Hash)\r\n        self.payload = payload\r\n      elsif payload\r\n        self.message = message.nil? ? payload.to_s : \"#{message} -- #{payload}\"\r\n        self.payload = nil\r\n      end\r\n      if exception\r\n        case log_exception\r\n        when :full\r\n          self.exception = exception\r\n        when :partial\r\n          self.message = \"#{message} -- Exception: #{exception.class}: #{exception.message}\"\r\n        when nil, :none\r\n          nil\r\n        else\r\n          raise(ArgumentError, \"Invalid value:#{log_exception.inspect} for argument :log_exception\")\r\n        end\r\n        if on_exception_level\r\n          self.level       = on_exception_level\r\n          self.level_index = Levels.index(level)\r\n        end\r\n      end\r\n      if backtrace\r\n        self.backtrace = Utils.extract_backtrace(backtrace)\r\n      elsif level_index >= SemanticLogger.backtrace_level_index\r\n        self.backtrace = Utils.extract_backtrace\r\n      end\r\n      if metric\r\n        self.metric        = metric\r\n        self.metric_amount = metric_amount\r\n        self.dimensions    = dimensions\r\n      end\r\n      true\r\n    end","code-length":453,"reference":"Assign named arguments to this log entry, supplying defaults where applicable","result":"Assign the logger to the logger instance.","score":[0.1085,0.0943]}
{"code":"# is used to<extra_id_0>\r\ndef assign_positional(message = nil, payload = nil, exception = nil)\r\n      if exception.nil? && payload.nil? && message.respond_to?(:backtrace) && message.respond_to?(:message)\r\n        exception = message\r\n        message   = nil\r\n      elsif exception.nil? && payload && payload.respond_to?(:backtrace) && payload.respond_to?(:message)\r\n        exception = payload\r\n        payload   = nil\r\n      elsif payload && !payload.is_a?(Hash)\r\n        message = message.nil? ? payload : \"#{message} -- #{payload}\"\r\n        payload = nil\r\n      end\r\n      if block_given? && (result = yield)\r\n        if result.is_a?(String)\r\n          message = message.nil? ? result : \"#{message} -- #{result}\"\r\n          assign(message: message, payload: payload, exception: exception)\r\n        elsif message.nil? && result.is_a?(Hash) && %i[message payload exception].any? { |k| result.key? k }\r\n          assign(result)\r\n        elsif payload&.respond_to?(:merge)\r\n          assign(message: message, payload: payload.merge(result), exception: exception)\r\n        else\r\n          assign(message: message, payload: result, exception: exception)\r\n        end\r\n      else\r\n        assign(message: message, payload: payload, exception: exception)\r\n      end\r\n    end","code-length":358,"reference":"Assign positional arguments to this log entry, supplying defaults where applicable","result":"Set the message and payload of the exception.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef each_exception\r\n   depth      = 0\r\n      exceptions = []\r\n      ex         = exception\r\n      while !ex.nil? && !exceptions.include?(ex) && exceptions.length < MAX_EXCEPTIONS_TO_UNWRAP\r\n        exceptions << ex\r\n        yield(ex, depth)\r\n        depth += 1\r\n        ex    =\r\n          if ex.respond_to?(:cause) && ex.cause\r\n            ex.cause\r\n          elsif ex.respond_to?(:continued_exception) && ex.continued_exception\r\n            ex.continued_exception\r\n          elsif ex.respond_to?(:original_exception) && ex.original_exception\r\n            ex.original_exception\r\n          end\r\n      end\r\n    end","code-length":191,"reference":"Call the block for exception and any nested exception","result":"Iterate over all exceptions.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef extract_file_and_line(stack, short_name = false)\r\n      match = CALLER_REGEXP.match(stack.first)\r\n      [short_name ? File.basename(match[1]) : match[1], match[2].to_i]\r\n    end","code-length":75,"reference":"Extract the filename and line number from the last entry in the supplied backtrace","result":"Extract file and line number.","score":[0.0622,0.1951]}
{"code":"# is used to<extra_id_0>\r\ndef message_for(corrections)\r\n      return \"\" if corrections.empty?\r\n      output = \"\\n\\n    Did you mean? \".dup\r\n      output << corrections.join(\"\\n                  \")\r\n      output << \"\\n \"\r\n    end","code-length":69,"reference":"Returns a human readable string that contains +corrections+.","result":"Generate the message.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef gather_vars(executor, tconf, message)\r\n      return nil if (tconf.keys & %w[ include_vars exclude_vars ]).empty?\r\n      iv = expand_filter(tconf['include_vars'])\r\n      return nil if iv == false\r\n      ev = expand_filter(tconf['exclude_vars'])\r\n      return {} if ev == true\r\n      vars = executor.vars(message['nid'])\r\n      return vars if iv == true\r\n      vars = vars.select { |k, v| var_match(k, iv) } if iv\r\n      vars = vars.reject { |k, v| var_match(k, ev) } if ev\r\n      vars\r\n    end","code-length":176,"reference":"By default, taskers don't see the flor variables in the execution.","result":"Gather variables.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef do_run\r\n      @unit.logger.log_run_start(self)\r\n      counter_next('runs')\r\n      t0 = Time.now\r\n      (@unit.conf['exe_max_messages'] || 77).times do |i|\r\n        break if @shutdown\r\n        m = @messages.shift\r\n        break unless m\r\n        m = (@messages << m).shift \\\r\n          if m['point'] == 'terminated' && @messages.any?\r\n        ms = process(m)\r\n        @consumed << m\r\n        ims, oms = ms.partition { |mm| mm['exid'] == @exid }\r\n        counter_add('omsgs', oms.size)\r\n        @messages.concat(ims)\r\n        @unit.storage.put_messages(oms)\r\n      end\r\n      @alive = false\r\n      @execution.merge!(\r\n        closing_messages: @consumed.select { |m|\r\n          CLOSING_POINTS.include?(m['point']) })\r\n      @unit.storage.put_execution(@execution)\r\n      @unit.storage.consume(@consumed)\r\n      @unit.storage.put_messages(@messages)\r\n      du = Time.now - t0\r\n      t0 = Flor.tstamp(t0)\r\n      @unit.logger.log_run_end(self, t0, du)\r\n      @unit.hooker.notify(self, make_end_message(t0, du, @execution['size']))\r\n      @consumed.clear\r\n    rescue Exception => exc\r\n      fn =\r\n        [\r\n          'flor',\r\n          @unit.conf['env'], @unit.identifier, @exid,\r\n          'r' + counter('runs').to_s\r\n        ].collect(&:to_s).join('_') + '.dump'\r\n      @unit.logger.error(\r\n        \"#{self.class}\r\n      File.open(fn, 'wb') do |f|\r\n        f.puts(Flor.to_pretty_s({\r\n          execution: @execution,\r\n          messages: @messages,\r\n          consumed: @consumed,\r\n          traps: @traps.collect(&:to_h),\r\n          exid: @exid,\r\n          alive: @alive,\r\n          shutdown: @shutdown,\r\n          thread: [ @thread.object_id, @thread.to_s ]\r\n        }))\r\n        f.puts('-' * 80)\r\n        f.puts(on_do_run_exc(exc))\r\n      end\r\n    end","code-length":637,"reference":"point for messages that, after consumption, are conserved in the execution's \"closing_messages\" array","result":"Code too long,keep in 512.","score":[0.0485,0.041]}
{"code":"# is used to<extra_id_0>\r\ndef route(name)\r\n      if name.is_a?(String)\r\n        [ Flor.dup_and_merge(\r\n            @message,\r\n            'tasker' => name, 'original_tasker' => @message['tasker'],\r\n            'routed' => true) ]\r\n      else\r\n        [ Flor.dup_and_merge(\r\n            @message,\r\n            'routed' => !! name) ]\r\n      end\r\n    end","code-length":124,"reference":"For domain taskers","result":"Route the message.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef row_waiter?\r\n      @serie.find { |_, points|\r\n        points.find { |po|\r\n          pos = po.split(':')\r\n          pos.length > 1 && ROW_PSEUDO_POINTS.include?(pos[0]) } }\r\n    end","code-length":82,"reference":"\"tasker\", not \"task\", since \"task\" is already a message point","result":"Wait for row waiter.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef node(reload=false)\r\n      nid = @values[:nid]; return nil unless nid\r\n      exe = execution(reload); return nil unless exe\r\n      nodes = exe.data['nodes']; return nil unless nodes\r\n      nodes[nid]\r\n    end","code-length":70,"reference":"Returns the node hash linked to this model","result":"Define the node.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef vars(nid, vs={})\r\n      n = node(nid); return vs unless n\r\n      (n['vars'] || {})\r\n        .each { |k, v| vs[k] = Flor.dup(v) unless vs.has_key?(k) }\r\n      pnid = n['parent']\r\n      if @unit.loader && pnid == nil && n['vdomain'] != false\r\n        @unit.loader.variables(n['vdomain'] || Flor.domain(@exid))\r\n          .each { |k, v| vs[k] = Flor.dup(v) unless vs.has_key?(k) }\r\n      end\r\n      if cn = n['cnid']; vars(cn, vs); end\r\n      vars(pnid, vs) if pnid\r\n      vs\r\n    end","code-length":208,"reference":"Given a nid, returns a copy of all the var the node sees at that point.","result":"Define variables in the node.","score":[0.0266,0.0336]}
{"code":"# is used to<extra_id_0>\r\ndef lookup_on_error_parent(message)\r\n      nd = Flor::Node.new(self, nil, message).on_error_parent\r\n      nd ? nd.to_procedure_node : nil\r\n    end","code-length":62,"reference":"Return an empty array of new messages.","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef decrement\r\n      c = data['count']\r\n      return false unless c\r\n      c = c - 1\r\n      data['count'] = c\r\n      self[:status] = s = (c > 0) ? 'active' : 'consumed'\r\n      self.update(\r\n        content: Flor::Storage.to_blob(@flor_model_cache_data),\r\n        status: s)\r\n      c < 1\r\n    end","code-length":114,"reference":"returns true if the trap should be removed from the execution's list of traps","result":"Decrement the count.","score":[0.0104,0.0388]}
{"code":"# is used to<extra_id_0>\r\ndef work\r\n      queue, job = lock_job\r\n      if queue && job\r\n        QC.log_yield(:at => \"work\", :job => job[:id]) do\r\n          process(queue, job)\r\n        end\r\n      end\r\n    end","code-length":72,"reference":"Blocks on locking a job, and once a job is locked, it will process the job.","result":"Define the work method.","score":[0.0159,0.0676]}
{"code":"# is used to<extra_id_0>\r\ndef lock_job\r\n      log(:at => \"lock_job\")\r\n      job = nil\r\n      while @running\r\n        @queues.each do |queue|\r\n          if job = queue.lock\r\n            return [queue, job]\r\n          end\r\n        end\r\n        @conn_adapter.wait(@wait_interval, *@queues.map {|q| q.name})\r\n      end\r\n    end","code-length":109,"reference":"Attempt to lock a job in the queue's table.","result":"Lock jobs.","score":[0,0.0602]}
{"code":"# is used to<extra_id_0>\r\ndef call(job)\r\n      args = job[:args]\r\n      receiver_str, _, message = job[:method].rpartition('.')\r\n      receiver = eval(receiver_str)\r\n      receiver.send(message, *args)\r\n    end","code-length":70,"reference":"Each job includes a method column.","result":"Call methods.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(meth, opts = {})\r\n      if meth.to_s == 'to_ary'\r\n        super\r\n      end\r\n      if meth.to_s.end_with? '!'\r\n        deep_merge_options meth[0..-2].to_sym, opts\r\n      else\r\n        merge_options meth, opts\r\n      end\r\n    end","code-length":99,"reference":"Pass other methods through to the javascript high_chart object.","result":"Define the method_missing method.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef remove_params(params)\r\n      self.tap do |u|\r\n        u.query_values = (u.query_values || {}).tap do |qv|\r\n          params.each do |key, value|\r\n            qv.delete key\r\n          end\r\n        end\r\n        if u.query_values.empty?\r\n          u.query_values = nil\r\n        end\r\n      end\r\n    end","code-length":112,"reference":"params can be an array or a hash","result":"Remove params from the query string.","score":[0.1383,0.0641]}
{"code":"# is used to<extra_id_0>\r\ndef parse_user_info(node)\r\n      return nil if node.nil?\r\n      {}.tap do |hash|\r\n        node.children.each do |e|\r\n          unless e.kind_of?(Nokogiri::XML::Text) || e.name == 'proxies'\r\n            if e.element_children.count == 0\r\n              if hash.has_key?(e.name)\r\n                hash[e.name] = [hash[e.name]] if hash[e.name].is_a? String\r\n                hash[e.name] << e.content\r\n              else\r\n                hash[e.name] = e.content\r\n              end\r\n            elsif e.element_children.count\r\n              if e.name == 'attributes'\r\n                hash.merge!(parse_user_info(e))\r\n              else\r\n                hash[e.name] = [] if hash[e.name].nil?\r\n                hash[e.name] = [hash[e.name]] if hash[e.name].is_a? String\r\n                hash[e.name].push(parse_user_info(e))\r\n              end\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end","code-length":303,"reference":"initially borrowed from omniauth-cas","result":"Parse user info.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef run_async(command)\r\n      raise 'Async command already in progress' if @started\r\n      @started = false\r\n      @user_method.reset\r\n      session.open_channel do |channel|\r\n        channel.request_pty\r\n        channel.on_data do |ch, data|\r\n          publish_data(data, 'stdout') unless @user_method.filter_password?(data)\r\n          @user_method.on_data(data, ch)\r\n        end\r\n        channel.on_extended_data { |ch, type, data| publish_data(data, 'stderr') }\r\n        channel.on_request('exit-status') { |ch, data| publish_exit_status(data.read_long) }\r\n        channel.on_request('exit-signal') do |ch, data|\r\n          publish_exit_status(data.read_string)\r\n          ch.close\r\n          ch.wait\r\n        end\r\n        channel.exec(command) do |_, success|\r\n          @started = true\r\n          raise('Error initializing command') unless success\r\n        end\r\n      end\r\n      session.process(0) { !run_started? }\r\n      return true\r\n    end","code-length":301,"reference":"Initiates run of the remote command and yields the data when available.","result":"Run a command asynchronously.","score":[0.0432,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef exit_code\r\n      fail_chance   = ENV.fetch('REX_SIMULATE_FAIL_CHANCE', 0).to_i\r\n      fail_exitcode = ENV.fetch('REX_SIMULATE_EXIT', 0).to_i\r\n      if fail_exitcode == 0 || fail_chance < (Random.rand * 100).round\r\n        0\r\n      else\r\n        fail_exitcode\r\n      end\r\n    end","code-length":118,"reference":"Decide if the execution should fail or not","result":"Generate the exit code.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef import_method(source, name, new_name = name)\r\n      from = name.to_sym\r\n      to   = new_name.to_sym\r\n      fn = source.is_a?(Registry) ? source.fetch(from) : source.method(from)\r\n      self.class.new(methods.merge(to => fn))\r\n    end","code-length":96,"reference":"Creates new immutable collection from the current one, updated with either the module's singleton method, or the proc having been imported from another module.","result":"Import a method.","score":[0,0.0228]}
{"code":"# is used to<extra_id_0>\r\ndef import_methods(source, names)\r\n      names.inject(self) { |a, e| a.import_method(source, e) }\r\n    end","code-length":48,"reference":"Creates new immutable collection from the current one, updated with either the module's singleton methods, or the procs having been imported from another module.","result":"Import methods.","score":[0,0.0229]}
{"code":"# is used to<extra_id_0>\r\ndef import_all(source)\r\n      names = source.public_methods - Registry.instance_methods - Module.methods\r\n      names -= [:initialize]\r\n      names += source.store.methods.keys if source.is_a? Registry\r\n      import_methods(source, names)\r\n    end","code-length":80,"reference":"Creates new immutable collection from the current one, updated with all singleton methods and imported methods from the other module ","result":"Import all modules.","score":[0.0014,0.0546]}
{"code":"# is used to<extra_id_0>\r\ndef [](fn, *args)\r\n      fetched = fetch(fn)\r\n      return Function.new(fetched, args: args, name: fn) unless already_wrapped?(fetched)\r\n      args.empty? ? fetched : fetched.with(*args)\r\n    end","code-length":74,"reference":"Builds the transformation ","result":"Wrap functions.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef fetch(fn)\r\n      return fn unless fn.instance_of? Symbol\r\n      respond_to?(fn) ? method(fn) : store.fetch(fn)\r\n    rescue\r\n      raise FunctionNotFoundError.new(fn, self)\r\n    end","code-length":70,"reference":"Gets the procedure for creating a transproc","result":"Define the method.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef to_ast\r\n      args_ast = args.map { |arg| arg.respond_to?(:to_ast) ? arg.to_ast : arg }\r\n      [name, args_ast]\r\n    end","code-length":61,"reference":"Return a simple AST representation of this function ","result":"Create a AST.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef to_proc\r\n      if args.size > 0\r\n        proc { |*value| fn.call(*value, *args) }\r\n      else\r\n        fn.to_proc\r\n      end\r\n    end","code-length":61,"reference":"Converts a transproc to a simple proc ","result":"Create a new instance.","score":[0.1509,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef from_pattern_match(keys, pattern, match)\r\n      keys.each_with_index.map do |key, idx|\r\n        if pattern[key]\r\n          interpolate(pattern[key], match)\r\n        else\r\n          match[idx + 1]\r\n        end\r\n      end\r\n    end","code-length":84,"reference":"Maps replacement keys to their values","result":"Create a new instance of the class.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef interpolate(replacement, match)\r\n      group_idx = replacement.index('$')\r\n      return replacement if group_idx.nil?\r\n      group_nbr = replacement[group_idx + 1]\r\n      replacement.sub(\"$#{group_nbr}\", match[group_nbr.to_i])\r\n    end","code-length":87,"reference":"Interpolates a string with data from matches if specified","result":"Interpolate the string.","score":[0,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef before(*commands, &block)\r\n      context = (@_context[:before] ||= [])\r\n      block_given? ? run_context(context, &block) : context.concat(commands)\r\n    end","code-length":60,"reference":"Run commands prior to each tab context.","result":"Define the before block.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef window(*args, &block)\r\n      key            = \"window#{@_windows.keys.size}\"\r\n      options        = args.extract_options!\r\n      options[:name] = args.first unless args.empty?\r\n      context = (@_windows[key] = window_hash.merge(:options => options))\r\n      run_context context, &block\r\n    end","code-length":98,"reference":"Run commands in the conext of a window.","result":"Create a window.","score":[0.109,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef tab(*args, &block)\r\n      tabs = @_context[:tabs]\r\n      key  = \"tab#{tabs.keys.size}\"\r\n      return (tabs[key] = { :commands => args }) unless block_given?\r\n      context           = (tabs[key] = {:commands => []})\r\n      options           = args.extract_options!\r\n      options[:name]    = args.first unless args.empty?\r\n      context[:options] = options\r\n      run_context context, &block\r\n      @_context = @_windows[@_windows.keys.last]\r\n    end","code-length":149,"reference":"Run commands in the context of a tab.","result":"Create tabs.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef run(*commands)\r\n      context = case\r\n                when @_context.is_a?(Hash) && @_context[:tabs]\r\n                  @_context[:tabs]['default'][:commands]\r\n                when @_context.is_a?(Hash)\r\n                  @_context[:commands]\r\n                else\r\n                  @_context\r\n                end\r\n      context << commands.map { |c| c =~ \/&$\/ ? \"(#{c})\" : c }.join(\" && \")\r\n    end","code-length":122,"reference":"Store commands to run in context.","result":"No valid comments generated.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef set_write(policy, operation, key, bins)\r\n      begin_cmd\r\n      field_count = estimate_key_size(key, policy)\r\n      bins.each do |bin|\r\n        estimate_operation_size_for_bin(bin)\r\n      end\r\n      size_buffer\r\n      write_header_with_policy(policy, 0, INFO2_WRITE, field_count, bins.length)\r\n      write_key(key, policy)\r\n      bins.each do |bin|\r\n        write_operation_for_bin(bin, operation)\r\n      end\r\n      end_cmd\r\n    end","code-length":158,"reference":"Writes the command for write operations","result":"Set the write policy for a key.","score":[0.2125,0.2459]}
{"code":"# is used to<extra_id_0>\r\ndef set_delete(policy, key)\r\n      begin_cmd\r\n      field_count = estimate_key_size(key)\r\n      size_buffer\r\n      write_header_with_policy(policy, 0, INFO2_WRITE|INFO2_DELETE, field_count, 0)\r\n      write_key(key)\r\n      end_cmd\r\n    end","code-length":95,"reference":"Writes the command for delete operations","result":"Set delete on a policy.","score":[0.1967,0.0847]}
{"code":"# is used to<extra_id_0>\r\ndef set_touch(policy, key)\r\n      begin_cmd\r\n      field_count = estimate_key_size(key)\r\n      estimate_operation_size\r\n      size_buffer\r\n      write_header_with_policy(policy, 0, INFO2_WRITE, field_count, 1)\r\n      write_key(key)\r\n      write_operation_for_operation_type(Aerospike::Operation::TOUCH)\r\n      end_cmd\r\n    end","code-length":122,"reference":"Writes the command for touch operations","result":"Set the touch value.","score":[0.2304,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef set_exists(policy, key)\r\n      begin_cmd\r\n      field_count = estimate_key_size(key)\r\n      size_buffer\r\n      write_header(policy, INFO1_READ|INFO1_NOBINDATA, 0, field_count, 0)\r\n      write_key(key)\r\n      end_cmd\r\n    end","code-length":93,"reference":"Writes the command for exist operations","result":"Set the existence of a key.","score":[0.193,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef set_read_header(policy, key)\r\n      begin_cmd\r\n      field_count = estimate_key_size(key)\r\n      estimate_operation_size_for_bin_name('')\r\n      size_buffer\r\n      write_header(policy, INFO1_READ, 0, field_count, 1)\r\n      write_key(key)\r\n      write_operation_for_bin_name('', Aerospike::Operation::READ)\r\n      end_cmd\r\n    end","code-length":127,"reference":"Writes the command for getting metadata operations","result":"Set the read header.","score":[0.1509,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef set_operate(policy, key, operations)\r\n      begin_cmd\r\n      field_count = estimate_key_size(key, policy)\r\n      read_attr = 0\r\n      write_attr = 0\r\n      read_header = false\r\n      operations.each do |operation|\r\n        case operation.op_type\r\n        when Aerospike::Operation::READ\r\n            read_attr |= INFO1_READ\r\n          read_attr |= INFO1_GET_ALL unless operation.bin_name\r\n        when Aerospike::Operation::READ_HEADER\r\n            read_attr |= INFO1_READ\r\n          read_header = true\r\n        else\r\n          write_attr = INFO2_WRITE\r\n        end\r\n        estimate_operation_size_for_operation(operation)\r\n      end\r\n      size_buffer\r\n      if write_attr != 0\r\n        write_header_with_policy(policy, read_attr, write_attr, field_count, operations.length)\r\n      else\r\n        write_header(policy, read_attr, write_attr, field_count, operations.length)\r\n      end\r\n      write_key(key, policy)\r\n      operations.each do |operation|\r\n        write_operation_for_operation(operation)\r\n      end\r\n      write_operation_for_bin(nil, Aerospike::Operation::READ) if read_header\r\n      end_cmd\r\n    end","code-length":351,"reference":"Implements different command operations","result":"Set the value of a key.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef write_header(policy, read_attr, write_attr, field_count, operation_count)\r\n      read_attr |= INFO1_CONSISTENCY_ALL if policy.consistency_level == Aerospike::ConsistencyLevel::CONSISTENCY_ALL\r\n      @data_buffer.write_byte(MSG_REMAINING_HEADER_SIZE, 8)\r\n      @data_buffer.write_byte(read_attr, 9)\r\n      @data_buffer.write_byte(write_attr, 10)\r\n      i = 11\r\n      while i <= 25\r\n        @data_buffer.write_byte(0, i)\r\n        i = i.succ\r\n      end\r\n      @data_buffer.write_int16(field_count, 26)\r\n      @data_buffer.write_int16(operation_count, 28)\r\n      @data_offset = MSG_TOTAL_HEADER_SIZE\r\n    end","code-length":226,"reference":"Generic header write.","result":"Write the header.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef write_header_with_policy(policy, read_attr, write_attr, field_count, operation_count)\r\n      generation = Integer(0)\r\n      info_attr = Integer(0)\r\n      case policy.record_exists_action\r\n      when Aerospike::RecordExistsAction::UPDATE\r\n      when Aerospike::RecordExistsAction::UPDATE_ONLY\r\n        info_attr |= INFO3_UPDATE_ONLY\r\n      when Aerospike::RecordExistsAction::REPLACE\r\n        info_attr |= INFO3_CREATE_OR_REPLACE\r\n      when Aerospike::RecordExistsAction::REPLACE_ONLY\r\n        info_attr |= INFO3_REPLACE_ONLY\r\n      when Aerospike::RecordExistsAction::CREATE_ONLY\r\n        write_attr |= INFO2_CREATE_ONLY\r\n      end\r\n      case policy.generation_policy\r\n      when Aerospike::GenerationPolicy::NONE\r\n      when Aerospike::GenerationPolicy::EXPECT_GEN_EQUAL\r\n        generation = policy.generation\r\n        write_attr |= INFO2_GENERATION\r\n      when Aerospike::GenerationPolicy::EXPECT_GEN_GT\r\n        generation = policy.generation\r\n        write_attr |= INFO2_GENERATION_GT\r\n      end\r\n      info_attr |= INFO3_COMMIT_MASTER if policy.commit_level == Aerospike::CommitLevel::COMMIT_MASTER\r\n      read_attr |= INFO1_CONSISTENCY_ALL if policy.consistency_level == Aerospike::ConsistencyLevel::CONSISTENCY_ALL\r\n      write_attr |= INFO2_DURABLE_DELETE if policy.durable_delete\r\n      @data_buffer.write_byte(MSG_REMAINING_HEADER_SIZE, 8)\r\n      @data_buffer.write_byte(read_attr, 9)\r\n      @data_buffer.write_byte(write_attr, 10)\r\n      @data_buffer.write_byte(info_attr, 11)\r\n      @data_buffer.write_byte(0, 12)\r\n      @data_buffer.write_byte(0, 13)\r\n      @data_buffer.write_uint32(generation, 14)\r\n      @data_buffer.write_uint32(policy.ttl, 18)\r\n      @data_buffer.write_byte(0, 22)\r\n      @data_buffer.write_byte(0, 23)\r\n      @data_buffer.write_byte(0, 24)\r\n      @data_buffer.write_byte(0, 25)\r\n      @data_buffer.write_int16(field_count, 26)\r\n      @data_buffer.write_int16(operation_count, 28)\r\n      @data_offset = MSG_TOTAL_HEADER_SIZE\r\n    end","code-length":662,"reference":"Header write for write operations.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef all_nodes_done?\r\n      if @scan\r\n        command = 'scan-list'\r\n      else\r\n        command = 'query-list'\r\n      end\r\n      nodes = @cluster.nodes\r\n      done = false\r\n      nodes.each do |node|\r\n        conn = node.get_connection(0)\r\n        responseMap, _ = Info.request(conn, command)\r\n        node.put_connection(conn)\r\n        response = responseMap[command]\r\n        find = \"job_id=#{@task_id}:\"\r\n        index = response.index(find)\r\n        unless index\r\n          done = true\r\n          next\r\n        end\r\n        b = index + find.length\r\n        response = response[b, response.length]\r\n        find = 'job_status='\r\n        index = response.index(find)\r\n        next unless index\r\n        b = index + find.length\r\n        response = response[b, response.length]\r\n        e = response.index(':')\r\n        status = response[0, e]\r\n        case status\r\n        when 'ABORTED'\r\n          raise raise Aerospike::Exceptions::QueryTerminated\r\n        when 'IN PROGRESS'\r\n          return false\r\n        when 'DONE'\r\n          done = true\r\n        end\r\n      end\r\n      done\r\n    end","code-length":336,"reference":"NewExecuteTask initializes task with fields needed to query server nodes.","result":"Determine if all nodes are done.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get_connection(timeout)\r\n      loop do\r\n        conn = @connections.poll\r\n        if conn.connected?\r\n          conn.timeout = timeout.to_f\r\n          return conn\r\n        end\r\n      end\r\n    end","code-length":67,"reference":"Initialize server node with connection parameters.","result":"Get a connection.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef parse_record(key, op_count, generation, expiration)\r\n      bins = op_count > 0 ? {} : nil\r\n      i = 0\r\n      while i < op_count\r\n        raise Aerospike::Exceptions::QueryTerminated.new unless valid?\r\n        read_bytes(8)\r\n        op_size = @data_buffer.read_int32(0).ord\r\n        particle_type = @data_buffer.read(5).ord\r\n        name_size = @data_buffer.read(7).ord\r\n        read_bytes(name_size)\r\n        name = @data_buffer.read(0, name_size).force_encoding('utf-8')\r\n        particle_bytes_size = op_size - (4 + name_size)\r\n        read_bytes(particle_bytes_size)\r\n        value = Aerospike.bytes_to_particle(particle_type, @data_buffer, 0, particle_bytes_size)\r\n        bins[name] = value\r\n        i = i.succ\r\n      end\r\n      Record.new(@node, key, bins, generation, expiration)\r\n    end","code-length":283,"reference":"Parses the given byte buffer and populate the result object.","result":"Parse a record.","score":[0,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef random_node\r\n      node_array = nodes\r\n      length = node_array.length\r\n      i = 0\r\n      while i < length\r\n        index = (@node_index.update{ |v| v+1 } % node_array.length).abs\r\n        node = node_array[index]\r\n        return node if node.active?\r\n        i = i.succ\r\n      end\r\n      raise Aerospike::Exceptions::InvalidNode\r\n    end","code-length":123,"reference":"Returns a random node on the cluster","result":"Generate a random node.","score":[0.2134,0.2799]}
{"code":"# is used to<extra_id_0>\r\ndef get_node_by_name(node_name)\r\n      node = find_node_by_name(node_name)\r\n      raise Aerospike::Exceptions::InvalidNode unless node\r\n      node\r\n    end","code-length":62,"reference":"Find a node by name and returns an error if not found","result":"Retrieve a node by name.","score":[0.122,0.2606]}
{"code":"# is used to<extra_id_0>\r\ndef prepend(key, bins, options = nil)\r\n      policy = create_policy(options, WritePolicy, default_write_policy)\r\n      command = WriteCommand.new(@cluster, policy, key, hash_to_bins(bins), Aerospike::Operation::PREPEND)\r\n      execute_command(command)\r\n    end","code-length":87,"reference":"Prepends bin values string to existing record bin values.","result":"Store the value in the database.","score":[0,0.0575]}
{"code":"# is used to<extra_id_0>\r\ndef get_header(key, options = nil)\r\n      policy = create_policy(options, Policy, default_read_policy)\r\n      command = ReadHeaderCommand.new(@cluster, policy, key)\r\n      execute_command(command)\r\n      command.record\r\n    end","code-length":75,"reference":"Read record generation and expiration only for specified key.","result":"Get the header.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef batch_exists(keys, options = nil)\r\n      policy = create_policy(options, BatchPolicy, default_batch_policy)\r\n      results = Array.new(keys.length)\r\n      if policy.use_batch_direct\r\n        key_map = BatchItem.generate_map(keys)\r\n        execute_batch_direct_commands(keys) do |node, batch|\r\n          BatchDirectExistsCommand.new(node, batch, policy, key_map, results)\r\n        end\r\n      else\r\n        execute_batch_index_commands(keys) do |node, batch|\r\n          BatchIndexExistsCommand.new(node, batch, policy, results)\r\n        end\r\n      end\r\n      results\r\n    end","code-length":182,"reference":"Check if multiple record keys exist in one batch call.","result":"Check if a batch exists.","score":[0.1383,0.269]}
{"code":"# is used to<extra_id_0>\r\ndef register_udf(udf_body, server_path, language, options = nil)\r\n      policy = create_policy(options, Policy, default_info_policy)\r\n      content = Base64.strict_encode64(udf_body).force_encoding('binary')\r\n      str_cmd = \"udf-put:filename=#{server_path};content=#{content};\"\r\n      str_cmd << \"content-len=#{content.length};udf-type=#{language};\"\r\n      response_map = @cluster.request_info(policy, str_cmd)\r\n      res = {}\r\n      response_map.each do |k, response|\r\n        vals = response.to_s.split(';')\r\n        vals.each do |pair|\r\n          k, v = pair.split(\"=\", 2)\r\n          res[k] = v\r\n        end\r\n      end\r\n      if res['error']\r\n        raise Aerospike::Exceptions::CommandRejected.new(\"Registration failed: #{res['error']}\\nFile: #{res['file']}\\nLine: #{res['line']}\\nMessage: #{res['message']}\")\r\n      end\r\n      UdfRegisterTask.new(@cluster, server_path)\r\n    end","code-length":302,"reference":"Register package containing user defined functions with server.","result":"Register a UDF file.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef remove_udf(udf_name, options = nil)\r\n      policy = create_policy(options, Policy, default_info_policy)\r\n      str_cmd = \"udf-remove:filename=#{udf_name};\"\r\n      response_map = @cluster.request_info(policy, str_cmd)\r\n      _, response = response_map.first\r\n      if response == 'ok'\r\n        UdfRemoveTask.new(@cluster, udf_name)\r\n      else\r\n        raise Aerospike::Exceptions::Aerospike.new(Aerospike::ResultCode::SERVER_ERROR, response)\r\n      end\r\n    end","code-length":165,"reference":"RemoveUDF removes a package containing user defined functions in the server.","result":"Remove a UDF.","score":[0.0284,0.1838]}
{"code":"# is used to<extra_id_0>\r\ndef list_udf(options = nil)\r\n      policy = create_policy(options, Policy, default_info_policy)\r\n      str_cmd = 'udf-list'\r\n      response_map = @cluster.request_info(policy, str_cmd)\r\n      _, response = response_map.first\r\n      vals = response.split(';')\r\n      vals.map do |udf_info|\r\n        next if udf_info.strip! == ''\r\n        udf_parts = udf_info.split(',')\r\n        udf = UDF.new\r\n        udf_parts.each do |values|\r\n          k, v = values.split('=', 2)\r\n          case k\r\n          when 'filename'\r\n            udf.filename = v\r\n          when 'hash'\r\n            udf.hash = v\r\n          when 'type'\r\n            udf.language = v\r\n          end\r\n        end\r\n        udf\r\n      end\r\n    end","code-length":240,"reference":"ListUDF lists all packages containing user defined functions in the server.","result":"List the UDFs.","score":[0.0284,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef execute_udf_on_query(statement, package_name, function_name, function_args=[], options = nil)\r\n      policy = create_policy(options, QueryPolicy, default_query_policy)\r\n      nodes = @cluster.nodes\r\n      if nodes.empty?\r\n        raise Aerospike::Exceptions::Aerospike.new(Aerospike::ResultCode::SERVER_NOT_AVAILABLE, \"Executing UDF failed because cluster is empty.\")\r\n      end\r\n      statement.set_aggregate_function(package_name, function_name, function_args, false)\r\n      nodes.each do |node|\r\n        Thread.new do\r\n          Thread.current.abort_on_exception = true\r\n          begin\r\n            command = QueryCommand.new(node, policy, statement, nil)\r\n            execute_command(command)\r\n          rescue => e\r\n            Aerospike.logger.error(e)\r\n            raise e\r\n          end\r\n        end\r\n      end\r\n      ExecuteTask.new(@cluster, statement)\r\n    end","code-length":261,"reference":"execute_udf_on_query applies user defined function on records that match the statement filter.","result":"Execute UDF on a query.","score":[0.0593,0.0442]}
{"code":"# is used to<extra_id_0>\r\ndef create_index(namespace, set_name, index_name, bin_name, index_type, collection_type = nil, options = nil)\r\n      if options.nil? && collection_type.is_a?(Hash)\r\n        options, collection_type = collection_type, nil\r\n      end\r\n      policy = create_policy(options, Policy, default_info_policy)\r\n      str_cmd = \"sindex-create:ns=#{namespace}\"\r\n      str_cmd << \";set=#{set_name}\" unless set_name.to_s.strip.empty?\r\n      str_cmd << \";indexname=#{index_name};numbins=1\"\r\n      str_cmd << \";indextype=#{collection_type.to_s.upcase}\" if collection_type\r\n      str_cmd << \";indexdata=#{bin_name},#{index_type.to_s.upcase}\"\r\n      str_cmd << \";priority=normal\"\r\n      response = send_info_command(policy, str_cmd).upcase\r\n      if response == 'OK'\r\n        return IndexTask.new(@cluster, namespace, index_name)\r\n      end\r\n      if response.start_with?('FAIL:200')\r\n        return IndexTask.new(@cluster, namespace, index_name, true)\r\n      end\r\n      raise Aerospike::Exceptions::Aerospike.new(Aerospike::ResultCode::INDEX_GENERIC, \"Create index failed: #{response}\")\r\n    end","code-length":359,"reference":"Create secondary index.","result":"Create a new index.","score":[0.3799,0.3226]}
{"code":"# is used to<extra_id_0>\r\ndef drop_index(namespace, set_name, index_name, options = nil)\r\n      policy = create_policy(options, Policy, default_info_policy)\r\n      str_cmd = \"sindex-delete:ns=#{namespace}\"\r\n      str_cmd << \";set=#{set_name}\" unless set_name.to_s.strip.empty?\r\n      str_cmd << \";indexname=#{index_name}\"\r\n      response = send_info_command(policy, str_cmd).upcase\r\n      return if response == 'OK'\r\n      return if response.start_with?('FAIL:201')\r\n      raise Aerospike::Exceptions::Aerospike.new(Aerospike::ResultCode::INDEX_GENERIC, \"Drop index failed: #{response}\")\r\n    end","code-length":195,"reference":"Delete secondary index.","result":"Drop an index.","score":[0.4082,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef scan_node(node, namespace, set_name, bin_names = nil, options = nil)\r\n      policy = create_policy(options, ScanPolicy, default_scan_policy)\r\n      new_policy = policy.clone\r\n      new_policy.max_retries = 0\r\n      node = @cluster.get_node_by_name(node) unless node.is_a?(Aerospike::Node)\r\n      recordset = Recordset.new(policy.record_queue_size, 1, :scan)\r\n      Thread.new do\r\n        Thread.current.abort_on_exception = true\r\n        command = ScanCommand.new(node, new_policy, namespace, set_name, bin_names, recordset)\r\n        begin\r\n          execute_command(command)\r\n        rescue => e\r\n          Aerospike.logger.error(e.backtrace.join(\"\\n\")) unless e == SCAN_TERMINATED_EXCEPTION\r\n          recordset.cancel(e)\r\n        ensure\r\n          recordset.thread_finished\r\n        end\r\n      end\r\n      recordset\r\n    end","code-length":271,"reference":"ScanNode reads all records in specified namespace and set, from one node only.","result":"Scan a set of nodes.","score":[0,0.041]}
{"code":"# is used to<extra_id_0>\r\ndef drop_user(user, options = nil)\r\n      policy = create_policy(options, AdminPolicy, default_admin_policy)\r\n      command = AdminCommand.new\r\n      command.drop_user(@cluster, policy, user)\r\n    end","code-length":68,"reference":"Remove user from cluster.","result":"Drop a user.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef change_password(user, password, options = nil)\r\n      raise Aerospike::Exceptions::Aerospike.new(INVALID_USER) unless @cluster.user && @cluster.user != \"\"\r\n      policy = create_policy(options, AdminPolicy, default_admin_policy)\r\n      hash = AdminCommand.hash_password(password)\r\n      command = AdminCommand.new\r\n      if user == @cluster.user\r\n        command.change_password(@cluster, policy, user, hash)\r\n      else\r\n        command.set_password(@cluster, policy, user, hash)\r\n      end\r\n      @cluster.change_password(user, hash)\r\n    end","code-length":169,"reference":"Change user's password. Clear-text password will be hashed using bcrypt before sending to server.","result":"Change the password of a cluster.","score":[0.0605,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef grant_roles(user, roles, options = nil)\r\n      policy = create_policy(options, AdminPolicy, default_admin_policy)\r\n      command = AdminCommand.new\r\n      command.grant_roles(@cluster, policy, user, roles)\r\n    end","code-length":72,"reference":"Add roles to user's list of roles.","result":"Create the admin command.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef query_users(options = nil)\r\n      policy = create_policy(options, AdminPolicy, default_admin_policy)\r\n      command = AdminCommand.new\r\n      command.query_users(@cluster, policy)\r\n    end","code-length":64,"reference":"Retrieve all users and their roles.","result":"Query users.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef next_record\r\n      raise @thread_exception.get unless @thread_exception.get.nil?\r\n      r = @records.deq\r\n      set_exception if r.nil?\r\n      r\r\n    end","code-length":62,"reference":"fetches and return the first record from the queue if the operation is not finished and the queue is empty it blocks and waits for new records it sets the exception if it reaches the EOF mark, and returns nil","result":"Skip over the next record.","score":[0.0002,0.0137]}
{"code":"# is used to<extra_id_0>\r\ndef each(&block)\r\n      r = true\r\n      while r\r\n        r = next_record\r\n        unless r.nil?\r\n          block.call(r)\r\n        else\r\n          break\r\n        end\r\n      end\r\n    end","code-length":71,"reference":"fetches and returns all the records from the queue until the whole operation is finished and it reaches an EOF mark calling cancel inside the each block raises an exception to signal other consumer threads","result":"Iterate over the records.","score":[0.0001,0.0157]}
{"code":"# is used to<extra_id_0>\r\ndef intercom_script_tag(user_details = nil, options={})\r\n      controller.instance_variable_set(IntercomRails::SCRIPT_TAG_HELPER_CALLED_INSTANCE_VARIABLE, true) if defined?(controller)\r\n      options[:user_details] = user_details if user_details.present?\r\n      options[:find_current_user_details] = !options[:user_details]\r\n      options[:find_current_company_details] = !(options[:user_details] && options[:user_details][:company])\r\n      options[:controller] = controller if defined?(controller)\r\n      ScriptTag.new(options)\r\n    end","code-length":166,"reference":"Generate an intercom script tag.","result":"Generate the script tag.","score":[0.3894,0.5215]}
{"code":"# is used to<extra_id_0>\r\ndef move_free(aim, speed)\r\n      if aim.is_a? Vector\r\n        x_d = aim.x - @x; y_d = aim.y - @y\r\n        distance = Math.sqrt(x_d**2 + y_d**2)\r\n        if distance == 0\r\n          @speed.x = @speed.y = 0\r\n          return\r\n        end\r\n        @speed.x = 1.0 * x_d * speed \/ distance\r\n        @speed.y = 1.0 * y_d * speed \/ distance\r\n        if (@speed.x < 0 and @x + @speed.x <= aim.x) or (@speed.x >= 0 and @x + @speed.x >= aim.x)\r\n          @x = aim.x\r\n          @speed.x = 0\r\n        else\r\n          @x += @speed.x\r\n        end\r\n        if (@speed.y < 0 and @y + @speed.y <= aim.y) or (@speed.y >= 0 and @y + @speed.y >= aim.y)\r\n          @y = aim.y\r\n          @speed.y = 0\r\n        else\r\n          @y += @speed.y\r\n        end\r\n      else\r\n        rads = aim * Math::PI \/ 180\r\n        @speed.x = speed * Math.cos(rads)\r\n        @speed.y = speed * Math.sin(rads)\r\n        @x += @speed.x\r\n        @y += @speed.y\r\n      end\r\n    end","code-length":392,"reference":"Moves this object, without performing any collision checking, towards a specified point or in a specified direction.","result":"Move a free point.","score":[0.0124,0.0637]}
{"code":"# is used to<extra_id_0>\r\ndef get_absolute_size\r\n      return Vector.new(@tile_size.x * @size.x, @tile_size.y * @size.y) unless @isometric\r\n      avg = (@size.x + @size.y) * 0.5\r\n      Vector.new (avg * @tile_size.x).to_i, (avg * @tile_size.y).to_i\r\n    end","code-length":108,"reference":"Creates a new map.","result":"Calculate the absolute size of the tile.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get_screen_pos(map_x, map_y)\r\n      return Vector.new(map_x * @tile_size.x - @cam.x, map_y * @tile_size.y - @cam.y) unless @isometric\r\n      Vector.new ((map_x - map_y - 1) * @tile_size.x * 0.5) - @cam.x + @x_offset,\r\n                 ((map_x + map_y) * @tile_size.y * 0.5) - @cam.y\r\n    end","code-length":142,"reference":"Returns the position in the screen corresponding to the given tile indices.","result":"Get the screen position.","score":[0.0611,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef get_map_pos(scr_x, scr_y)\r\n      return Vector.new((scr_x + @cam.x) \/ @tile_size.x, (scr_y + @cam.y) \/ @tile_size.y) unless @isometric\r\n      v = get_isometric_position scr_x, scr_y\r\n      Vector.new((v.x * @inverse_square_size).to_i, (v.y * @inverse_square_size).to_i)\r\n    end","code-length":133,"reference":"Returns the tile in the map that corresponds to the given position in the screen, as a Vector, where x is the horizontal index and y the vertical index.","result":"Get the map position.","score":[0.0009,0.0377]}
{"code":"# is used to<extra_id_0>\r\ndef is_in_map(v)\r\n      v.x >= 0 && v.y >= 0 && v.x < @size.x && v.y < @size.y\r\n    end","code-length":54,"reference":"Verifies whether a tile is inside the map.","result":"Check if a value is in a map.","score":[0.1828,0.1875]}
{"code":"# is used to<extra_id_0>\r\ndef animate_once(indices, interval)\r\n      if @animate_once_control == 2\r\n        return if indices == @animate_once_indices && interval == @animate_once_interval\r\n        @animate_once_control = 0\r\n      end\r\n      unless @animate_once_control == 1\r\n        @anim_counter = 0\r\n        @img_index = indices[0]\r\n        @index_index = 0\r\n        @animate_once_indices = indices\r\n        @animate_once_interval = interval\r\n        @animate_once_control = 1\r\n        return\r\n      end\r\n      @anim_counter += 1\r\n      return unless @anim_counter >= interval\r\n      @index_index += 1\r\n      @img_index = indices[@index_index]\r\n      @anim_counter = 0\r\n      @animate_once_control = 2 if @index_index == indices.length - 1\r\n    end","code-length":241,"reference":"Causes the sprite to animate through the +indices+ array exactly once, so that the animation stops once it reaches the last index in the array.","result":"Animate the image once.","score":[0.0017,0.0437]}
{"code":"# is used to<extra_id_0>\r\ndef draw(map = nil, scale_x = 1, scale_y = 1, alpha = 0xff, color = 0xffffff, angle = nil, flip = nil, z_index = 0, round = false)\r\n      if map.is_a? Hash\r\n        scale_x = map.fetch(:scale_x, 1)\r\n        scale_y = map.fetch(:scale_y, 1)\r\n        alpha = map.fetch(:alpha, 0xff)\r\n        color = map.fetch(:color, 0xffffff)\r\n        angle = map.fetch(:angle, nil)\r\n        flip = map.fetch(:flip, nil)\r\n        z_index = map.fetch(:z_index, 0)\r\n        round = map.fetch(:round, false)\r\n        map = map.fetch(:map, nil)\r\n      end\r\n      color = (alpha << 24) | color\r\n      if angle\r\n        @img[@img_index].draw_rot @x - (map ? map.cam.x : 0) + @img[0].width * scale_x * 0.5,\r\n                                  @y - (map ? map.cam.y : 0) + @img[0].height * scale_y * 0.5,\r\n                                  z_index, angle, 0.5, 0.5, (flip == :horiz ? -scale_x : scale_x),\r\n                                  (flip == :vert ? -scale_y : scale_y), color\r\n      else\r\n        x = @x - (map ? map.cam.x : 0) + (flip == :horiz ? scale_x * @img[0].width : 0)\r\n        y = @y - (map ? map.cam.y : 0) + (flip == :vert ? scale_y * @img[0].height : 0)\r\n        @img[@img_index].draw (round ? x.round : x), (round ? y.round : y),\r\n                              z_index, (flip == :horiz ? -scale_x : scale_x),\r\n                              (flip == :vert ? -scale_y : scale_y), color\r\n      end\r\n    end","code-length":511,"reference":"Draws the sprite in the screen       and y coordinates of the sprite will be changed according to the [scale_x] A scale factor to be applied horizontally to the image.","result":"Draw the image.","score":[0.0001,0.0968]}
{"code":"# is used to<extra_id_0>\r\ndef update\r\n      return unless @enabled and @visible\r\n      mouse_over = Mouse.over? @x, @y, @w, @h\r\n      mouse_press = Mouse.button_pressed? :left\r\n      mouse_rel = Mouse.button_released? :left\r\n      if @state == :up\r\n        if mouse_over\r\n          @img_index = 1\r\n          @state = :over\r\n        else\r\n          @img_index = 0\r\n        end\r\n      elsif @state == :over\r\n        if not mouse_over\r\n          @img_index = 0\r\n          @state = :up\r\n        elsif mouse_press\r\n          @img_index = 2\r\n          @state = :down\r\n        else\r\n          @img_index = 1\r\n        end\r\n      elsif @state == :down\r\n        if not mouse_over\r\n          @img_index = 0\r\n          @state = :down_out\r\n        elsif mouse_rel\r\n          @img_index = 1\r\n          @state = :over\r\n          click\r\n        else\r\n          @img_index = 2\r\n        end\r\n      else\r\n        if mouse_over\r\n          @img_index = 2\r\n          @state = :down\r\n        elsif mouse_rel\r\n          @img_index = 0\r\n          @state = :up\r\n        else\r\n          @img_index = 0\r\n        end\r\n      end\r\n    end","code-length":357,"reference":"Creates a button.","result":"Update the mouse state.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef draw(alpha = 0xff, z_index = 0, color = 0xffffff)\r\n      return unless @visible\r\n      color = (alpha << 24) | color\r\n      text_color =\r\n        if @enabled\r\n          if @state == :down\r\n            @down_text_color\r\n          else\r\n            @state == :over ? @over_text_color : @text_color\r\n          end\r\n        else\r\n          @disabled_text_color\r\n        end\r\n      text_color = (alpha << 24) | text_color\r\n      @img[@img_index].draw @x, @y, z_index, @scale_x, @scale_y, color if @img\r\n      if @text\r\n        if @center_x or @center_y\r\n          rel_x = @center_x ? 0.5 : 0\r\n          rel_y = @center_y ? 0.5 : 0\r\n          @font.draw_text_rel @text, @text_x, @text_y, z_index, rel_x, rel_y, @scale_x, @scale_y, text_color\r\n        else\r\n          @font.draw_text @text, @text_x, @text_y, z_index, @scale_x, @scale_y, text_color\r\n        end\r\n      end\r\n    end","code-length":332,"reference":"Draws the button in the screen.","result":"Draw the image.","score":[0.1502,0.1754]}
{"code":"# is used to<extra_id_0>\r\ndef text=(value, trigger_changed = true)\r\n      @text = value[0...@max_length]\r\n      @nodes.clear; @nodes << @text_x\r\n      x = @nodes[0]\r\n      @text.chars.each { |char|\r\n        x += @font.text_width(char) * @scale_x\r\n        @nodes << x\r\n      }\r\n      @cur_node = @nodes.size - 1\r\n      @anchor1 = nil\r\n      @anchor2 = nil\r\n      set_cursor_visible\r\n      @on_text_changed.call @text, @params if trigger_changed && @on_text_changed\r\n    end","code-length":172,"reference":"Sets the text of the text field to the specified value.","result":"Set the text.","score":[0.0284,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef set_position(x, y)\r\n      d_x = x - @x\r\n      d_y = y - @y\r\n      @x = x; @y = y\r\n      @text_x += d_x\r\n      @text_y += d_y\r\n      @nodes.map! do |n|\r\n        n + d_x\r\n      end\r\n    end","code-length":102,"reference":"Sets the position of the text field in the screen.","result":"Set the position of the text.","score":[0.3102,0.3875]}
{"code":"# is used to<extra_id_0>\r\ndef draw(alpha = 0xff, z_index = 0, color = 0xffffff, disabled_color = 0x808080)\r\n      return unless @visible\r\n      color = (alpha << 24) | ((@enabled or @disabled_img) ? color : disabled_color)\r\n      text_color = (alpha << 24) | (@enabled ? @text_color : @disabled_text_color)\r\n      img = ((@enabled or @disabled_img.nil?) ? @img : @disabled_img)\r\n      img.draw @x, @y, z_index, @scale_x, @scale_y, color\r\n      @font.draw_text @text, @text_x, @text_y, z_index, @scale_x, @scale_y, text_color\r\n      if @anchor1 and @anchor2\r\n        selection_color = ((alpha \/ 2) << 24) | @selection_color\r\n        G.window.draw_quad @nodes[@anchor1], @text_y, selection_color,\r\n                           @nodes[@anchor2] + 1, @text_y, selection_color,\r\n                           @nodes[@anchor2] + 1, @text_y + @font.height * @scale_y, selection_color,\r\n                           @nodes[@anchor1], @text_y + @font.height * @scale_y, selection_color, z_index\r\n      end\r\n      if @cursor_visible\r\n        if @cursor_img\r\n          @cursor_img.draw @nodes[@cur_node] - (@cursor_img.width * @scale_x) \/ 2, @text_y, z_index, @scale_x, @scale_y\r\n        else\r\n          cursor_color = alpha << 24\r\n          G.window.draw_quad @nodes[@cur_node], @text_y, cursor_color,\r\n                             @nodes[@cur_node] + 1, @text_y, cursor_color,\r\n                             @nodes[@cur_node] + 1, @text_y + @font.height * @scale_y, cursor_color,\r\n                             @nodes[@cur_node], @text_y + @font.height * @scale_y, cursor_color, z_index\r\n        end\r\n      end\r\n    end","code-length":541,"reference":"Draws the text field in the screen.","result":"Code too long,keep in 512.","score":[0.1611,0.0735]}
{"code":"# is used to<extra_id_0>\r\ndef draw(alpha = 0xff, z_index = 0, color = 0xffffff)\r\n      return unless @visible\r\n      if @bg\r\n        c = (alpha << 24) | color\r\n        @bg.draw @x, @y, z_index, @scale_x, @scale_y, c\r\n      else\r\n        c = (alpha << 24) | @bg_color\r\n        G.window.draw_quad @x, @y, c,\r\n                           @x + @w, @y, c,\r\n                           @x + @w, @y + @h, c,\r\n                           @x, @y + @h, c, z_index\r\n      end\r\n      if @fg\r\n        c = (alpha << 24) | color\r\n        w1 = @fg.width * @scale_x\r\n        w2 = (@value.to_f \/ @max_value * @w).round\r\n        x0 = @x + @fg_margin_x\r\n        x = 0\r\n        while x <= w2 - w1\r\n          @fg.draw x0 + x, @y + @fg_margin_y, z_index, @scale_x, @scale_y, c\r\n          x += w1\r\n        end\r\n        if w2 - x > 0\r\n          img = Gosu::Image.new(@fg_path, tileable: true, retro: @retro, rect: [0, 0, ((w2 - x) \/ @scale_x).round, @fg.height])\r\n          img.draw x0 + x, @y + @fg_margin_y, z_index, @scale_x, @scale_y, c\r\n        end\r\n      else\r\n        c = (alpha << 24) | @fg_color\r\n        rect_r = @x + (@value.to_f \/ @max_value * @w).round\r\n        G.window.draw_quad @x, @y, c,\r\n                           rect_r, @y, c,\r\n                           rect_r, @y + @h, c,\r\n                           @x, @y + @h, c, z_index\r\n      end\r\n      if @font\r\n        c = (alpha << 24) | @text_color\r\n        @text = @format == '%' ? \"#{(@value.to_f \/ @max_value * 100).round}%\" : \"#{@value}\/#{@max_value}\"\r\n        @font.draw_text_rel @text, @x + @w \/ 2, @y + @h \/ 2, z_index, 0.5, 0.5, @scale_x, @scale_y, c\r\n      end\r\n    end","code-length":644,"reference":"Draws the progress bar.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef update\r\n      return unless @enabled and @visible\r\n      if @open and Mouse.button_pressed? :left and not Mouse.over?(@x, @y, @w, @max_h)\r\n        toggle\r\n        return\r\n      end\r\n      @buttons.each { |b| b.update }\r\n    end","code-length":87,"reference":"Creates a new drop-down list.","result":"Update the mouse.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef value=(val)\r\n      if @options.include? val\r\n        old = @value\r\n        @value = @buttons[0].text = val\r\n        @on_changed.call(old, val) if @on_changed\r\n      end\r\n    end","code-length":72,"reference":"Sets the currently selected value of the drop-down list.","result":"Set the value of the radio button.","score":[0.2686,0.55]}
{"code":"# is used to<extra_id_0>\r\ndef draw(alpha = 0xff, z_index = 0, color = 0xffffff, over_color = 0xcccccc)\r\n      return unless @visible\r\n      unless @img\r\n        bottom = @y + (@open ? @max_h : @h) + @scale_y\r\n        b_color = (alpha << 24)\r\n        G.window.draw_quad @x - @scale_x, @y - @scale_y, b_color,\r\n                           @x + @w + @scale_x, @y - @scale_y, b_color,\r\n                           @x + @w + @scale_x, bottom, b_color,\r\n                           @x - @scale_x, bottom, b_color, z_index\r\n        @buttons.each do |b|\r\n          c = (alpha << 24) | (b.state == :over ? over_color : color)\r\n          G.window.draw_quad b.x, b.y, c,\r\n                             b.x + b.w, b.y, c,\r\n                             b.x + b.w, b.y + b.h, c,\r\n                             b.x, b.y + b.h, c, z_index + 1 if b.visible\r\n        end\r\n      end\r\n      @buttons[0].draw(alpha, z_index, color)\r\n      @buttons[1..-1].each { |b| b.draw alpha, z_index + 1, color }\r\n    end","code-length":364,"reference":"Draws the drop-down list.","result":"Draw the buttons.","score":[0.2925,0.4808]}
{"code":"# is used to<extra_id_0>\r\ndef draw(alpha = 255, z_index = 0, color = 0xffffff)\r\n      c = @enabled ? @text_color : @disabled_text_color\r\n      r1 = c >> 16\r\n      g1 = (c & 0xff00) >> 8\r\n      b1 = (c & 0xff)\r\n      r2 = color >> 16\r\n      g2 = (color & 0xff00) >> 8\r\n      b2 = (color & 0xff)\r\n      r1 *= r2; r1 \/= 255\r\n      g1 *= g2; g1 \/= 255\r\n      b1 *= b2; b1 \/= 255\r\n      color = (alpha << 24) | (r1 << 16) | (g1 << 8) | b1\r\n      @font.draw_text(@text, @x, @y, z_index, @scale_x, @scale_y, color)\r\n    end","code-length":223,"reference":"Creates a new label.","result":"Draw the text.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef write_line(text, x = nil, y = nil, mode = :left, color = 0, alpha = 0xff,\r\n                   effect = nil, effect_color = 0, effect_size = 1, effect_alpha = 0xff,\r\n                   z_index = 0)\r\n      if text.is_a? Hash\r\n        x = text[:x]\r\n        y = text[:y]\r\n        mode = text.fetch(:mode, :left)\r\n        color = text.fetch(:color, 0)\r\n        alpha = text.fetch(:alpha, 0xff)\r\n        effect = text.fetch(:effect, nil)\r\n        effect_color = text.fetch(:effect_color, 0)\r\n        effect_size = text.fetch(:effect_size, 1)\r\n        effect_alpha = text.fetch(:effect_alpha, 0xff)\r\n        z_index = text.fetch(:z_index, 0)\r\n        text = text[:text]\r\n      end\r\n      color = (alpha << 24) | color\r\n      rel =\r\n        case mode\r\n        when :left then 0\r\n        when :center then 0.5\r\n        when :right then 1\r\n        else 0\r\n        end\r\n      if effect\r\n        effect_color = (effect_alpha << 24) | effect_color\r\n        if effect == :border\r\n          @font.draw_markup_rel text, x - effect_size, y - effect_size, z_index, rel, 0, 1, 1, effect_color\r\n          @font.draw_markup_rel text, x, y - effect_size, z_index, rel, 0, 1, 1, effect_color\r\n          @font.draw_markup_rel text, x + effect_size, y - effect_size, z_index, rel, 0, 1, 1, effect_color\r\n          @font.draw_markup_rel text, x + effect_size, y, z_index, rel, 0, 1, 1, effect_color\r\n          @font.draw_markup_rel text, x + effect_size, y + effect_size, z_index, rel, 0, 1, 1, effect_color\r\n          @font.draw_markup_rel text, x, y + effect_size, z_index, rel, 0, 1, 1, effect_color\r\n          @font.draw_markup_rel text, x - effect_size, y + effect_size, z_index, rel, 0, 1, 1, effect_color\r\n          @font.draw_markup_rel text, x - effect_size, y, z_index, rel, 0, 1, 1, effect_color\r\n        elsif effect == :shadow\r\n          @font.draw_markup_rel text, x + effect_size, y + effect_size, z_index, rel, 0, 1, 1, effect_color\r\n        end\r\n      end\r\n      @font.draw_markup_rel text, x, y, z_index, rel, 0, 1, 1, color\r\n    end","code-length":720,"reference":"Creates a TextHelper.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef write_breaking(text, x, y, width, mode = :left, color = 0, alpha = 0xff, z_index = 0)\r\n      color = (alpha << 24) | color\r\n      text.split(\"\\n\").each do |p|\r\n        if mode == :justified\r\n          y = write_paragraph_justified p, x, y, width, color, z_index\r\n        else\r\n          rel =\r\n            case mode\r\n            when :left then 0\r\n            when :center then 0.5\r\n            when :right then 1\r\n            else 0\r\n            end\r\n          y = write_paragraph p, x, y, width, rel, color, z_index\r\n        end\r\n      end\r\n    end","code-length":186,"reference":"Draws text, breaking lines when needed and when explicitly caused by the \"\\n\" character.","result":"Write paragraphs.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add_global(message)\r\n      unless (slot = @entries.index { |e| e.nil? })\r\n        slot = 0\r\n        0.upto(15) do |i|\r\n          if i != slot && @entries[slot].last_use > @entries[i].last_use\r\n            slot = i\r\n          end\r\n        end\r\n      end\r\n      @entries[slot] = Entry.new(message, Time.now)\r\n      slot\r\n    end","code-length":127,"reference":"Add a new GlobalFitMessage to the mapper and return the local message number.","result":"Add a message to the log.","score":[0.1183,0.3024]}
{"code":"# is used to<extra_id_0>\r\ndef get_local(message)\r\n      0.upto(15) do |i|\r\n        if (entry = @entries[i]) && entry.global_message == message\r\n          entry.last_use = Time.now\r\n          return i\r\n        end\r\n      end\r\n      nil\r\n    end","code-length":83,"reference":"Get the local message number for a given GlobalFitMessage.","result":"Get the local message.","score":[0.1885,0.3464]}
{"code":"# is used to<extra_id_0>\r\ndef check\r\n      last_timestamp = ts_16_offset = nil\r\n      last_ts_16 = nil\r\n      @monitorings.each do |record|\r\n        if last_ts_16 && ts_16_offset && record.timestamp_16 &&\r\n           record.timestamp_16 < last_ts_16\r\n          ts_16_offset += 2 ** 16\r\n        end\r\n        if ts_16_offset\r\n          if record.timestamp_16\r\n            record.timestamp = ts_16_offset + record.timestamp_16\r\n            last_ts_16 = record.timestamp_16\r\n          end\r\n        else\r\n          if record.timestamp_16 && last_timestamp\r\n            ts_16_offset = last_timestamp + 60 - record.timestamp_16\r\n            record.timestamp = ts_16_offset + record.timestamp_16\r\n            last_ts_16 = record.timestamp_16\r\n          else\r\n            last_timestamp = record.timestamp\r\n          end\r\n        end\r\n      end\r\n    end","code-length":252,"reference":"Create a new Monitoring_B object.","result":"Check the monitorings.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef create_global_definition(fit_entity)\r\n      messages = fit_entity.developer_fit_messages\r\n      unless (gfm = GlobalFitMessages[@native_mesg_num])\r\n        Log.error \"Developer field description references unknown global \" +\r\n          \"message number #{@native_mesg_num}\"\r\n        return\r\n      end\r\n      if @developer_data_index >=\r\n           fit_entity.top_level_record.developer_data_ids.size\r\n         Log.error \"Developer data index #{@developer_data_index} is too large\"\r\n         return\r\n      end\r\n      msg = messages[@native_mesg_num] ||\r\n        messages.message(@native_mesg_num, gfm.name)\r\n      unless (@fit_base_type_id & 0x7F) < FIT_TYPE_DEFS.size\r\n        Log.error \"fit_base_type_id #{@fit_base_type_id} is too large\"\r\n        return\r\n      end\r\n      options = {}\r\n      options[:scale] = @scale if @scale\r\n      options[:offset] = @offset if @offset\r\n      options[:array] = @array if @array\r\n      options[:unit] = @units\r\n      msg.field(@field_definition_number,\r\n                FIT_TYPE_DEFS[@fit_base_type_id & 0x7F][1],\r\n                \"_#{@developer_data_index}_#{@field_name}\", options)\r\n    end","code-length":365,"reference":"Create a new FieldDescription object.","result":"Create a new global definition.","score":[0.4949,0.5889]}
{"code":"# is used to<extra_id_0>\r\ndef check(index)\r\n      unless @device_index\r\n        Log.fatal 'device info record must have a device_index'\r\n      end\r\n      if @device_index == 0\r\n        unless @manufacturer\r\n          Log.fatal 'device info record 0 must have a manufacturer field set'\r\n        end\r\n        if @manufacturer == 'garmin'\r\n          unless @garmin_product\r\n            Log.fatal 'device info record 0 must have a garman_product ' +\r\n                      'field set'\r\n          end\r\n        else\r\n          unless @product\r\n            Log.fatal 'device info record 0 must have a product field set'\r\n          end\r\n        end\r\n        if @serial_number.nil?\r\n          Log.fatal 'device info record 0 must have a serial number set'\r\n        end\r\n      end\r\n    end","code-length":214,"reference":"Ensure that FitDataRecords have a deterministic sequence.","result":"Check the validity of the device info record.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef open(io)\r\n      begin\r\n        @@logger = Logger.new(io)\r\n      rescue => e\r\n        @@logger = Logger.new($stderr)\r\n        Log.fatal \"Cannot open log file: #{e.message}\"\r\n      end\r\n    end","code-length":73,"reference":"Redirect all log messages to the given IO.","result":"Open the log file.","score":[0.1398,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef set_type(type)\r\n      if @top_level_record\r\n        Log.fatal \"FIT file type has already been set to \" +\r\n                  \"#{@top_level_record.class}\"\r\n      end\r\n      case type\r\n      when 4, 'activity'\r\n        @top_level_record = Activity.new\r\n        @type = 'activity'\r\n      when 32, 'monitoring_b'\r\n        @top_level_record = Monitoring_B.new\r\n        @type = 'monitoring_b'\r\n      when 44, 'metrics'\r\n        @top_level_record = Metrics.new\r\n        @type = 'metrics'\r\n      else\r\n        Log.error \"Unsupported FIT file type #{type}\"\r\n        return nil\r\n      end\r\n      @top_level_record\r\n    end","code-length":205,"reference":"Create a FitFileEntity.","result":"Set the type of the record.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef check\r\n      unless @timestamp && @timestamp >= Time.parse('1990-01-01T00:00:00+00:00')\r\n        Log.fatal \"Activity has no valid timestamp\"\r\n      end\r\n      unless @total_timer_time\r\n        Log.fatal \"Activity has no valid total_timer_time\"\r\n      end\r\n      unless @device_infos.length > 0\r\n        Log.fatal \"Activity must have at least one device_info section\"\r\n      end\r\n      @device_infos.each.with_index { |d, index| d.check(index) }\r\n      @sensor_settings.each.with_index { |s, index| s.check(index) }\r\n      unless @num_sessions == @sessions.count\r\n        Log.fatal \"Activity record requires #{@num_sessions}, but \"\r\n                  \"#{@sessions.length} session records were found in the \"\r\n                  \"FIT file.\"\r\n      end\r\n      ts = Time.parse('1989-12-31')\r\n      distance = nil\r\n      invalid_records = []\r\n      @records.each_with_index do |r, idx|\r\n        Log.fatal \"Record has no timestamp\" unless r.timestamp\r\n        if r.timestamp < ts\r\n          Log.fatal \"Record has earlier timestamp than previous record\"\r\n        end\r\n        if r.distance\r\n          if distance && r.distance < distance\r\n            Log.error \"Record #{r.timestamp} has smaller distance \" +\r\n                      \"(#{r.distance}) than an earlier record (#{distance}).\"\r\n            (idx - 1).downto(0) do |i|\r\n              if (ri = @records[i]).distance > r.distance\r\n                invalid_records << ri\r\n              else\r\n                break\r\n              end\r\n            end\r\n          end\r\n          distance = r.distance\r\n        end\r\n        ts = r.timestamp\r\n      end\r\n      unless invalid_records.empty?\r\n        Log.warn \"Discarding #{invalid_records.length} earlier records\"\r\n        @records.delete_if { |r| invalid_records.include?(r) }\r\n      end\r\n      @laps.each.with_index do |lap, index|\r\n        lap.check(index)\r\n        @heart_rate_zones[index].check(index) if @heart_rate_zones[index]\r\n      end\r\n      @sessions.each { |s| s.check(self) }\r\n    end","code-length":604,"reference":"Create a new Activity object.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef total_gps_distance\r\n      timer_stops = []\r\n      @events.each do |e|\r\n        if e.event == 'timer' && e.event_type == 'stop_all'\r\n          timer_stops << e.timestamp\r\n        end\r\n      end\r\n      d = 0.0\r\n      last_lat = last_long = nil\r\n      last_timestamp = nil\r\n      @records.each do |r|\r\n        if (lat = r.position_lat) && (long = r.position_long)\r\n          if last_lat && last_long\r\n            distance = Fit4Ruby::GeoMath.distance(last_lat, last_long,\r\n                                                  lat, long)\r\n            d += distance\r\n          end\r\n          if last_timestamp\r\n            speed = distance \/ (r.timestamp - last_timestamp)\r\n          end\r\n          if timer_stops[0] == r.timestamp\r\n            last_lat = last_long = nil\r\n            last_timestamp = nil\r\n            timer_stops.shift\r\n          else\r\n            last_lat = lat\r\n            last_long = long\r\n            last_timestamp = r.timestamp\r\n          end\r\n        end\r\n      end\r\n      d\r\n    end","code-length":313,"reference":"Total distance convered by this activity purely computed by the GPS coordinates.","result":"Calculate the speed of the GPS distance.","score":[0.1118,0.163]}
{"code":"# is used to<extra_id_0>\r\ndef vo2max\r\n      @events.each do |e|\r\n        return e.vo2max if e.event == 'vo2max'\r\n      end\r\n      @user_data.each do |u|\r\n        return u.metmax * 3.5 if u.metmax\r\n      end\r\n      nil\r\n    end","code-length":89,"reference":"Returns the computed VO2max value.","result":"Calculate the max velocity.","score":[0.2488,0.102]}
{"code":"# is used to<extra_id_0>\r\ndef write(io, id_mapper)\r\n      @file_id.write(io, id_mapper)\r\n      @file_creator.write(io, id_mapper)\r\n      (@field_descriptions + @developer_data_ids +\r\n       @device_infos + @sensor_settings +\r\n       @data_sources + @user_profiles +\r\n       @physiological_metrics + @events +\r\n       @sessions + @laps + @records + @heart_rate_zones +\r\n       @personal_records).sort.each do |s|\r\n        s.write(io, id_mapper)\r\n      end\r\n      super\r\n    end","code-length":167,"reference":"Write the Activity data to a file.","result":"Serialize the file.","score":[0.128,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef new_fit_data_record(record_type, field_values = {})\r\n      case record_type\r\n      when 'file_id'\r\n        @file_id = (record = FileId.new(field_values))\r\n      when 'field_description'\r\n        @field_descriptions << (record = FieldDescription.new(field_values))\r\n      when 'developer_data_id'\r\n        @developer_data_ids << (record = DeveloperDataId.new(field_values))\r\n      when 'epo_data'\r\n        @epo_data = (record = EPO_Data.new(field_values))\r\n      when 'file_creator'\r\n        @file_creator = (record = FileCreator.new(field_values))\r\n      when 'device_info'\r\n        @device_infos << (record = DeviceInfo.new(field_values))\r\n      when 'sensor_settings'\r\n        @sensor_settings << (record = SensorSettings.new(field_values))\r\n      when 'data_sources'\r\n        @data_sources << (record = DataSources.new(field_values))\r\n      when 'user_data'\r\n        @user_data << (record = UserData.new(field_values))\r\n      when 'user_profile'\r\n        @user_profiles << (record = UserProfile.new(field_values))\r\n      when 'physiological_metrics'\r\n        @physiological_metrics <<\r\n          (record = PhysiologicalMetrics.new(field_values))\r\n      when 'event'\r\n        @events << (record = Event.new(field_values))\r\n      when 'session'\r\n        unless @cur_lap_records.empty?\r\n          lap_field_values = {}\r\n          [ :timestamp, :sport ].each do |f|\r\n            lap_field_values[f] = field_values[f] if field_values.include?(f)\r\n          end\r\n          record = create_new_lap(lap_field_values)\r\n        end\r\n        @num_sessions += 1\r\n        @sessions << (record = Session.new(@cur_session_laps, @lap_counter,\r\n                                           field_values))\r\n        @cur_session_laps = []\r\n      when 'lap'\r\n        record = create_new_lap(field_values)\r\n      when 'record'\r\n        @cur_lap_records << (record = Record.new(field_values))\r\n        @records << record\r\n      when 'hrv'\r\n        @hrv << (record = HRV.new(field_values))\r\n      when 'heart_rate_zones'\r\n        @heart_rate_zones << (record = HeartRateZones.new(field_values))\r\n      when 'personal_records'\r\n        @personal_records << (record = PersonalRecords.new(field_values))\r\n      else\r\n        record = nil\r\n      end\r\n      record\r\n    end","code-length":728,"reference":"Check if the current Activity is equal to the passed Activity.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef check(activity)\r\n      unless @first_lap_index\r\n        Log.fatal 'first_lap_index is not set'\r\n      end\r\n      unless @num_laps\r\n        Log.fatal 'num_laps is not set'\r\n      end\r\n      @first_lap_index.upto(@first_lap_index - @num_laps) do |i|\r\n        if (lap = activity.lap[i])\r\n          @laps << lap\r\n        else\r\n          Log.fatal \"Session references lap #{i} which is not contained in \"\r\n                    \"the FIT file.\"\r\n        end\r\n      end\r\n    end","code-length":168,"reference":"Create a new Session object.","result":"Check the session.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef field(number, type, name, opts = {})\r\n      field = Field.new(type, name, opts)\r\n      register_field_by_name(field, name)\r\n      register_field_by_number(field, number)\r\n    end","code-length":71,"reference":"Create a new GlobalFitMessage definition.","result":"Register a field.","score":[0.2096,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef alt_field(number, ref_field, &block)\r\n      unless @fields_by_name.include?(ref_field)\r\n        raise \"Unknown ref_field: #{ref_field}\"\r\n      end\r\n      field = AltField.new(self, ref_field, &block)\r\n      register_field_by_number(field, number)\r\n    end","code-length":98,"reference":"Define a new set of Field alternatives for this message definition.","result":"Register an alt field.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef spam?\r\n      self.class.mail_captcha.each do |field|\r\n        next if send(field).blank?\r\n        if defined?(Rails) && Rails.env.development?\r\n          raise ScriptError, \"The captcha field #{field} was supposed to be blank\"\r\n        else\r\n          return true\r\n        end\r\n      end\r\n      false\r\n    end","code-length":101,"reference":"In development, raises an error if the captcha field is not blank.","result":"Check if the email is spam.","score":[0.1112,0.2242]}
{"code":"# is used to<extra_id_0>\r\ndef deliver!\r\n      mailer = MailForm::Notifier.contact(self)\r\n      if mailer.respond_to?(:deliver_now)\r\n        mailer.deliver_now\r\n      else\r\n        mailer.deliver\r\n      end\r\n    end","code-length":67,"reference":"Deliver the resource without running any validation.","result":"Deliver the message.","score":[0.1522,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef mail_form_attributes\r\n      self.class.mail_attributes.each_with_object({}) do |attr, hash|\r\n        hash[attr.to_s] = send(attr)\r\n      end\r\n    end","code-length":63,"reference":"Returns a hash of attributes, according to the attributes existent in self.class.mail_attributes.","result":"Generate the form.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef start\r\n      extract_and_configure\r\n      if config.managed?\r\n        exec('start', p: port, c: config.cloud)\r\n        unless status\r\n          sleep config.poll_interval\r\n        end\r\n        after_start\r\n      end\r\n    end","code-length":76,"reference":"Start Solr and wait for it to become available","result":"Start the server.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef restart\r\n      if config.managed? && started?\r\n        exec('restart', p: port, c: config.cloud)\r\n      end\r\n    end","code-length":47,"reference":"Stop Solr and wait for it to finish exiting","result":"Restart the server.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef create(options = {})\r\n      options[:name] ||= SecureRandom.hex\r\n      create_options = { p: port }\r\n      create_options[:c] = options[:name] if options[:name]\r\n      create_options[:n] = options[:config_name] if options[:config_name]\r\n      create_options[:d] = options[:dir] if options[:dir]\r\n      Retriable.retriable do\r\n        raise \"Not started yet\" unless started?\r\n      end\r\n      return if options[:persist] && create_options[:c] && client.exists?(create_options[:c])\r\n      exec(\"create\", create_options)\r\n      options[:name]\r\n    end","code-length":178,"reference":"Create a new collection in solr ","result":"Create a new instance.","score":[0.3991,0.5077]}
{"code":"# is used to<extra_id_0>\r\ndef upconfig(options = {})\r\n      options[:name] ||= SecureRandom.hex\r\n      options[:zkhost] ||= zkhost\r\n      upconfig_options = { upconfig: true, n: options[:name] }\r\n      upconfig_options[:d] = options[:dir] if options[:dir]\r\n      upconfig_options[:z] = options[:zkhost] if options[:zkhost]\r\n      exec 'zk', upconfig_options\r\n      options[:name]\r\n    end","code-length":125,"reference":"Update the collection configuration in zookeeper ","result":"Create a new node.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef downconfig(options = {})\r\n      options[:name] ||= SecureRandom.hex\r\n      options[:zkhost] ||= zkhost\r\n      downconfig_options = { downconfig: true, n: options[:name] }\r\n      downconfig_options[:d] = options[:dir] if options[:dir]\r\n      downconfig_options[:z] = options[:zkhost] if options[:zkhost]\r\n      exec 'zk', downconfig_options\r\n      options[:name]\r\n    end","code-length":125,"reference":"Copy the collection configuration from zookeeper to a local directory ","result":"Downconfigure the node.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef with_collection(options = {})\r\n      options = config.collection_options.merge(options)\r\n      return yield if options.empty?\r\n      name = create(options)\r\n      begin\r\n        yield name\r\n      ensure\r\n        delete name unless options[:persist]\r\n      end\r\n    end","code-length":83,"reference":"Create a new collection, run the block, and then clean up the collection ","result":"Create a collection.","score":[0.0206,0.1563]}
{"code":"# is used to<extra_id_0>\r\ndef clean!\r\n      stop\r\n      remove_instance_dir!\r\n      FileUtils.remove_entry(config.download_dir, true) if File.exist?(config.download_dir)\r\n      FileUtils.remove_entry(config.tmp_save_dir, true) if File.exist? config.tmp_save_dir\r\n      checksum_validator.clean!\r\n      FileUtils.remove_entry(config.version_file) if File.exist? config.version_file\r\n    end","code-length":123,"reference":"Clean up any files solr_wrapper may have downloaded","result":"Clean the instance directory.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef get_signals\r\n      all_signals = []\r\n      current = @klass\r\n      while current != Qt::Base\r\n        meta = Meta[current.name]\r\n        if !meta.nil?\r\n          all_signals.concat meta.signals\r\n        end\r\n        current = current.superclass\r\n      end\r\n      return all_signals\r\n    end","code-length":96,"reference":"Return a list of signals, including inherited ones","result":"Get the signals.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef +(other)\r\n      if Duration === other\r\n        Duration.new(value + other.value, @parts + other.parts)\r\n      else\r\n        Duration.new(value + other, @parts + [[:seconds, other]])\r\n      end\r\n    end","code-length":74,"reference":"Adds another Duration or a Numeric to this Duration.","result":"Create a new Duration.","score":[0.1088,0.1176]}
{"code":"# is used to<extra_id_0>\r\ndef days_to_week_start(start_day = Date.beginning_of_week)\r\n      start_day_number = DAYS_INTO_WEEK[start_day]\r\n      current_day_number = wday != 0 ? wday - 1 : 6\r\n      (current_day_number - start_day_number) % 7\r\n    end","code-length":93,"reference":"Returns the number of days to the start of the week on the given day.","result":"Calculate the days to week start.","score":[0.0724,0.2238]}
{"code":"# is used to<extra_id_0>\r\ndef reset\r\n      @width             = 0 if no_width\r\n      @render_period     = frequency == 0 ? 0 : 1.0 \/ frequency\r\n      @current           = 0\r\n      @last_render_time  = Time.now\r\n      @last_render_width = 0\r\n      @done              = false\r\n      @stopped           = false\r\n      @start_at          = Time.now\r\n      @started           = false\r\n      @tokens            = {}\r\n      @meter.clear\r\n    end","code-length":132,"reference":"Create progress bar ","result":"Reset the rendering.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef advance(progress = 1, tokens = {})\r\n      return if done?\r\n      synchronize do\r\n        emit(:progress, progress)\r\n        if progress.respond_to?(:to_hash)\r\n          tokens, progress = progress, 1\r\n        end\r\n        @start_at  = Time.now if @current.zero? && !@started\r\n        @current  += progress\r\n        @tokens    = tokens\r\n        @meter.sample(Time.now, progress)\r\n        if !no_width && @current >= total\r\n          finish && return\r\n        end\r\n        now = Time.now\r\n        return if (now - @last_render_time) < @render_period\r\n        render\r\n      end\r\n    end","code-length":186,"reference":"Advance the progress bar ","result":"Track progress.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef iterate(collection, progress = 1, &block)\r\n      update(total: collection.count * progress) unless total\r\n      progress_enum = Enumerator.new do |iter|\r\n        collection.each do |elem|\r\n          advance(progress)\r\n          iter.yield(elem)\r\n        end\r\n      end\r\n      block_given? ? progress_enum.each(&block) : progress_enum\r\n    end","code-length":110,"reference":"Iterate over collection either yielding computation to block or provided Enumerator.","result":"Iterate over a collection.","score":[0.0785,0.182]}
{"code":"# is used to<extra_id_0>\r\ndef update(options = {})\r\n      synchronize do\r\n        options.each do |name, val|\r\n          if @configuration.respond_to?(\"#{name}=\")\r\n            @configuration.public_send(\"#{name}=\", val)\r\n          end\r\n        end\r\n      end\r\n    end","code-length":83,"reference":"Update configuration options for this bar ","result":"Update the configuration.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef render\r\n      return if done?\r\n      if hide_cursor && @last_render_width == 0 && !(@current >= total)\r\n        write(TTY::Cursor.hide)\r\n      end\r\n      if @multibar\r\n        characters_in = @multibar.line_inset(self)\r\n        update(inset: self.class.display_columns(characters_in))\r\n      end\r\n      formatted = @formatter.decorate(self, @format)\r\n      @tokens.each do |token, val|\r\n        formatted = formatted.gsub(\":#{token}\", val)\r\n      end\r\n      padded = padout(formatted)\r\n      write(padded, true)\r\n      @last_render_time  = Time.now\r\n      @last_render_width = self.class.display_columns(formatted)\r\n    end","code-length":215,"reference":"Render progress to the output ","result":"Render the current line.","score":[0.2959,0.2041]}
{"code":"# is used to<extra_id_0>\r\ndef move_to_row\r\n      if @multibar\r\n        CURSOR_LOCK.synchronize do\r\n          if @first_render\r\n            @row = @multibar.next_row\r\n            yield if block_given?\r\n            output.print \"\\n\"\r\n            @first_render = false\r\n          else\r\n            lines_up = (@multibar.rows + 1) - @row\r\n            output.print TTY::Cursor.save\r\n            output.print TTY::Cursor.up(lines_up)\r\n            yield if block_given?\r\n            output.print TTY::Cursor.restore\r\n          end\r\n        end\r\n      else\r\n        yield if block_given?\r\n      end\r\n    end","code-length":188,"reference":"Move cursor to a row of the current bar if the bar is rendered under a multibar.","result":"Render the multiline.","score":[0.0038,0.0641]}
{"code":"# is used to<extra_id_0>\r\ndef write(data, clear_first = false)\r\n      return unless tty?\r\n      move_to_row do\r\n        output.print(TTY::Cursor.column(1)) if clear_first\r\n        characters_in = @multibar.line_inset(self) if @multibar\r\n        output.print(\"#{characters_in}#{data}\")\r\n        output.flush\r\n      end\r\n    end","code-length":108,"reference":"Write out to the output ","result":"Write to the terminal.","score":[0.3894,0.5215]}
{"code":"# is used to<extra_id_0>\r\ndef finish\r\n      return if done?\r\n      @current = total unless no_width\r\n      render\r\n      clear ? clear_line : write(\"\\n\", false)\r\n    ensure\r\n      @meter.clear\r\n      @done = true\r\n      if hide_cursor && @last_render_width != 0\r\n        write(TTY::Cursor.show, false)\r\n      end\r\n      emit(:done)\r\n    end","code-length":111,"reference":"End the progress ","result":"Mark the end of the line.","score":[0.193,0.303]}
{"code":"# is used to<extra_id_0>\r\ndef stop\r\n      if hide_cursor && @last_render_width != 0\r\n        write(TTY::Cursor.show, false)\r\n      end\r\n      return if done?\r\n      render\r\n      clear ? clear_line : write(\"\\n\", false)\r\n    ensure\r\n      @meter.clear\r\n      @stopped = true\r\n      emit(:stopped)\r\n    end","code-length":100,"reference":"Stop and cancel the progress at the current position ","result":"Stop the program.","score":[0.0657,0.119]}
{"code":"# is used to<extra_id_0>\r\ndef log(message)\r\n      sanitized_message = message.gsub(\/\\r|\\n\/, ' ')\r\n      if done?\r\n        write(sanitized_message + \"\\n\", false)\r\n        return\r\n      end\r\n      sanitized_message = padout(sanitized_message)\r\n      write(sanitized_message + \"\\n\", true)\r\n      render\r\n    end","code-length":104,"reference":"Log message above the current progress bar ","result":"Log the message.","score":[0.128,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef padout(message)\r\n      message_length = self.class.display_columns(message)\r\n      if @last_render_width > message_length\r\n        remaining_width = @last_render_width - message_length\r\n        message += ' ' * remaining_width\r\n      end\r\n      message\r\n    end","code-length":86,"reference":"Pad message out with spaces ","result":"Pad out the message.","score":[0.2959,0.2041]}
{"code":"# is used to<extra_id_0>\r\ndef lock_exclusively!(max_run_time, worker = worker_name)\r\n      now = self.class.db_time_now\r\n      affected_rows = if locked_by != worker\r\n        self.class.update_all([\"locked_at = ?, locked_by = ?\", now, worker], [\"id = ? and (locked_at is null or locked_at < ?)\", id, (now - max_run_time.to_i)])\r\n      else\r\n        self.class.update_all([\"locked_at = ?\", now], [\"id = ? and locked_by = ?\", id, worker])\r\n      end\r\n      if affected_rows == 1\r\n        self.locked_at    = now\r\n        self.locked_by    = worker\r\n        return true\r\n      else\r\n        return false\r\n      end\r\n    end","code-length":215,"reference":"Lock this job for this worker.","result":"Lock a job.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef setup_tracery dir_path\r\n      raise \"Provided path not a directory\" unless Dir.exist?(dir_path)\r\n      @grammar = {}\r\n      Dir.open(dir_path) do |dir|\r\n        dir.each do |file|\r\n          next if file =~ \/^\\.\\.?$\/\r\n          @grammar[file.split('.').first] =\r\n            createGrammar(JSON.parse(File.read(\"#{dir_path}\/#{file}\")))\r\n        end\r\n      end\r\n      unless @grammar['reply'].nil?\r\n        on_reply { |bot|\r\n          bot.reply_with_mentions('d\r\n    end","code-length":167,"reference":"loads all of our tracery files into our +files+ hash if a file is named 'default' then we load that into +grammar+ ","result":"Setup tracers.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef expand_and_post(text, *options)\r\n      opts = Hash[*options]\r\n      rules = opts.fetch(:rules, 'default')\r\n      actually_post(@grammar[rules].flatten(text),\r\n                    **opts.reject {|k|\r\n                      k == :rules\r\n                    })\r\n    end","code-length":87,"reference":"a shortcut fuction for expanding text with tracery before posting ","result":"Expand and post text.","score":[0,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef run_interact\r\n      @streamer.user do |update|\r\n        if update.kind_of? Mastodon::Notification\r\n                    case update.type\r\n                        when 'mention'\r\n            update.status.class.module_eval { alias_method :content, :strip } if @strip_html\r\n            store_mention_data update.status\r\n            @on_reply.call(self, update.status) unless @on_reply.nil?\r\n                      when 'reblog'\r\n            @on_boost.call(self, update) unless @on_boost.nil?\r\n                      when 'favourite'\r\n            @on_fave.call(self, update) unless @on_fave.nil?\r\n                      when 'follow'\r\n            @on_follow.call(self, update) unless @on_follow.nil?\r\n                      end\r\n        end\r\n      end\r\n    end","code-length":228,"reference":"Starts a loop that checks for any notifications for the authenticated user, running the appropriate stored proc when needed","result":"Run the interacting process.","score":[0.0075,0.1071]}
{"code":"# is used to<extra_id_0>\r\ndef reply(text, *options)\r\n      options = Hash[*options]\r\n            post(\"@#{@mention_data[:account].acct} #{text}\",\r\n           **@mention_data.merge(options).reject { |k|\r\n             k == :mentions or k == :account\r\n           })\r\n    end","code-length":89,"reference":"Replies to the last mention the bot recieved using the mention's   visibility and spoiler with +text+","result":"Send a message to the recipient.","score":[0.0516,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef run_reply\r\n      @streamer.user do |update|\r\n        next unless update.kind_of? Mastodon::Notification and update.type == 'mention'\r\n        update.status.class.module_eval { alias_method :content, :strip } if @strip_html\r\n        store_mention_data update.status\r\n                if block_given?\r\n          yield(self, update.status)\r\n        else\r\n          @on_reply.call(self, update.status)\r\n        end\r\n      end\r\n    end","code-length":141,"reference":"Starts a loop that checks for mentions from the authenticated user account running a supplied block or, if a block is not provided, on_reply","result":"Run the reply.","score":[0.0004,0.0457]}
{"code":"# is used to<extra_id_0>\r\ndef store_mention_data(mention)\r\n      @mention_data = {\r\n        reply_id: mention.id,\r\n        visibility: mention.visibility,\r\n        spoiler: mention.spoiler_text,\r\n        hide_media: mention.sensitive?,\r\n        mentions: mention.mentions,\r\n        account: mention.account\r\n      }\r\n    end","code-length":102,"reference":"Stores select data about a post into a hash for later use","result":"Store the mention data.","score":[0,0.0446]}
{"code":"# is used to<extra_id_0>\r\ndef setup_streaming\r\n      stream_uri = @client.instance()\r\n                     .attributes['urls']['streaming_api'].gsub(\/^wss?\/, 'https')\r\n      @streamer = Mastodon::Streaming::Client.new(base_url: stream_uri,\r\n                                                  bearer_token: ENV['TOKEN'])\r\n    end","code-length":93,"reference":"Creates the stream client","result":"Setup streaming.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef parse_service_name(path)\r\n      parts = Pathname.new(path).each_filename.to_a.reverse!\r\n      parts.find {|seg| !COMMON_SEGMENTS[seg] } || parts.first\r\n    end","code-length":68,"reference":"Parse the service name from a path.","result":"Parse the service name.","score":[0.3108,0.4395]}
{"code":"# is used to<extra_id_0>\r\ndef connect\r\n      start_time = Time.now\r\n      retries    = 0\r\n      close\r\n      begin\r\n        connect_to_server(servers, policy)\r\n        logger.info(message: \"Connected to #{address}\", duration: (Time.now - start_time) * 1000) if respond_to?(:logger)\r\n      rescue ConnectionFailure, ConnectionTimeout => exception\r\n        cause = exception.is_a?(ConnectionTimeout) ? exception : exception.cause\r\n        if self.class.reconnect_on_errors.include?(cause.class) && (retries < connect_retry_count.to_i)\r\n          retries += 1\r\n          logger.warn \"\r\n          sleep(connect_retry_interval)\r\n          retry\r\n        else\r\n          message = \"\r\n          logger.benchmark_error(message, exception: exception, duration: (Time.now - start_time)) if respond_to?(:logger)\r\n          raise ConnectionFailure.new(message, address.to_s, cause)\r\n        end\r\n      end\r\n    end","code-length":258,"reference":"Create a new TCP Client connection","result":"Connect to the server.","score":[0,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef write(data, timeout = write_timeout)\r\n      data = data.to_s\r\n      if respond_to?(:logger)\r\n        payload        = {timeout: timeout}\r\n        payload[:data] = data if logger.trace?\r\n        logger.benchmark_debug('\r\n          payload[:bytes] = socket_write(data, timeout)\r\n        end\r\n      else\r\n        socket_write(data, timeout)\r\n      end\r\n    rescue Exception => exc\r\n      close if close_on_error\r\n      raise exc\r\n    end","code-length":141,"reference":"Write data to the server","result":"Write data to the socket.","score":[0.7521,0.7938]}
{"code":"# is used to<extra_id_0>\r\ndef read(length, buffer = nil, timeout = read_timeout)\r\n      if respond_to?(:logger)\r\n        payload = {bytes: length, timeout: timeout}\r\n        logger.benchmark_debug('\r\n          data           = socket_read(length, buffer, timeout)\r\n          payload[:data] = data if logger.trace?\r\n          data\r\n        end\r\n      else\r\n        socket_read(length, buffer, timeout)\r\n      end\r\n    rescue Exception => exc\r\n      close if close_on_error\r\n      raise exc\r\n    end","code-length":144,"reference":"Returns a response from the server","result":"Read from the socket.","score":[0.274,0.3233]}
{"code":"# is used to<extra_id_0>\r\ndef close\r\n      socket.close if socket && !socket.closed?\r\n      @socket  = nil\r\n      @address = nil\r\n      true\r\n    rescue IOError => exception\r\n      logger.warn \"IOError when attempting to close socket: #{exception.class}: #{exception.message}\" if respond_to?(:logger)\r\n      false\r\n    end","code-length":92,"reference":"Close the socket only if it is not already closed","result":"Close the socket.","score":[0.056,0.2016]}
{"code":"# is used to<extra_id_0>\r\ndef alive?\r\n      return false if socket.nil? || closed?\r\n      if IO.select([socket], nil, nil, 0)\r\n        !socket.eof? rescue false\r\n      else\r\n        true\r\n      end\r\n    rescue IOError\r\n      false\r\n    end","code-length":76,"reference":"Returns whether the connection to the server is alive","result":"Check if the socket is alive.","score":[0.1392,0.1149]}
{"code":"# is used to<extra_id_0>\r\ndef socket_connect(socket, address, timeout)\r\n      socket_address = Socket.pack_sockaddr_in(address.port, address.ip_address)\r\n      return socket.connect(socket_address) if timeout == -1\r\n      deadline = Time.now.utc + timeout\r\n      begin\r\n        non_blocking(socket, deadline) { socket.connect_nonblock(socket_address) }\r\n      rescue Errno::EISCONN\r\n      rescue NonBlockingTimeout\r\n        raise ConnectionTimeout.new(\"Timed out after #{timeout} seconds trying to connect to #{address}\")\r\n      rescue SystemCallError, IOError => exception\r\n        message = \"\r\n        logger.error message if respond_to?(:logger)\r\n        raise ConnectionFailure.new(message, address.to_s, exception)\r\n      end\r\n    end","code-length":202,"reference":"Connect to server","result":"Connect to a socket.","score":[0.4518,0.6048]}
{"code":"# is used to<extra_id_0>\r\ndef socket_write(data, timeout)\r\n      if timeout < 0\r\n        socket.write(data)\r\n      else\r\n        deadline = Time.now.utc + timeout\r\n        length = data.bytesize\r\n        total_count = 0\r\n        non_blocking(socket, deadline) do\r\n          loop do\r\n            begin\r\n              count = socket.write_nonblock(data)\r\n            rescue Errno::EWOULDBLOCK\r\n              retry\r\n            end\r\n            total_count += count\r\n            return total_count if total_count >= length\r\n            data = data.byteslice(count..-1)\r\n          end\r\n        end\r\n      end\r\n    rescue NonBlockingTimeout\r\n      logger.warn \"\r\n      raise WriteTimeout.new(\"Timed out after #{timeout} seconds trying to write to #{address}\")\r\n    rescue SystemCallError, IOError => exception\r\n      message = \"\r\n      logger.error message if respond_to?(:logger)\r\n      raise ConnectionFailure.new(message, address.to_s, exception)\r\n    end","code-length":262,"reference":"Write to the socket","result":"Write to a socket.","score":[0.4518,0.4688]}
{"code":"# is used to<extra_id_0>\r\ndef ssl_connect(socket, address, timeout)\r\n      ssl_context = OpenSSL::SSL::SSLContext.new\r\n      ssl_context.set_params(ssl.is_a?(Hash) ? ssl : {})\r\n      ssl_socket            = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)\r\n      ssl_socket.hostname   = address.host_name\r\n      ssl_socket.sync_close = true\r\n      begin\r\n        if timeout == -1\r\n          ssl_socket.connect\r\n        else\r\n          deadline = Time.now.utc + timeout\r\n          begin\r\n            non_blocking(socket, deadline) { ssl_socket.connect_nonblock }\r\n          rescue Errno::EISCONN\r\n          rescue NonBlockingTimeout\r\n            raise ConnectionTimeout.new(\"SSL handshake Timed out after #{timeout} seconds trying to connect to #{address.to_s}\")\r\n          end\r\n        end\r\n      rescue SystemCallError, OpenSSL::SSL::SSLError, IOError => exception\r\n        message = \"\r\n        logger.error message if respond_to?(:logger)\r\n        raise ConnectionFailure.new(message, address.to_s, exception)\r\n      end\r\n      ssl_verify(ssl_socket, address) if ssl_context.verify_mode != OpenSSL::SSL::VERIFY_NONE\r\n      ssl_socket\r\n    end","code-length":326,"reference":"Try connecting to a single server","result":"Verify the SSL certificate.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef party_mode new_master = nil\r\n      return nil unless speakers.length > 1\r\n      new_master = find_party_master if new_master.nil?\r\n      party_over\r\n      speakers.each do |slave|\r\n        next if slave.uid == new_master.uid\r\n        slave.join new_master\r\n      end\r\n      rescan @topology\r\n    end","code-length":105,"reference":"Party Mode!  Join all speakers into a single group.","result":"Set the party mode.","score":[0,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef discover\r\n      result = SSDP::Consumer.new.search(service: 'urn:schemas-upnp-org:device:ZonePlayer:1', first_only: true, timeout: @timeout, filter: lambda {|r| r[:params][\"ST\"].match(\/ZonePlayer\/) })\r\n      @first_device_ip = result[:address]\r\n    end","code-length":96,"reference":"Look for Sonos devices on the network and return the first IP address found ","result":"Discover the first device.","score":[0.0371,0.1442]}
{"code":"# is used to<extra_id_0>\r\ndef topology\r\n      self.discover unless @first_device_ip\r\n      return [] unless @first_device_ip\r\n      doc = Nokogiri::XML(open(\"http:\/\/#{@first_device_ip}:#{Sonos::PORT}\/status\/topology\"))\r\n      doc.xpath('\/\/ZonePlayers\/ZonePlayer').map do |node|\r\n        TopologyNode.new(node)\r\n      end\r\n    end","code-length":110,"reference":"Find all of the Sonos devices on the network ","result":"Determine the nodes of the topology.","score":[0.1833,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef find(id)\r\n      response = RestClient.get(\"#{@type.Resource}\/#{id}\")\r\n      singular_resource = @type.Resource[0...-1]\r\n      if response.body[singular_resource].nil?\r\n        raise ArgumentError, 'Resource not found'\r\n      end\r\n            type.new.from_json(response.body[singular_resource].to_json)\r\n    end","code-length":105,"reference":"Find a single resource by the resource id ","result":"Find a resource.","score":[0.109,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef all\r\n      list = []\r\n      page = 1\r\n      fetch_all = true\r\n      if @query.has_key?(:page)\r\n        page = @query[:page]\r\n        fetch_all = false\r\n      end\r\n            while true\r\n        response = RestClient.get(@type.Resource, @query)\r\n        data = response.body[@type.Resource]      \r\n        if !data.empty?\r\n          data.each {|item| list << @type.new.from_json(item.to_json)}\r\n                    if !fetch_all\r\n            break\r\n          else\r\n            where(page: page += 1)\r\n          end\r\n        else\r\n          break\r\n        end\r\n      end\r\n      return list\r\n    end","code-length":195,"reference":"Get all resources from a query by paging through data","result":"Fetch all items.","score":[0.0396,0.2016]}
{"code":"# is used to<extra_id_0>\r\ndef validate(form)\r\n      property = attributes.first\r\nord.send(\"#{property}=\", form.send(property))\r\n      @klass = record.classcord).tap do |res|\r\n        form.errors.add(property, record.errors.first.last) if record.errors.present?\r\n      end\r\n    end","code-length":89,"reference":"when calling validates it should create the Vali instance already and set ","result":"Validate the form.","score":[0.0203,0.0901]}
{"code":"# is used to<extra_id_0>\r\ndef validates(*args, &block)\r\n      validation(name: :default, inherit: true) { validates *args, &block }\r\n    end","code-length":43,"reference":"moved from reform as not applicable to dry","result":"Validate the form.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef update_xml(xml, value)\r\n      wrap(xml).tap do |xml|\r\n        if content?\r\n          add(xml, value)\r\n        elsif name?\r\n          xml.name = value\r\n        elsif array?\r\n          value.each do |v|\r\n            add(XML.add_node(xml, name), v)\r\n          end\r\n        else\r\n          add(XML.add_node(xml, name), value)\r\n        end\r\n      end\r\n    end","code-length":129,"reference":"Updates the text in the given _xml_ block to the _value_ provided.","result":"Update the xml.","score":[0.0203,0.0901]}
{"code":"# is used to<extra_id_0>\r\ndef ipmt(rate, per, nper, pv, fv = 0, end_or_beginning = 0)\r\n      pmt = self.pmt(rate, nper, pv, fv, end_or_beginning)\r\n      fv = self.fv(rate, (per - 1), pmt, pv, end_or_beginning) * rate\r\n      temp = end_or_beginning == 1 ? fv \/ (1 + rate) : fv\r\n      (per == 1 && end_or_beginning == 1) ? 0.0 : temp\r\n    end","code-length":142,"reference":"Calculates the payment on interest for an investment based on constant-amount periodic payments and a constant interest rate.","result":"Calculate the IPMT.","score":[0.0028,0.1136]}
{"code":"# is used to<extra_id_0>\r\ndef nper(rate, pmt, pv, fv = 0, end_or_beginning = 0)\r\n      z = pmt * (1 + rate * end_or_beginning) \/ rate\r\n      temp = Math.log((-fv + z) \/ (pv + z))\r\n      temp \/ Math.log(1 + rate)\r\n    end","code-length":92,"reference":"Calculates the number of payment periods for an investment based on constant-amount periodic payments and a constant interest rate.","result":"Calculate the nper.","score":[0.002,0.1078]}
{"code":"# is used to<extra_id_0>\r\ndef pmt(rate, nper, pv, fv = 0, end_or_beginning = 0)\r\n      temp = (1 + rate) ** nper\r\n      fact = (1 + rate * end_or_beginning) * (temp - 1) \/ rate\r\n      -(fv + pv * temp) \/ fact\r\n    end","code-length":88,"reference":"Calculates the periodic payment for an annuity investment based on constant-amount periodic payments and a constant interest rate.","result":"Calculate the pmt.","score":[0.0028,0.1136]}
{"code":"# is used to<extra_id_0>\r\ndef rate(nper, pmt, pv, fv = 0, end_or_beginning = 0, rate_guess = 0.10)\r\n      guess = rate_guess\r\n      tolerancy = 1e-6\r\n      close = false\r\n      begin\r\n        temp = newton_iter(guess, nper, pmt, pv, fv, end_or_beginning)\r\n        next_guess = (guess - temp).round(20)\r\n        diff = (next_guess - guess).abs\r\n        close = diff < tolerancy\r\n        guess = next_guess\r\n      end while !close\r\n      next_guess\r\n    end","code-length":163,"reference":"Calculates the interest rate of an annuity investment based on constant-amount periodic payments and the assumption of a constant interest rate.","result":"Calculate the rate.","score":[0.0012,0.0781]}
{"code":"# is used to<extra_id_0>\r\ndef npv(discount, cashflows)\r\n      total = 0\r\n      cashflows.each_with_index do |cashflow, index|\r\n        total += (cashflow.to_f \/ (1 + discount.to_f) ** (index + 1))\r\n      end\r\n      total\r\n    end","code-length":86,"reference":"Calculates the net present value of an investment based on a series of periodic cash flows and a discount rate.","result":"Calculate the total value of a given quantity.","score":[0.0521,0.2268]}
{"code":"# is used to<extra_id_0>\r\ndef irr(values)\r\n      func = Helpers::IrrHelper.new(values)\r\n      guess = [ func.eps ]\r\n      nlsolve( func, guess)\r\n      guess[0]\r\n    end","code-length":61,"reference":"Calculates the internal rate of return on an investment based on a series of periodic cash flows.","result":"Define the method.","score":[0.0038,0.0321]}
{"code":"# is used to<extra_id_0>\r\ndef newton_iter(r, n, p, x, y, w)\r\n      t1 = (r+1)**n\r\n      t2 = (r+1)**(n-1)\r\n      ((y + t1*x + p*(t1 - 1)*(r*w + 1)\/r) \/ (n*t2*x - p*(t1 - 1)*(r*w + 1)\/(r**2) + n*p*t2*(r*w + 1)\/r + p*(t1 - 1)*w\/r))\r\n    end","code-length":143,"reference":"This method was borrowed from the NumPy rate formula which was generated by Sage","result":"Iterate over the newton iteration.","score":[0.0397,0.0382]}
{"code":"# is used to<extra_id_0>\r\ndef event_summary(trim_at = 100)\r\n      summary = @event['check']['notification'] || @event['check']['description']\r\n      if summary.nil?\r\n        source = @event['check']['source'] || @event['client']['name']\r\n        event_context = [source, @event['check']['name']].join('\/')\r\n        output = @event['check']['output'].chomp\r\n        output = output.length > trim_at ? output[0..trim_at] + '...' : output\r\n        summary = [event_context, output].join(' : ')\r\n      end\r\n      summary\r\n    end","code-length":157,"reference":"Helpers and filters.","result":"Generate the event summary.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef load\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t@io.rewind\r\n\t\t\theader_block = @io.read 512\r\n\t\t\t@header = Header.new header_block\r\n\t\t\t\r\n\t\t\t@bbat = AllocationTable::Big.new self\r\n\t\t\tbbat_chain = header_block[Header::SIZE..-1].unpack 'V*'\r\n\t\t\tmbat_block = @header.mbat_start\r\n\t\t\t@header.num_mbat.times do\r\n\t\t\t\tblocks = @bbat.read([mbat_block]).unpack 'V*'\r\n\t\t\t\tmbat_block = blocks.pop\r\n\t\t\t\tbbat_chain += blocks\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\t@bbat.load @bbat.read(bbat_chain[0, @header.num_bat])\r\n\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t@dirents = @bbat.read(@header.dirent_start).to_enum(:each_chunk, Dirent::SIZE).\r\n\t\t\t\tmap { |str| Dirent.new self, str }\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tclass << @dirents\r\n\t\t\t\tdef to_tree idx=0\r\n\t\t\t\t\treturn [] if idx == Dirent::EOT\r\n\t\t\t\t\td = self[idx]\r\n\t\t\t\t\tto_tree(d.child).each { |child| d << child }\r\n\t\t\t\t\traise FormatError, \"directory #{d.inspect} used twice\" if d.idx\r\n\t\t\t\t\td.idx = idx\r\n\t\t\t\t\tto_tree(d.prev) + [d] + to_tree(d.next)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\t\t\t@root = @dirents.to_tree.first\r\n\t\t\t@dirents.reject! { |d| d.type_id == 0 }\r\n\t\t\t\t\t\t\r\n\t\t\t\r\n\t\t\tunused = @dirents.reject(&:idx).length\r\n\t\t\tLog.warn \"#{unused} unused directories\" if unused > 0\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t@sb_file = RangesIOResizeable.new @bbat, :first_block => @root.first_block, :size => @root.size\r\n\t\t\t@sbat = AllocationTable::Small.new self\r\n\t\t\t@sbat.load @bbat.read(@header.sbat_start)\r\n\t\tend","code-length":585,"reference":"load document from file.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef repack temp=:file\r\n\t\t\tcase temp\r\n\t\t\twhen :file\r\n\t\t\t\tTempfile.open 'ole-repack' do |io|\r\n\t\t\t\t\tio.binmode\r\n\t\t\t\t\trepack_using_io io\r\n\t\t\t\tend\r\n\t\t\twhen :mem;  StringIO.open(''.dup, &method(:repack_using_io))\r\n\t\t\telse raise ArgumentError, \"unknown temp backing #{temp.inspect}\"\r\n\t\t\tend\r\n\t\tend","code-length":123,"reference":"could be useful with mis-behaving ole documents. or to just clean them up.","result":"Repack the file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef load_relation(relationship, position = nil)\r\n      if objects = @resource.dig(\"_embedded\", relationship)\r\n        location = position ? objects[position] : objects\r\n        begin\r\n          WpApiClient::Collection.new(location)\r\n        rescue WpApiClient::ErrorResponse\r\n          load_from_links(relationship, position)\r\n        end\r\n      else\r\n        load_from_links(relationship, position)\r\n      end\r\n    end","code-length":119,"reference":"try to load an embedded object; call out to the API if not","result":"Load a relation.","score":[0,0.0417]}
{"code":"# is used to<extra_id_0>\r\ndef native_representation_of(response_body)\r\n      if response_body.is_a? Array\r\n        WpApiClient::Collection.new(response_body, @headers)\r\n      else\r\n        WpApiClient::Entities::Base.build(response_body)\r\n      end\r\n    end","code-length":82,"reference":"Take the API response and figure out what it is","result":"Create the native representation of the response.","score":[0.1052,0.0515]}
{"code":"# is used to<extra_id_0>\r\ndef call_func(method:, params: [], tx: {})\r\n      data, output_types = function_data_with_ot(method, *params)\r\n      resp = @rpc.call_rpc(:call, params: [tx.merge(data: data, to: address), \"latest\"])\r\n      result = resp[\"result\"]\r\n      data = [Utils.remove_hex_prefix(result)].pack(\"H*\")\r\n      return if data.nil?\r\n      re = decode_abi output_types, data\r\n      re.length == 1 ? re.first : re\r\n    end","code-length":151,"reference":"call contract functions by rpc `call` method ","result":"Call a function.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef send_func(tx:, private_key:, method:, params: [])\r\n      data, _output_types = function_data_with_ot(method, *params)\r\n      transaction = if tx.is_a?(Hash)\r\n                      Transaction.from_hash(tx)\r\n                    else\r\n                      tx\r\n                    end\r\n      transaction.data = data\r\n      resp = @rpc.send_transaction(transaction, private_key)\r\n      resp&.dig(\"result\")\r\n    end","code-length":130,"reference":"call contract functions by sendRawTransaction ","result":"Send a function to a transaction.","score":[0,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef parse_url\r\n      uri = URI.parse(@url)\r\n      @host = uri.host\r\n      @port = uri.port\r\n      @scheme = uri.scheme\r\n    end","code-length":55,"reference":"parse url to host, port and scheme","result":"Parse the url.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef call_rpc(method, jsonrpc: DEFAULT_JSONRPC, params: DEFAULT_PARAMS, id: DEFAULT_ID)\r\n      conn.post(\"\/\", rpc_params(method, jsonrpc: jsonrpc, params: params, id: id))\r\n    end","code-length":66,"reference":"wrapper for call rpc method ","result":"Call RPCs.","score":[0,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef rpc_params(method, jsonrpc: DEFAULT_JSONRPC, params: DEFAULT_PARAMS, id: DEFAULT_ID)\r\n      {\r\n        jsonrpc: jsonrpc,\r\n        id: id,\r\n        method: method,\r\n        params: params\r\n      }.to_json\r\n    end","code-length":78,"reference":"wrapper for rpc params ","result":"Generate the rpc_params method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef conn\r\n      Faraday.new(url: url) do |faraday|\r\n        faraday.headers[\"Content-Type\"] = \"application\/json\"\r\n        faraday.request  :url_encoded\r\n        faraday.adapter  Faraday.default_adapter\r\n      end\r\n    end","code-length":88,"reference":"wrapper faraday object with CITA URL and Content-Type ","result":"Connect to the server.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef transfer(to:, private_key:, value:, quota: 30_000)\r\n      valid_until_block = block_number[\"result\"].hex + 88\r\n      meta_data = get_meta_data(\"latest\")[\"result\"]\r\n      version = meta_data[\"version\"]\r\n      chain_id = if version.zero?\r\n                   meta_data[\"chainId\"]\r\n                 elsif version == 1\r\n                   meta_data[\"chainIdV1\"]\r\n                 end\r\n      transaction = Transaction.new(nonce: Utils.nonce, valid_until_block: valid_until_block, chain_id: chain_id, to: to, value: value, quota: quota, version: version)\r\n      send_transaction(transaction, private_key)\r\n    end","code-length":190,"reference":"easy to transfer tokens ","result":"Transfer a value to a private key.","score":[0.1615,0.2326]}
{"code":"# is used to<extra_id_0>\r\ndef replace(new)\r\n    if String === new\r\n      @data.replace(JSON.parse(new))\r\n    else\r\n      @data.replace(new)\r\n    end\r\n  end","code-length":57,"reference":"Replace the current storage with the given one.","result":"Replace the data.","score":[0.109,0.1333]}
{"code":"# is used to<extra_id_0>\r\ndef to_json\r\n    io = StringIO.new(\"{\")\r\n    io << JSON.create_id.to_json << \":\" << self.class.name.to_json << \",\"\r\n    @data.each {|key, value|\r\n      io << key.to_json.to_s << \":\" << value.to_json << \",\"\r\n    }\r\n    io.seek(-1, IO::SEEK_CUR)\r\n    io << \"}\"\r\n    io.string\r\n  end","code-length":125,"reference":"Convert the storage to JSON.","result":"Serialize the object.","score":[0.2096,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef time(label, &block)\r\n    raise ArgumentError, \"no block given\" unless block\r\n    `\r\n    begin\r\n      if block.arity == 0\r\n        instance_exec(&block)\r\n      else\r\n        block.call(self)\r\n      end\r\n    ensure\r\n      `\r\n    end\r\n  end","code-length":90,"reference":"Time the given block with the given label.","result":"Format the time.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef group(*args, &block)\r\n    raise ArgumentError, \"no block given\" unless block\r\n    `  if block.arity == 0\r\n        instance_exec(&block)\r\n      else\r\n        block.call(self)\r\n      end\r\n    ensure\r\n      `\r\n    end\r\n  end","code-length":84,"reference":"Group the given block.","result":"Define groups.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef group!(*args, &block)\r\n    return unless block_given?\r\n    `  if block.arity == 0\r\n        instance_exec(&block)\r\n      else\r\n        block.call(self)\r\n      end\r\n    ensure\r\n      `\r\n    end\r\n  end","code-length":81,"reference":"Group the given block but collapse it.","result":"Define groups.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef authenticate!\r\n      options = authentication_handler.call(self, @options)\r\n      @options.merge!(options)\r\n      client.config.soap_header = soap_headers\r\n    end","code-length":57,"reference":"Internal Calls the authentication handler, which should set ","result":"Authenticate.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef new_with_uuid(klass, uuid)\r\n      if klass.is_a?(String)\r\n        klass = Object.const_get(klass)\r\n      end\r\n      object = klass.new(self, uuid)\r\n      object.initialize_defaults\r\n      object\r\n    end","code-length":79,"reference":"Creates a new object with given UUID.","result":"Create a new object.","score":[0.2134,0.4395]}
{"code":"# is used to<extra_id_0>\r\ndef new_reference_with_uuid(path, uuid, source_tree = :group)\r\n      path = Pathname.new(path)\r\n      ref = self.project.new_with_uuid(PBXFileReference, uuid)\r\n      self.children << ref\r\n      GroupableHelper.set_path_with_source_tree(ref, path, source_tree)\r\n      ref.set_last_known_file_type\r\n      if ref.path.include?('\/')\r\n        ref.name = ref.path.split('\/').last\r\n      end\r\n      if File.extname(ref.path).downcase == '.framework'\r\n        ref.include_in_index = nil\r\n      end\r\n      ref\r\n    end","code-length":186,"reference":"Creates a file reference with given UUID.","result":"Create a new file reference.","score":[0.1915,0.3758]}
{"code":"# is used to<extra_id_0>\r\ndef add_file_reference_with_uuid(file_ref, uuid, avoid_duplicates = false)\r\n      if avoid_duplicates && existing = build_file(file_ref)\r\n        existing\r\n      else\r\n        build_file = project.new_with_uuid(PBXBuildFile, uuid)\r\n        build_file.file_ref = file_ref\r\n        files.insert(0, build_file)\r\n        build_file\r\n      end\r\n    end","code-length":121,"reference":"Adds the file reference with given UUID.","result":"Add a file reference to a project.","score":[0.2284,0.3651]}
{"code":"# is used to<extra_id_0>\r\ndef remove_seeds\r\n      removings = self.locks.keys - self.seeds.keys\r\n      removings.each do |name|\r\n        say \"Removing #{name} (#{self.locks[name].version})\".red\r\n        dirname = File.join(self.root_path, \"Seeds\", name)\r\n        FileUtils.rm_rf(dirname)\r\n      end\r\n    end","code-length":103,"reference":"Removes disused seeds.","result":"Remove seeds.","score":[0.3033,0.3448]}
{"code":"# is used to<extra_id_0>\r\ndef configure_phase\r\n      self.project.targets.each do |target|\r\n        begin\r\n          phase = target.sources_build_phase\r\n          resource_phase = target.resources_build_phase\r\n          next unless phase\r\n        rescue NoMethodError\r\n          next\r\n        end\r\n        phase.files_references.each do |file|\r\n          begin\r\n            file.real_path\r\n          rescue\r\n            phase.files.each do |build_file|\r\n              phase.files.delete(build_file) if build_file.file_ref == file\r\n            end\r\n          end\r\n        end\r\n        resource_phase.files_references.each do |file|\r\n          begin\r\n            file.real_path\r\n          rescue \r\n            resource_phase.files.each do |build_file|\r\n              resource_phase.files.delete(build_file) if build_file.file_ref == file\r\n            end\r\n          end\r\n        end\r\n        removings = []\r\n        addings = []\r\n        self.targets.keys.sort.each do |seed_name|\r\n          target_names = self.targets[seed_name]\r\n          if not target_names.include?(target.name)\r\n            removings << seed_name if not removings.include?(seed_name)\r\n          else\r\n            addings << seed_name if not addings.include?(seed_name)\r\n          end\r\n        end\r\n        self.file_references.each do |file|\r\n          removings.each do |seed_names|\r\n            next if not seed_names.include?(file.parent.name)\r\n            phase.files.each do |build_file|\r\n              phase.files.delete(build_file) if build_file.file_ref == file\r\n            end\r\n            resource_phase.files.each do |build_file|\r\n              resource_phase.files.delete(build_file) if build_file.file_ref == file\r\n            end\r\n          end\r\n          addings.each do |seed_names|\r\n            next if file.name.end_with? \".h\"\r\n            next if not seed_names.include?(file.parent.name)\r\n            uuid = Xcodeproj::uuid_with_name \"#{target.name}:#{file.name}\"\r\n            if self.valid_source_file?(file)\r\n              phase.add_file_reference_with_uuid(file, uuid, true)\r\n            else\r\n              resource_phase.add_file_reference_with_uuid(file, uuid, true)\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end","code-length":650,"reference":"Adds file references to the 'Sources Build Phase'.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef valid_source_file? filename\r\n      suffixs = [\".h\", \".c\", \".m\", \".mm\", \".swift\", \".cpp\"]\r\n      suffixs.each do |suffix|\r\n        return true if filename.name.end_with? suffix\r\n      end\r\n      return false\r\n    end","code-length":83,"reference":"Determines whether there's a source file.","result":"Check if the source file is valid.","score":[0.1615,0.082]}
{"code":"# is used to<extra_id_0>\r\ndef speller\r\n      return @speller if @speller\r\n      begin\r\n        require \"raspell\"\r\n      rescue LoadError\r\n        $stderr.puts \"ERROR: Ruby gem \\\"raspell\\\" is not installed.\"\r\n        exit 1\r\n      end\r\n      @speller = Aspell.new(\"en_US\")\r\n      @speller.suggestion_mode = Aspell::NORMAL\r\n      @speller.set_option(\"mode\", \"html\")\r\n      @speller\r\n    end","code-length":139,"reference":"create an Aspell speller object ","result":"Generate a new file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef files_to_check\r\n      files = config[\"check\"].reduce([]) { |a, e| a + Dir[e] }\r\n      config[\"ignore\"].reduce(files) { |a, e| a - Dir[e] }\r\n    end","code-length":70,"reference":"evaluate the files to check","result":"Check files.","score":[0,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef read_spell_config(file)\r\n      return {} unless File.exist?(file)\r\n      puts \"Loading config file (#{file})...\" if verbose == true\r\n      require \"yaml\"\r\n      YAML.load_file(file)\r\n    end","code-length":70,"reference":"read a Yaml config file","result":"Read spell config file.","score":[0.2488,0.2041]}
{"code":"# is used to<extra_id_0>\r\ndef report_duplicates(dict1, dict2)\r\n      duplicates = dict1 & dict2\r\n      return if duplicates.empty?\r\n      $stderr.puts \"Warning: Found dictionary duplicates in the local dictionary \" \\\r\n        \"(#{CUSTOM_SPELL_CONFIG_FILE}):\\n\"\r\n      duplicates.each { |duplicate| $stderr.puts \"  #{duplicate}\" }\r\n      $stderr.puts\r\n    end","code-length":107,"reference":"print the duplicate dictionary entries","result":"Report duplicate dictionaries.","score":[0.2096,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef config\r\n      return @config if @config\r\n      @config = read_spell_config(GLOBAL_SPELL_CONFIG_FILE)\r\n      custom_config = read_spell_config(CUSTOM_SPELL_CONFIG_FILE)\r\n      report_duplicates(config[\"dictionary\"], custom_config[\"dictionary\"].to_a)\r\n      custom_config[\"dictionary\"] = @config[\"dictionary\"] + custom_config[\"dictionary\"].to_a\r\n      custom_config[\"dictionary\"].uniq!\r\n      @config.merge!(custom_config)\r\n      @config\r\n    end","code-length":148,"reference":"return the merged global and the custom spell configs ","result":"Generate the config file.","score":[0.0915,0.1176]}
{"code":"# is used to<extra_id_0>\r\ndef check_file(file)\r\n      puts \"Checking #{file}...\" if verbose == true\r\n      lines = File.read(file).split(\"\\n\")\r\n      success = true\r\n      lines.each_with_index do |text, index|\r\n        misspelled = misspelled_on_line(text)\r\n        next if misspelled.empty?\r\n        success = false\r\n        print_misspelled(misspelled, index, text)\r\n      end\r\n      success\r\n    end","code-length":135,"reference":"check the file using the spellchecker ","result":"Check the file contents.","score":[0.274,0.2586]}
{"code":"# is used to<extra_id_0>\r\ndef check_writable(path)\r\n      raise Error, \"'#{path}' is not writable\" if path.exist? && !path.writable? || !path.parent.writable?\r\n    end","code-length":53,"reference":"If the path does not exist, it will check for the parent directory write permission ","result":"Check the writable status of a file.","score":[0.0515,0.0704]}
{"code":"# is used to<extra_id_0>\r\ndef check_option(opt)\r\n      raise Error, \"The option is not an OptBase, #{opt.class} supplied\" unless opt.is_a?(OptBase)\r\n      raise Error, \"The option #{opt.to_sym} is already used !\" if @symbols_used.include?(opt.to_sym)\r\n    end","code-length":88,"reference":"Ensures the opt given is valid ","result":"Check the option.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef post_processing\r\n      @opts.each do |opt|\r\n        raise NoRequiredOption, \"The option #{opt} is required\" if opt.required? && !@results.key?(opt.to_sym)\r\n        next if opt.required_unless.empty? || @results.key?(opt.to_sym)\r\n        fail_msg = \"One of the following options is required: #{opt}, #{opt.required_unless.join(', ')}\"\r\n        raise NoRequiredOption, fail_msg unless opt.required_unless.any? do |sym|\r\n          @results.key?(sym)\r\n        end\r\n      end\r\n    end","code-length":164,"reference":"Ensure that all required options are supplied","result":"Post-process the results.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef subdir_entities(dir = @current_dir)\r\n      Dir.glob(dir[:path].gsub(\/[*?\\\\\\[\\]{}]\/, '\\\\\\\\\\0') + '\/*').map!{|path| {path: path, time: File.mtime(path), name: File.basename(path)}}\r\n    end","code-length":84,"reference":"Conversions","result":"Create entities.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef string_to_bytes(str)\r\n      unless @e.nil? || @e == :utf8\r\n        if @e == :shift_jis\r\n          begin\r\n            str = str.gsub \/[\\\\:*?\"<>|\\uff5e]\/, '\uff1f'\r\n            str.encode! 'Shift_JIS', :invalid => :replace, :undef => :replace, :replace => '\uff1f'\r\n          rescue => e\r\n          end\r\n        end\r\n      end\r\n      [str].pack('a*')\r\n    end","code-length":144,"reference":"Create ASCII-8bits string. Also convert encoding if needed.","result":"Convert a string to a byte array.","score":[0,0.0633]}
{"code":"# is used to<extra_id_0>\r\ndef pack(files)\r\n      entities = Entity.entities_from files\r\n      return if entities.empty?\r\n      reset_state\r\n      pack_entities entities\r\n      while has_dir?\r\n        cd next_dir\r\n        pack_current_dir\r\n      end\r\n    end","code-length":78,"reference":"Compression operations","result":"Pack the files.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef pack_symlinks\r\n      reset_state\r\n      @l.each do |link|\r\n        if @w.path_exists? Entity.linked_path(link[:abs_path], File.readlink(link[:path]))\r\n          link[:name] = link[:abs_path]\r\n          pack_symbolic_link_entity link\r\n        end\r\n      end\r\n    end","code-length":101,"reference":"Pack symlinks if its link path exists in zip","result":"Pack symlinks.","score":[0.0151,0.0602]}
{"code":"# is used to<extra_id_0>\r\ndef pack_entities(entities)\r\n      entities.each do |entity|\r\n        next unless entity.is_a?(Hash) && entity[:path]\r\n        path = entity[:path]\r\n        if File.symlink? path\r\n          postpone_symlink entity\r\n        elsif File.directory? path\r\n          postpone_dir entity\r\n        elsif File.file? path\r\n          pack_file_entity entity\r\n        end\r\n      end\r\n    end","code-length":120,"reference":"Pack file entities. Directory entities are queued, not packed in this method.","result":"Pack the entities.","score":[0.0242,0.0901]}
{"code":"# is used to<extra_id_0>\r\ndef header content = nil, options = nil, html_options = nil, &block\r\n      @header = UiBibz::Ui::Core::Lists::Components::ListHeader.new content, options, html_options, &block\r\n    end","code-length":64,"reference":"Add header which is a component","result":"Create the list header.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef body content = nil, options = nil, html_options = nil, &block\r\n      @body = UiBibz::Ui::Core::Lists::Components::ListBody.new content, options, html_options, &block\r\n    end","code-length":64,"reference":"Add body which is a component","result":"Create the list body.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef td_content record, col\r\n      content = col.count ? record.send(col.data_index).count : record.send(col.data_index)\r\n      unless content.nil?\r\n        content = content.strftime(col.date_format)                    unless col.date_format.nil?\r\n        content = link_to content, action.inject_url(col.link, record) unless col.link.nil?\r\n        content = col.format.call(@store.records, record)              unless col.format.nil?\r\n      end\r\n      content = As.new(col, record, content, @options).render unless col.as.nil?\r\n      content\r\n    end","code-length":173,"reference":"Maybe create a class for td_content","result":"Render the content of the td.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef body content = nil, options = nil, html_options = nil, &block\r\n      options, content = inherit_options(content, options, block)\r\n      if is_tap(content, options)\r\n        content = (content || {}).merge(collapse: options.try(:[], :collapse), parent_collapse: @options[:parent_collapse] )\r\n        @items << UiBibz::Ui::Core::Boxes::Components::CardBody.new(content, options, html_options).tap(&block).render\r\n      else\r\n        options = (options || {}).merge(collapse: options.try(:[], :collapse), parent_collapse: @options[:parent_collapse] )\r\n        @items << UiBibz::Ui::Core::Boxes::Components::CardBody.new(content, options, html_options, &block).render\r\n      end\r\n    end","code-length":212,"reference":"Add Body div which is a component","result":"Render the card body.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef footer content = nil, options = nil, html_options = nil, &block\r\n      options, content = inherit_options(content, options, block)\r\n      @footer = UiBibz::Ui::Core::Boxes::Components::CardFooter.new(content, options, html_options, &block).render\r\n    end","code-length":84,"reference":"Add Footer which is a component","result":"Create the card footer.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef list_group content = nil, options = nil, html_options = nil, &block\r\n      @items << UiBibz::Ui::Core::Boxes::Components::CardListGroup.new(content, options, html_options).tap(&block).render\r\n    end","code-length":72,"reference":"Add List group which is a component","result":"Create a list group.","score":[0.1509,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef image content = nil, options = nil, html_options = nil, &block\r\n      @items << UiBibz::Ui::Core::Boxes::Components::CardImage.new(content, options, html_options, &block).render\r\n    end","code-length":67,"reference":"Add Image which is a component","result":"Create the image element.","score":[0,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef html content = nil, &block\r\n      if !block.nil?\r\n        context  = eval(\"self\", block.binding)\r\n        @items << context.capture(&block)\r\n      else\r\n        @items << content\r\n      end\r\n    end","code-length":72,"reference":"Add html component","result":"Create a html tag.","score":[0.3195,0.1613]}
{"code":"# is used to<extra_id_0>\r\ndef component_html_options\r\n      super.merge({\r\n        multiple:      options[:multiple],\r\n        disabled:      options[:state] == :disabled,\r\n        include_blank: options[:include_blank],\r\n        prompt:        options[:prompt]\r\n      })\r\n    end","code-length":78,"reference":"Try to put it on a line","result":"Render the component.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef nav content = nil, options = {}, html_options = nil, &block\r\n      @items << UiBibz::Ui::Core::Component.new(Nav.new(content, options).tap(&block).render, {}, html_options)\r\n    end","code-length":69,"reference":"Add nav in nav","result":"Create the nav element.","score":[0.3195,0.125]}
{"code":"# is used to<extra_id_0>\r\ndef body content = nil, options = nil, html_options = nil, &block\r\n      @body = UiBibz::Ui::Core::Notifications::Components::AlertBody.new(content, options, html_options, &block).render\r\n    end","code-length":67,"reference":"Add Body which is a component","result":"Create the body element.","score":[0,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef is_tap content, options\r\n      (content[:tap] if content.kind_of?(Hash)) || (options[:tap] unless options.nil?)\r\n    end","code-length":49,"reference":"Know if component is tapped or not","result":"Detect tap.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef component_html_data\r\n      data_target = html_options.try(:[], :data).try(:[], :target) || options.try(:delete, :target)\r\n      add_html_data(:target, data_target) unless data_target.nil?\r\n      data_controller = html_options.try(:[], :data).try(:[], :controller) || options.try(:delete, :controller)\r\n      add_html_data(:controller, data_controller) unless data_controller.nil?\r\n      data_action = html_options.try(:[], :data).try(:[], :action) || options.try(:delete, :action)\r\n      add_html_data(:action, data_action) unless data_action.nil?\r\n      data_turbolinks = html_options.try(:[], :data).try(:[], :turbolinks) || options.try(:delete, :turbolinks)\r\n      add_html_data(:turbolinks, data_turbolinks) unless data_turbolinks.nil?\r\n    end","code-length":271,"reference":"Override this method to add html data","result":"Store the component data.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add_html_data name, value = true\r\n      html_options[:data] = {} if html_options[:data].nil?\r\n      value = value.kind_of?(String) ? value.strip : value\r\n      html_options[:data].update(Hash[name, value])\r\n    end","code-length":81,"reference":"Add html data arguments","result":"Add data to html.","score":[0.3799,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef header column, name = nil\r\n      @column  = column\r\n      defaults = [translate_headers_by_defaults, translate_headers_by_defaults_active_record, translate_headers_by_active_record, header_name(name)]\r\n      @name    = UiBibz::Utils::Internationalization.new(translate_headers_by_model, default: defaults).translate\r\n      sortable? ? sortable_link : title\r\n    end","code-length":114,"reference":"header use i18n","result":"Define the header.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef column data_index = nil, options = nil, html_options = nil, &block\r\n      @columns << Column.new(data_index, options, html_options, &block)\r\n    end","code-length":56,"reference":"Add column in table","result":"Create a column.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef link content = nil, options = nil, html_options = nil, &block\r\n      @actions << UiBibz::Ui::Core::Forms::Dropdowns::Components::DropdownLink.new(content, options, html_options, &block).render\r\n    end","code-length":70,"reference":"Add link action in table","result":"Create the link element.","score":[0.2488,0.102]}
{"code":"# is used to<extra_id_0>\r\ndef engine_scaffold\r\n      FileUtils.mkdir_p(@gem_temp)\r\n      Dir.chdir(@gem_temp) do\r\n        response = Open3.capture3(\"rails plugin new #{gem} --mountable --dummy-path=site --skip-test-unit\")\r\n        if !response[1].empty?\r\n          puts response[1]\r\n          abort \"FAILED: Please be sure you have the rails gem installed with `gem install rails`\"\r\n        end\r\n        remove = %w(mailers models assets channels jobs views).map{ |f| File.join('app', f) }\r\n        remove.concat %w(cable.yml storage.yml database.yml).map{ |f| File.join('config', f) }\r\n        remove.each { |f| FileUtils.rm_rf File.join(@gem, 'site', f), secure: true }\r\n      end\r\n            engine_copy\r\n    end","code-length":228,"reference":"Create an Rails plugin engine for documentation site","result":"Create a new engine.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef engine_copy\r\n      site_path = File.join path, 'site'\r\n      FileUtils.mkdir_p site_path\r\ntemp}\/#{gem}\/site\" do\r\n        %w(app config bin config.ru Rakefile public log).each do |item|\r\n          target = File.join site_path, item\r\n          FileUtils.cp_r item, target\r\n          action_log \"create\", target.sub(@cwd+'\/','')\r\n        end\r\n      end\r\n      FileUtils.rm_rf @gem_temp\r\n    end","code-length":137,"reference":"Copy parts of the engine scaffold into site directory","result":"Copy the engine.","score":[0.0657,0.119]}
{"code":"# is used to<extra_id_0>\r\ndef make_map(item)\r\n      '(' + item.map {|key, value| key.to_s + ':' + convert_to_sass_value(value) }.join(',') + ')'\r\n    end","code-length":61,"reference":"Convert hashes to Sass map syntax","result":"Make a map.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add_files(klass)\r\n      ext = asset_ext klass\r\n      find_files(ext).map do |path|\r\n        klass.new(self, path)\r\n      end\r\n    end","code-length":58,"reference":"Find files based on class type and return an array of Classes for each file","result":"Add files to the asset.","score":[0.0325,0.0357]}
{"code":"# is used to<extra_id_0>\r\ndef find_files(ext)\r\n      files = Dir[File.join(paths[ext.to_sym], asset_glob(ext))]\r\n      files.reject { |f| File.basename(f).start_with?('_') }\r\n    end","code-length":70,"reference":"Find files by class type and extension","result":"Find files.","score":[0.041,0.0769]}
{"code":"# is used to<extra_id_0>\r\ndef dispatch(command, *args)\r\n      @threads = []\r\n      send command, *args\r\n      @threads.each { |thr| thr.join }\r\n    end","code-length":52,"reference":"Handles running threaded commands","result":"Dispatch the command.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef watch(options={})\r\n      build(options)\r\n      require 'listen'\r\n      trap(\"SIGINT\") {\r\n        puts \"\\nspark_engine watcher stopped. Have a nice day!\"\r\n        exit!\r\n      }\r\n      @threads.concat SparkEngine.load_plugin.watch(options)\r\n    end","code-length":86,"reference":"Watch assets for changes and build","result":"Watch SparkEngine.","score":[0.0677,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef load_setup( name )\r\r\n    reader = create_fixture_reader( name )\r\r\n\r\r\n    reader.each do |fixture_name|\r\r\n      load( fixture_name )\r\r\n    end\r\r\n  end","code-length":68,"reference":"lets us use match_teams_for_country etc.","result":"Load fixtures.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef avoid_duplicate_image_names(content)\r\n      nodes = content.xpath(\"\/\/draw:frame[@draw:name]\")\r\n      nodes.each_with_index do |node, i|\r\n        node.attribute('name').value = \"pic_#{i}\"\r\n      end\r\n    end","code-length":79,"reference":"replace_images newer versions of LibreOffice can't open files with duplicates image names","result":"Avoid duplicate image names.","score":[0.0432,0.1674]}
{"code":"# is used to<extra_id_0>\r\ndef scope_params\r\n        return {} if dynamic_scaffold.scope.nil?\r\n        case dynamic_scaffold.scope\r\n        when Array then\r\n          dynamic_scaffold.scope.each_with_object({}) do |val, res|\r\n            if val.is_a? Hash\r\n              val.each {|k, v| res[k] = v }\r\n            else\r\n              res[val] = params[val]\r\n            end\r\n          end\r\n        when Hash then\r\n          dynamic_scaffold.scope\r\n        end\r\n      end","code-length":140,"reference":"Get the hash of the key and value specified for the scope.","result":"Determine the scope parameters.","score":[0.0432,0.0446]}
{"code":"# is used to<extra_id_0>\r\ndef pkey_string_to_hash(pkey)\r\n        pkey.split(',').map {|v| v.split(':') }.each_with_object({}) {|v, res| res[v.first] = v.last }\r\n      end","code-length":71,"reference":"Convert pkey_string value to hash.","result":"Convert a string to a hash.","score":[0.2541,0.2941]}
{"code":"# is used to<extra_id_0>\r\ndef update_values\r\n        permitting = []\r\n        dynamic_scaffold.form.items.reject {|i| i.type?(:carrierwave_image) }.each do |item|\r\n          item.extract_parameters(permitting)\r\n        end\r\n        permitting.concat(dynamic_scaffold.form.permit_params)\r\n        dynamic_scaffold.form.items.select {|i| i.type?(:carrierwave_image) }.each do |item|\r\n          item.extract_parameters(permitting)\r\n        end\r\n        values = params\r\n                   .require(dynamic_scaffold.model.name.underscore)\r\n                   .permit(*permitting)\r\n        if dynamic_scaffold.scope && !valid_for_scope?(values)\r\n          raise DynamicScaffold::Error::InvalidOperation, \"You can update only to #{scope_params} on this scope\"\r\n        end\r\n        values\r\n      end","code-length":235,"reference":"Get paramters for update record.","result":"Update values for a dynamic scaffold.","score":[0.193,0.1961]}
{"code":"# is used to<extra_id_0>\r\ndef valid_for_scope?(update_params)\r\n        return true if dynamic_scaffold.scope_options[:changeable]\r\n        result = true\r\n        scope_params.each do |key, value|\r\n          if update_params.key?(key) && update_params[key] != value\r\n            result = false\r\n            break\r\n          end\r\n        end\r\n        result\r\n      end","code-length":106,"reference":"Check if there are inconsistent scopes in update parameters","result":"Check if the scope is valid.","score":[0.1656,0.2937]}
{"code":"# is used to<extra_id_0>\r\ndef lock(timeout: nil, &block)\r\n      ensure_exists_and_release_stale_locks!\r\n      success = @redis.with do |conn|\r\n        if timeout\r\n          !conn.blpop(available_key, timeout.to_i).nil?\r\n        else\r\n          !conn.lpop(available_key).nil?\r\n        end\r\n      end\r\n      return false unless success\r\n      token = SecureRandom.hex(16)\r\n      @tokens.push(token)\r\n      @redis.with do |conn|\r\n        conn.zadd(grabbed_key, epoch_f(conn), token)\r\n      end\r\n      return_or_yield(token, &block)\r\n    end","code-length":185,"reference":"Acquire a resource from the semaphore, if available.","result":"Acquire a lock.","score":[0.109,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef unlock(token = @tokens.pop)\r\n      return unless token\r\n      removed = false\r\n      @redis.with do |conn|\r\n        removed = conn.zrem grabbed_key, token\r\n        if removed\r\n          conn.lpush available_key, 1\r\n        end\r\n      end\r\n      removed\r\n    end","code-length":90,"reference":"Release a resource back to the semaphore.","result":"Unlock the lock.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef apply_options(options={})\r\n      options.each { |key, value| send(\"#{key}=\", value) if respond_to?(key) }\r\n      yield(self) if block_given?\r\n    end","code-length":63,"reference":"Creates a notification object.","result":"Apply options to the object.","score":[0.2403,0.122]}
{"code":"# is used to<extra_id_0>\r\ndef show!\r\n      notify_init(app_name) or raise \"notify_init failed\"\r\n      raw_ptr = notify_notification_new(summary, body, icon_path, nil)\r\n      @notification = ::FFI::AutoPointer.new(raw_ptr, method(:g_object_unref))\r\n      show\r\n    end","code-length":90,"reference":"Shows a new notification.","result":"Show the notification.","score":[0.2925,0.2564]}
{"code":"# is used to<extra_id_0>\r\ndef update(options={}, &block)\r\n      apply_options(options, &block)\r\n      if @notification\r\n        notify_notification_update(@notification, summary, body, icon_path, nil)\r\n        show\r\n      else\r\n        show!\r\n      end\r\n    end","code-length":77,"reference":"Updates a previously shown notification or creates a new one.","result":"Update the object.","score":[0,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef download\r\n      raise ArgumentError.new('url cannot be nil') if @url.nil?\r\n      raise ArgumentError.new('url cannot be empty') if @url.empty?\r\n      set_information_from_json(YoutubeDL::Runner.new(url, runner_options).run)\r\n    end","code-length":80,"reference":"Instantiate new model ","result":"Download videos.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(method, *args, &block)\r\n      value = information[method]\r\n      if value.nil?\r\n        super\r\n      else\r\n        value\r\n      end\r\n    end","code-length":59,"reference":"Redirect methods for information getting ","result":"Avoid infinite recursion.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef options_to_commands\r\n      commands = []\r\n      @options.sanitize_keys.each_paramized_key do |key, paramized_key|\r\n        if @options[key].to_s == 'true'\r\n          commands.push \"--#{paramized_key}\"\r\n        elsif @options[key].to_s == 'false'\r\n          commands.push \"--no-#{paramized_key}\"\r\n        else\r\n          commands.push \"--#{paramized_key} :#{key}\"\r\n        end\r\n      end\r\n      commands.push quoted(url)\r\n      commands.join(' ')\r\n    end","code-length":157,"reference":"Parses options and converts them to Cocaine's syntax ","result":"Generate the options to commands.","score":[0.1568,0.1299]}
{"code":"# is used to<extra_id_0>\r\ndef with(hash)\r\n      merged = Options.new(@store.merge(hash.to_h))\r\n      merged.banned_keys = @banned_keys\r\n      merged.send(:remove_banned)\r\n      merged\r\n    end","code-length":68,"reference":"Merge options with given hash, removing banned keys, and returning a new instance of Options.","result":"Create a new instance.","score":[0.0289,0.1349]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(method, *args, &_block)\r\n      remove_banned\r\n      if method.to_s.include? '='\r\n        method = method.to_s.tr('=', '').to_sym\r\n        return nil if banned? method\r\n        @store[method] = args.first\r\n      else\r\n        return nil if banned? method\r\n        @store[method]\r\n      end\r\n    end","code-length":115,"reference":"Option getting and setting using ghost methods ","result":"Call the method_missing method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef manipulate_keys!(&block)\r\n      @store.keys.each do |old_name|\r\n        new_name = block.call(old_name)\r\n        unless new_name == old_name\r\n          @store[new_name] = @store[old_name]\r\n          @store.delete(old_name)\r\n        end\r\n      end\r\n    end","code-length":101,"reference":"Calls a block to do operations on keys ","result":"Manipulate keys in the store.","score":[0.1319,0.0649]}
{"code":"# is used to<extra_id_0>\r\ndef sanitize_keys!\r\n      manipulate_keys! { |key_name| key_name.is_a?(Symbol) ? key_name : key_name.to_sym }\r\n      manipulate_keys! { |key_name| key_name.to_s.tr('-', '_').to_sym }\r\n    end","code-length":86,"reference":"Symbolizes and sanitizes keys in the option store ","result":"Sanitize the keys.","score":[0.0771,0.1333]}
{"code":"# is used to<extra_id_0>\r\ndef representer_for(format, model, options={})\r\n      options.delete(:represent_with) || self.class.represents_options.for(format, model, controller_path)\r\n    end","code-length":57,"reference":"Central entry-point for finding the appropriate representer.","result":"Represent the model.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef variable_text_field(x, y, params = {})\r\n      x = 0 unless numeric?(x)\r\n      y = 0 unless numeric?(y)\r\n      options = { height: 0.1, width: 0.1 }.merge!(params)\r\n      self.variable_fields_count += 1\r\n      label_data.push('^FO' + Integer(x * printer_dpi).to_s + ',' +\r\n                      Integer(y * printer_dpi).to_s)\r\n      if params[:orientation] == :landscape\r\n        label_data.push('^A0N,')\r\n      else\r\n        label_data.push('^A0B,')\r\n      end\r\n      label_data.push(Integer(options[:height] * printer_dpi).to_s + ',' +\r\n                      Integer(options[:width] * printer_dpi).to_s +\r\n                       '^FN' + variable_fields_count.to_s + '^FS')\r\n    end","code-length":248,"reference":"Called when the new method is invoked","result":"Create a variable text field.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef home_position(x, y)\r\n      x = 0 unless numeric?(x)\r\n      y = 0 unless numeric?(y)\r\n      label_data.push('^LH' + x.to_s + ',' + y.to_s)\r\n    end","code-length":74,"reference":"Set the home position of the label","result":"Define the home position.","score":[0.2134,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef draw_border(x, y, height, width)\r\n      return unless numeric?(height) && numeric?(width)\r\n      x = 0 unless numeric?(x)\r\n      y = 0 unless numeric?(y)\r\n      label_data.push('^FO' + Integer(x * printer_dpi).to_s + ',' +\r\n                      Integer(y * printer_dpi).to_s + '^GB' +\r\n                      Integer(height * printer_dpi).to_s +\r\n                      ',' + Integer(width * printer_dpi).to_s + ',1^FS')\r\n    end","code-length":153,"reference":"Draws a square border on dot in width","result":"Draw a border.","score":[0.0771,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef reset_barcode_fields_to_default\r\n      label_data.push('^BY' + Integer(self.barcode_default_module_width).to_s + ',' +\r\n                      Float(self.barcode_default_width_ratio).to_s + ',' +\r\n                      Integer(self.barcode_default_height).to_s)\r\n    end","code-length":96,"reference":"Some barcodes, such as QR codes may change document defaults.","result":"Reset barcode fields to default.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef draw_bar_code_39(bar_code_string, x, y, height)\r\n      return unless label_height > 0 && label_width > 0\r\n      pdf.bounding_box [x, Integer(label_width) - y - (height * pdf_dpi)],\r\n                       width: (height * pdf_dpi) do\r\n        barcode = Barby::Code39.new(bar_code_string)\r\n        barcode.annotate_pdf(pdf, height: (height * pdf_dpi))\r\n      end\r\n    end","code-length":139,"reference":"Draws the PDF bar code 39","result":"Draw barcode code 39.","score":[0.1938,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef add_field(value)\r\n      return if value.nil?\r\n      return if value.strip.empty?\r\n      self.variable_fields_count += 1\r\n      label_data.push('^FN' + variable_fields_count.to_s +\r\n                      '^FD' + value + '^FS')\r\n    end","code-length":87,"reference":"Called when the new method is invoked","result":"Add a field to the label.","score":[0.1634,0.0725]}
{"code":"# is used to<extra_id_0>\r\ndef build_slug\r\n      if localized?\r\n        begin\r\n          orig_locale = I18n.locale\r\n          all_locales.each do |target_locale|\r\n            I18n.locale = target_locale\r\n            apply_slug\r\n          end\r\n        ensure\r\n          I18n.locale = orig_locale\r\n        end\r\n      else\r\n        apply_slug\r\n      end\r\n      true\r\n    end","code-length":113,"reference":"Builds a new slug.","result":"Build the slug.","score":[0.2925,0.2564]}
{"code":"# is used to<extra_id_0>\r\ndef new_with_slugs?\r\n      if localized?\r\n        new_record? && _slugs_translations.fetch(I18n.locale.to_s, []).any?\r\n      else\r\n        new_record? && _slugs.present?\r\n      end\r\n    end","code-length":79,"reference":"Returns true if object is a new record and slugs are present","result":"Determine if a new record is created.","score":[0.185,0.3878]}
{"code":"# is used to<extra_id_0>\r\ndef persisted_with_slug_changes?\r\n      if localized?\r\n        changes = _slugs_change\r\n        return (persisted? && false) if changes.nil?\r\n        original = changes.first.try(:fetch, I18n.locale.to_s, nil)\r\n        compare = changes.last.try(:fetch, I18n.locale.to_s, nil)\r\n        persisted? && original != compare\r\n      else\r\n        persisted? && _slugs_changed?\r\n      end\r\n    end","code-length":133,"reference":"Returns true if object has been persisted and has changes in the slug","result":"Determine if the slug changes are persisted.","score":[0.1153,0.2545]}
{"code":"# is used to<extra_id_0>\r\ndef distance_of_time_in_words(from_time, to_time=Time.now)\r\n      from_time = from_time.to_time if from_time.respond_to?(:to_time)\r\n      to_time = to_time.to_time if to_time.respond_to?(:to_time)\r\n      seconds = (to_time - from_time).round\r\n      distance_in_days = (seconds\/(60*60*24)).round\r\n      seconds = seconds % (60*60*24)\r\n      distance_in_hours = (seconds\/(60*60)).round\r\n      seconds = seconds % (60*60)\r\n      distance_in_minutes = (seconds\/60).round\r\n      seconds = seconds % 60\r\n      distance_in_seconds = seconds\r\n          s = ''\r\n      s << \"#{distance_in_days} days,\" if distance_in_days > 0\r\n      s << \"#{distance_in_hours} hours, \" if distance_in_hours > 0\r\n      s << \"#{distance_in_minutes} minutes, \" if distance_in_minutes > 0\r\n      s << \"#{distance_in_seconds} seconds\"\r\n      s\r\n    end","code-length":298,"reference":"Return the distance of time in words from the given from_time to the specified to_time.","result":"Calculate the distance of time in words.","score":[0.2143,0.3408]}
{"code":"# is used to<extra_id_0>\r\ndef approximate_distance_of_time_in_words(from_time, to_time=Time.now, include_seconds=true)\r\n      from_time = from_time.to_time if from_time.respond_to?(:to_time)\r\n      to_time = to_time.to_time if to_time.respond_to?(:to_time)\r\n      distance_in_minutes = (((to_time - from_time).abs)\/60).round\r\n      distance_in_seconds = ((to_time - from_time).abs).round\r\n          case distance_in_minutes\r\n        when 0..1\r\n          return (distance_in_minutes == 0) ? 'less than a minute' : '1 minute' unless include_seconds\r\n        case distance_in_seconds\r\n          when 0..4   then 'less than 5 seconds'\r\n          when 5..9   then 'less than 10 seconds'\r\n          when 10..19 then 'less than 20 seconds'\r\n          when 20..39 then 'half a minute'\r\n          when 40..59 then 'less than a minute'\r\n          else             '1 minute'\r\n        end\r\n        when 2..44           then \"#{distance_in_minutes} minutes\"\r\n        when 45..89          then 'about 1 hour'\r\n        when 90..1439        then \"about #{(distance_in_minutes.to_f \/ 60.0).round} hours\"\r\n        when 1440..2879      then '1 day'\r\n        when 2880..43199     then \"#{(distance_in_minutes \/ 1440).round} days\"\r\n        when 43200..86399    then 'about 1 month'\r\n        when 86400..525959   then \"#{(distance_in_minutes \/ 43200).round} months\"\r\n        when 525960..1051919 then 'about 1 year'\r\n        else                      \"over #{(distance_in_minutes \/ 525960).round} years\"\r\n      end\r\n    end","code-length":481,"reference":"Get the approximate disntance of time in words from the given from_time to the the given to_time.","result":"Calculate the approximate distance of a time in words.","score":[0.0986,0.2296]}
{"code":"# is used to<extra_id_0>\r\ndef track_error(control, msg)\r\n      errors << msg\r\n      control.error_handlers.each do |handler|\r\n        handler.call(msg)\r\n      end\r\n    end","code-length":55,"reference":"First attempt at centralizing error notifications","result":"Track errors.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef process_batch(batch)\r\n      batch = ETL::Batch::Batch.resolve(batch, self)\r\n      say \"Processing batch #{batch.file}\"\r\n          ETL::Engine.batch = ETL::Execution::Batch.create!(\r\n        :batch_file => batch.file,\r\n        :status => 'executing'\r\n      )\r\n            batch.execute\r\n            ETL::Engine.batch.completed_at = Time.now\r\n      ETL::Engine.batch.status = (errors.length > 0 ? 'completed with errors' : 'completed')\r\n      ETL::Engine.batch.save!\r\n    end","code-length":159,"reference":"Process the specified batch file","result":"Resolve the batch file.","score":[0.2959,0.2041]}
{"code":"# is used to<extra_id_0>\r\ndef pre_process(control)\r\n      Engine.logger.debug \"Pre-processing #{control.file}\"\r\n      control.pre_processors.each do |processor|\r\n        processor.process\r\n      end\r\n      Engine.logger.debug \"Pre-processing complete\"\r\n    end","code-length":75,"reference":"Execute all preprocessors","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef post_process(control)\r\n      say_on_own_line \"Executing post processes\"\r\n      Engine.logger.debug \"Post-processing #{control.file}\"\r\n      control.post_processors.each do |processor|\r\n        processor.process\r\n      end\r\n      Engine.logger.debug \"Post-processing complete\"\r\n      say \"Post-processing complete\"\r\n    end","code-length":100,"reference":"Execute all postprocessors","result":"Execute post-processing.","score":[0.3033,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef execute_dependencies(control)\r\n      Engine.logger.debug \"Executing dependencies\"\r\n      control.dependencies.flatten.each do |dependency|\r\n        case dependency\r\n        when Symbol\r\n          f = dependency.to_s + '.ctl'\r\n          Engine.logger.debug \"Executing dependency: #{f}\"\r\n          say \"Executing dependency: #{f}\"\r\n          process(f)\r\n        when String\r\n          Engine.logger.debug \"Executing dependency: #{f}\"\r\n          say \"Executing dependency: #{f}\"\r\n          process(dependency)\r\n        else\r\n          raise \"Invalid dependency type: #{dependency.class}\"\r\n        end\r\n      end\r\n    end","code-length":167,"reference":"Execute all dependencies","result":"Execute the control's dependencies.","score":[0.3195,0.1613]}
{"code":"# is used to<extra_id_0>\r\ndef execute_screens(control, timing = :before_post_process)\r\n      screens = case timing\r\n        when :after_post_process\r\n          control.after_post_process_screens\r\n        else\r\n          control.screens\r\n        end\r\n      [:fatal,:error,:warn].each do |type|\r\n        screens[type].each do |block|\r\n          begin\r\n            block.call\r\n          rescue => e\r\n            case type\r\n            when :fatal\r\n              raise FatalScreenError, e\r\n            when :error\r\n              raise ScreenError, e\r\n            when :warn\r\n              say \"Screen warning: #{e}\"\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end","code-length":195,"reference":"Execute all screens","result":"Execute screens in the control.","score":[0.2857,0.3125]}
{"code":"# is used to<extra_id_0>\r\ndef redis_key *fields\r\n      @redis_key_config = fields.flatten\r\n            validate_redis_key\r\n            remove_redis_autoincrement_key unless redis_user_field_config.include?(:id) || @redis_key_config.include?(:id)\r\n      @redis_key_config.each do |field|\r\n        validates field, :presence => :true if field != :id\r\n      end\r\n    end","code-length":113,"reference":"set redis key which will be used for storing model","result":"Create a new redis key.","score":[0.0884,0.0526]}
{"code":"# is used to<extra_id_0>\r\ndef redis_key_normalize *metrics\r\n      @redis_key_normalize_conf ||= []\r\n      metrics.each do |metric|\r\n        raise ArgumentError, \"Please provide valid normalization: #{VALID_NORMALIZATIONS.join(\", \")}\" unless VALID_NORMALIZATIONS.include?(metric)\r\n        @redis_key_normalize_conf << metric\r\n      end\r\n    end","code-length":97,"reference":"set redis model to normalize redis keys","result":"Normalize redis keys.","score":[0.1076,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef redis_alias name, main_fields, name_of_field_for_order = nil, name_of_field_for_args = nil\r\n      if name_of_field_for_order && name_of_field_for_args\r\n        redis_field name_of_field_for_order, :array, [] unless redis_fields_config.has_key?(name_of_field_for_order)\r\n        redis_field name_of_field_for_args, :hash, {} unless redis_fields_config.has_key?(name_of_field_for_args)\r\n      end\r\n      @redis_alias_config ||= {}\r\n      @redis_alias_config[name] = { \r\n        main_fields: main_fields,\r\n        order_field: name_of_field_for_order,\r\n        args_field: name_of_field_for_args,\r\n      }\r\n      create_class_alias_method(name)\r\n    end","code-length":244,"reference":"store informations about redis aliases","result":"Define the class alias method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef store_redis_keys\r\n      args = to_arg\r\n      redis_old_keys[:key] = self.class.generate_key(args)\r\n      redis_old_keys[:aliases] = []\r\n      redis_alias_config.each do |alias_name, fields|\r\n        redis_old_keys[:aliases] << redis_alias_key(alias_name) if valid_alias_key? alias_name\r\n      end\r\n    end","code-length":116,"reference":"set old arguments","result":"Store redis keys.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef conf\r\n      fields = {}\r\n      redis_fields_config.each do |key, type|\r\n        fields[key] = TYPE_TRANSLATIONS[type] if TYPE_TRANSLATIONS.has_key?(type)\r\n      end\r\n      {\r\n        fields: fields,\r\n        required: @required_config.sort,\r\n        redis_key: redis_key_config,\r\n        redis_aliases: redis_alias_config.inject({}){|o,(k,v)| o[k] = v[:main_fields]; o},\r\n        reject_nil_values: !redis_save_fields_with_nil_conf,\r\n      }\r\n    end","code-length":168,"reference":"get config hash","result":"Define the configuration.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef exists? args = {}\r\n      RedisModelExtension::Database.redis.exists(self.name.constantize.generate_key(args))\r\n    end","code-length":45,"reference":"Check if key by arguments exists in db","result":"Detect if a record exists.","score":[0.1319,0.0649]}
{"code":"# is used to<extra_id_0>\r\ndef alias_exists? alias_name, args = {}\r\n      RedisModelExtension::Database.redis.exists(self.name.constantize.generate_alias_key(alias_name, args))\r\n    end","code-length":57,"reference":"Check if key by alias name and arguments exists in db","result":"Check if an alias exists.","score":[0.1133,0.2457]}
{"code":"# is used to<extra_id_0>\r\ndef valid_item_for_redis_key? args, key\r\n      (args.has_key?(key) && !args[key].nil?) || redis_fields_config[key] == :autoincrement\r\n    end","code-length":61,"reference":"validate one item of redis key","result":"Validate the arguments.","score":[0,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef validate_redis_key\r\n      valid_fields = redis_fields_config.select{|k,v| v != :array && v != :hash  }.keys\r\n      bad_fields = redis_key_config - valid_fields\r\n      raise ArgumentError, \"Sorry, but you cannot use as redis key [nonexisting | array | hash] fields: [#{bad_fields.join(\",\")}], availible are: #{valid_fields.join(\", \")}\" unless bad_fields.size == 0\r\n    end","code-length":128,"reference":"look for bad cofiguration in redis key and raise argument error","result":"Validate the redis key.","score":[0.0555,0.0485]}
{"code":"# is used to<extra_id_0>\r\ndef to_arg\r\n      redis_fields_config.inject({}) do |args, (key, type)|\r\n        args[key] = self.send(key)\r\n        args\r\n      end\r\n    end","code-length":60,"reference":"take all arguments and send them out","result":"Create a new function.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef find_by_alias(alias_name, args = {})\r\n      raise ArgumentError, \"Unknown dynamic alias: '#{alias_name}', use: #{redis_alias_config.keys.join(\", \")} \" unless redis_alias_config.has_key?(alias_name.to_sym)\r\n      args = HashWithIndifferentAccess.new(args)\r\n      out = []\r\n      klass = self.name.constantize\r\n      search_key = klass.generate_alias_key(alias_name, args)\r\n      unless search_key =~ \/\\*\/\r\n        out = klass.get_by_alias(alias_name, args) if klass.alias_exists?(alias_name, args)\r\n      else\r\n        RedisModelExtension::Database.redis.keys(search_key).each do |key|\r\n          out << klass.get_by_alias_key(key)\r\n        end\r\n      end\r\n      out.flatten\r\n    end","code-length":236,"reference":"Find method for searching in redis","result":"Find the model by its alias.","score":[0.193,0.0833]}
{"code":"# is used to<extra_id_0>\r\ndef get(args = {})\r\n      args = { id: args } if args.is_a?(Integer)\r\n      args = HashWithIndifferentAccess.new(args)\r\n      klass = self.name.constantize\r\n      if klass.valid_key?(args) && klass.exists?(args)\r\n        klass.new_by_key(klass.generate_key(args))\r\n      else\r\n        nil\r\n      end\r\n    end","code-length":119,"reference":"GET BY ARGUMENTSfastest method to get object from redis by getting it by arguments","result":"Get a resource.","score":[0,0.0388]}
{"code":"# is used to<extra_id_0>\r\ndef get_by_alias_key(alias_key)\r\n      klass = self.name.constantize\r\n      if RedisModelExtension::Database.redis.exists(alias_key)\r\n        out = []\r\n        RedisModelExtension::Database.redis.smembers(alias_key).each do |key|\r\n          item = klass.new_by_key(key)\r\n          out << item if item\r\n        end\r\n        return out\r\n      end\r\n      nil\r\n    end","code-length":124,"reference":"fastest method to get object from redis by getting it by alias and arguments","result":"Get the list of items by alias key.","score":[0.0928,0.1907]}
{"code":"# is used to<extra_id_0>\r\ndef new_by_key(key)\r\n      args = RedisModelExtension::Database.redis.hgetall(key)\r\n      return nil unless args && args.any?\r\n      args.symbolize_keys!\r\n      new_instance = new(args)\r\n      new_instance.store_keys\r\n      return new_instance\r\n    end","code-length":91,"reference":"CREATE NEW OBJECT BY HASH VALUES","result":"Create new instances.","score":[0,0.3289]}
{"code":"# is used to<extra_id_0>\r\ndef value_to_redis name, value\r\n      if redis_fields_config.has_key?(name)\r\n        value_transform value, redis_fields_config[name]\r\n      else\r\n        value\r\n      end\r\n    end","code-length":67,"reference":"choose right type of value and then transform it for redis","result":"Store the value in redis.","score":[0.0724,0.0481]}
{"code":"# is used to<extra_id_0>\r\ndef value_transform value, type\r\n      return nil if value.nil? || value.to_s.size == 0\r\n      case type\r\n      when :integer then value.to_i\r\n      when :autoincrement then value.to_i\r\n      when :string then value.to_s\r\n      when :float then value.to_f\r\n      when :bool then value.to_s\r\n      when :symbol then value.to_s\r\n      when :marshal then Marshal.dump(value)\r\n      when :array then Yajl::Encoder.encode(value)\r\n      when :hash then Yajl::Encoder.encode(value)\r\n      when :time then Time.parse(value.to_s).strftime(\"%Y.%m.%d %H:%M:%S\")\r\n      when :date then Date.parse(value.to_s).strftime(\"%Y-%m-%d\")\r\n      else value\r\n      end\r\n    end","code-length":232,"reference":"convert value for valid format which can be saved in redis","result":"Transform values.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef value_parse value, type\r\n      return nil if value.nil? || value.to_s.size == 0\r\n      case type\r\n      when :integer then value.to_i\r\n      when :autoincrement then value.to_i\r\n      when :string then value.to_s\r\n      when :float then value.to_f\r\n      when :bool then value.to_s.to_bool\r\n      when :symbol then value.to_s.to_sym\r\n      when :marshal then value.is_a?(String) ? Marshal.load(value) : value\r\n      when :array then value.is_a?(String) ? Yajl::Parser.parse(value) : value\r\n      when :hash then value.is_a?(String) ? Hashr.new(Yajl::Parser.parse(value)) : Hashr.new(value)\r\n      when :time then value.is_a?(String) ? Time.parse(value) : value\r\n      when :date then value.is_a?(String) ? Date.parse(value) : value\r\n      else value\r\n      end\r\n    end","code-length":279,"reference":"convert value from redis into valid format in ruby","result":"Parse the value.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef update args\r\n      args.each do |key, value|\r\n        method = \"#{key}=\".to_sym \r\n        if self.respond_to? method\r\n          self.send(method, value)\r\n        end\r\n      end\r\n    end","code-length":71,"reference":"update multiple attrubutes at once","result":"Update the object.","score":[0,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef destroy_aliases!\r\n      if redis_old_keys[:aliases].size > 0\r\n        redis_old_keys[:aliases].each do |alias_key|\r\n          RedisModelExtension::Database.redis.srem alias_key, redis_old_keys[:key]\r\n          RedisModelExtension::Database.redis.del(alias_key) if RedisModelExtension::Database.redis.scard(alias_key).to_i == 0\r\n        end\r\n      end\r\n    end","code-length":122,"reference":"remove all aliases","result":"Destroy aliases.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add(username, token)\r\n      Firim::AccountManager.new(\r\n        user: username,\r\n        token: token\r\n      ).add_to_keychain\r\n    end","code-length":56,"reference":"Add entry to Apple Keychain","result":"Add to the keychain.","score":[0.2959,0.2041]}
{"code":"# is used to<extra_id_0>\r\ndef get_nsqds(lookupd, topic = nil)\r\n      uri_scheme = 'http:\/\/' unless lookupd.match(%r(https?:\/\/))\r\n      uri = URI.parse(\"#{uri_scheme}#{lookupd}\")\r\n      uri.query = \"ts=#{Time.now.to_i}\"\r\n      if topic\r\n        uri.path = '\/lookup'\r\n        uri.query += \"&topic=#{URI.escape(topic)}\"\r\n      else\r\n        uri.path = '\/nodes'\r\n      end\r\n      begin\r\n        body = Net::HTTP.get(uri)\r\n        data = JSON.parse(body)\r\n        producers = data['producers'] ||\r\n                      (data['data'] && data['data']['producers'])\r\n        if producers\r\n          producers.map do |producer|\r\n            \"#{producer['broadcast_address']}:#{producer['tcp_port']}\"\r\n          end\r\n        else\r\n          []\r\n        end\r\n      rescue Exception => e\r\n        error \"Error during discovery for #{lookupd}: #{e}\"\r\n        nil\r\n      end\r\n    end","code-length":275,"reference":"Returns an array of nsqd addresses","result":"Detect if a topic is not specified.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef discover_repeatedly(opts = {})\r\n      @discovery_thread = Thread.new do\r\n        @discovery = Discovery.new(opts[:nsqlookupds])\r\n        loop do\r\n          begin\r\n            nsqds = nsqds_from_lookupd(opts[:topic])\r\n            drop_and_add_connections(nsqds)\r\n          rescue DiscoveryException\r\n            warn 'Could not connect to any nsqlookupd instances in discovery loop'\r\n          end\r\n          sleep opts[:interval]\r\n        end\r\n      end\r\n      @discovery_thread.abort_on_exception = true\r\n    end","code-length":157,"reference":"discovers nsqds from an nsqlookupd repeatedly","result":"Create a new instance of the class.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef with_retries(&block)\r\n      base_sleep_seconds = 0.5\r\n      max_sleep_seconds = 300\r\n      attempts = 0\r\n      begin\r\n        attempts += 1\r\n        return block.call(attempts)\r\n      rescue Errno::ECONNREFUSED, Errno::ECONNRESET, Errno::EHOSTUNREACH,\r\n             Errno::ENETDOWN, Errno::ENETUNREACH, Errno::ETIMEDOUT, Timeout::Error => ex\r\n        raise ex if attempts >= 100\r\n        sleep_seconds = [base_sleep_seconds * (2 ** (attempts - 1)), max_sleep_seconds].min\r\n        sleep_seconds = sleep_seconds * (0.5 * (1 + rand()))\r\n        sleep_seconds = [base_sleep_seconds, sleep_seconds].max\r\n        warn \"Failed to connect: #{ex}. Retrying in #{sleep_seconds.round(1)} seconds.\"\r\n        snooze(sleep_seconds)\r\n        retry\r\n      end\r\n    end","code-length":247,"reference":"Retry the supplied block with exponential backoff.","result":"Retry connection failures.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef show(ind = '')\r\r\n      count = 0\r\r\n      self.to_a.each{|i|\r\r\n        puts \"#{ind}#{i.name} [#{count}]: #{i.to_s.sub(\/^(.{30})(.*?)(.{30})$\/, '\\1...\\3')}\"\r\r\n        if i.kind_of?(X12::Segment) && i.nodes[0]\r\r\n          i.find_field(i.nodes[0].name)\r\r\n        end\r\r\n        i.nodes.each{|j|\r\r\n          case \r\r\n          when j.kind_of?(X12::Base)  then j.show(ind+'  ')\r\r\n          when j.kind_of?(X12::Field) then puts \"#{ind+'  '}#{j.name} -> '#{j.to_s}'\"\r\r\n          end\r\r\n        } \r\r\n        count += 1\r\r\n      }\r\r\n    end","code-length":238,"reference":"Prints a tree-like representation of the element","result":"Print the contents of the field.","score":[0.2311,0.3704]}
{"code":"# is used to<extra_id_0>\r\ndef do_repeats(s)\r\r\n      if self.repeats.end > 1\r\r\n        possible_repeat = self.dup\r\r\n        p_s = possible_repeat.parse(s)\r\r\n        if p_s\r\r\n          s = p_s\r\r\n          self.next_repeat = possible_repeat\r\r\n        end\r\n      end\r\n      s\r\r\n    end","code-length":105,"reference":"Try to parse the current element one more time if required.","result":"Parse the string.","score":[0.0284,0.1838]}
{"code":"# is used to<extra_id_0>\r\ndef find(e)\r\r\n      case self\r\r\n        when X12::Loop\r\r\n        res = nodes.find{|i| e==i.name }\r\r\n        return res if res\r\r\n        nodes.each{|i| \r\r\n          res = i.find(e) if i.kind_of?(X12::Loop)\r\r\n          return res unless res.nil? or EMPTY==res\r\n        }\r\r\n        when X12::Segment\r\r\n        return find_field(e).to_s\r\r\n      end\r\n      return EMPTY\r\r\n    end","code-length":149,"reference":"Make a deep copy of the element dup","result":"Find the element.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(meth, *args, &block)\r\r\n      str = meth.id2name\r\r\n      str = str[1..str.length] if str =~ \/^_\\d+$\/\r\n      if str =~ \/=$\/\r\r\n        str.chop!\r\r\n        case self\r\r\n        when X12::Segment\r\r\n          res = find_field(str)\r\r\n          throw Exception.new(\"No field '#{str}' in segment '#{self.name}'\") if EMPTY == res\r\r\n          res.content = args[0].to_s\r\r\n        else\r\r\n          throw Exception.new(\"Illegal assignment to #{meth} of #{self.class}\")\r\r\n        end\r\n      else\r\r\n        res = find(str)\r\r\n        yield res if block_given?\r\r\n        res\r\r\n      end\r\n    end","code-length":212,"reference":"The main method implementing Ruby-like access methods for nested elements","result":"Define the method.","score":[0,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef parse(str)\r\r\n      s = str\r\r\n      m = regexp.match(s)\r\r\n      \r\r\n      return nil unless m\r\r\n\r\r\n      s = m.post_match\r\r\n      self.parsed_str = m[0]\r\r\n      s = do_repeats(s)\r\r\n\r\r\n      return s\r\r\n    end","code-length":100,"reference":"Parses this segment out of a string, puts the match into value, returns the rest of the string - nil if cannot parse","result":"Parse the string.","score":[0.0005,0.0476]}
{"code":"# is used to<extra_id_0>\r\ndef render\r\r\n      self.to_a.inject(''){|repeat_str, i|\r\r\n        if i.repeats.begin < 1 and !i.has_content?\r\r\n          repeat_str\r\r\n        else\r\r\n          repeat_str += i.name+i.nodes.reverse.inject(''){|nodes_str, j|\r\r\n            field = j.render\r\r\n            (j.required or nodes_str != '' or field != '') ? field_separator+field+nodes_str : nodes_str\r\r\n          } + segment_separator\r\r\n        end\r\r\n      }\r\r\n    end","code-length":159,"reference":"parse","result":"Render the template.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef regexp\r\r\n      unless @regexp\r\r\n        if self.nodes.find{|i| i.type =~ \/^\".+\"$\/ }\r\r\n          re_str = self.nodes.inject(\"^#{name}#{Regexp.escape(field_separator)}\"){|s, i|\r\r\n            field_re = i.simple_regexp(field_separator, segment_separator)+Regexp.escape(field_separator)+'?'\r\r\n            field_re = \"(#{field_re})?\" unless i.required\r\r\n            s+field_re\r\r\n          } + Regexp.escape(segment_separator)\r\r\n          @regexp = Regexp.new(re_str)\r\r\n        else\r\r\n          @regexp = Regexp.new(\"^#{name}#{Regexp.escape(field_separator)}[^#{Regexp.escape(segment_separator)}]*#{Regexp.escape(segment_separator)}\")\r\r\n        end\r\r\n      end\r\r\n      @regexp\r\r\n    end","code-length":233,"reference":"render","result":"Match the field name.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef find_field(str)\r\r\n      field_num = nil\r\r\n      self.nodes.each_index{|i|\r\r\n        field_num = i if str == self.nodes[i].name\r\r\n      }\r\r\n      return EMPTY if field_num.nil?\r\r\n\r\r\n      unless @fields\r\r\n        @fields = self.to_s.chop.split(Regexp.new(Regexp.escape(field_separator)))\r\r\n        self.nodes.each_index{|i| self.nodes[i].content = @fields[i+1] }\r\r\n      end\r\r\n      return self.nodes[field_num]\r\r\n    end","code-length":171,"reference":"Finds a field in the segment. Returns EMPTY if not found.","result":"Find a field.","score":[0.0284,0.1838]}
{"code":"# is used to<extra_id_0>\r\ndef parse(loop_name, str)\r\r\n      loop = @x12_definition[X12::Loop][loop_name]\r\r\n      throw Exception.new(\"Cannot find a definition for loop #{loop_name}\") unless loop\r\r\n      loop = loop.dup\r\r\n      loop.parse(str)\r\r\n      return loop\r\r\n    end","code-length":92,"reference":"Creates a parser out of a definition initialize","result":"Parse a loop.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef factory(loop_name)\r\r\n      loop = @x12_definition[X12::Loop][loop_name]\r\r\n      throw Exception.new(\"Cannot find a definition for loop #{loop_name}\") unless loop\r\r\n      loop = loop.dup\r\r\n      return loop\r\r\n    end","code-length":80,"reference":"parse","result":"Create a loop.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef process_loop(loop)\r\r\n      loop.nodes.each{|i|\r\r\n        case i\r\r\n          when X12::Loop then process_loop(i)\r\r\n          when X12::Segment then process_segment(i) unless i.nodes.size > 0\r\r\n          else return\r\r\n        end\r\r\n      }\r\r\n    end","code-length":96,"reference":"Recursively scan the loop and instantiate fields' definitions for all its segments","result":"Process loop nodes.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef process_segment(segment)\r\r\n      unless @x12_definition[X12::Segment] && @x12_definition[X12::Segment][segment.name]\r\r\n        initialize(segment.name+'.xml')\r\r\n        segment_definition = @x12_definition[X12::Segment][segment.name]\r\r\n        throw Exception.new(\"Cannot find a definition for segment #{segment.name}\") unless segment_definition\r\r\n      else\r\r\n        segment_definition = @x12_definition[X12::Segment][segment.name]\r\r\n      end\r\r\n      segment_definition.nodes.each_index{|i|\r\r\n        segment.nodes[i] = segment_definition.nodes[i] \r\r\n        table = segment.nodes[i].validation\r\r\n        if table\r\r\n          unless @x12_definition[X12::Table] && @x12_definition[X12::Table][table]\r\r\n            initialize(table+'.xml')\r\r\n            throw Exception.new(\"Cannot find a definition for table #{table}\") unless @x12_definition[X12::Table] && @x12_definition[X12::Table][table]\r\r\n          end\r\r\n        end\r\r\n      }\r\r\n    end","code-length":303,"reference":"Instantiate segment's fields as previously defined","result":"Process the segment.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef render\r\r\n      if self.has_content?\r\r\n        self.to_a.inject(''){|loop_str, i|\r\r\n          loop_str += i.nodes.inject(''){|nodes_str, j|\r\r\n            nodes_str += j.render\r\r\n          } \r\r\n        }\r\r\n      else\r\r\n        ''\r\r\n      end\r\r\n    end","code-length":107,"reference":"parse","result":"Render the loop.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef calculate_sortable_values\r\n      response_fieldable.input_fields.each do |response_field|\r\n        if (x = response_value(response_field)).present?\r\n          get_responses[\"#{response_field.id}_sortable_value\"] = response_field.sortable_value(x)\r\n        end\r\n      end\r\n      mark_responses_as_changed!\r\n    end","code-length":104,"reference":"for manual use, maybe when migrating","result":"Calculate the sortable values.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef normalize_responses\r\n      return if form.blank?\r\n      form.response_fields.each do |response_field|\r\n        if (x = self.response_value(response_field))\r\n          response_field.normalize_response(x, get_responses)\r\n        end\r\n      end\r\n      mark_responses_as_changed!\r\n    end","code-length":95,"reference":"Normalizations get run before validation.","result":"Normalize form fields.","score":[0,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef audit_responses\r\n      form.response_fields.each do |response_field|\r\n        response_field.audit_response(self.response_value(response_field), get_responses)\r\n      end\r\n      mark_responses_as_changed!\r\n    end","code-length":73,"reference":"Audits get run explicitly.","result":"Generate the generated code.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef tag!(tag, *args, &block)\r\n      text, attributes = nil, {}\r\n      args.each do |arg|\r\n        case arg\r\n        when ::Hash\r\n          attributes.merge!(arg)\r\n        when ::String\r\n          text ||= ''\r\n          text << arg\r\n        end\r\n      end\r\n      @stack << [tag, attributes, text ? [text] : []]\r\n      if block\r\n        _process(&block)\r\n      end\r\n      if @stack.length > 1\r\n        node = @stack.pop\r\n        @stack.last[2] << node\r\n        NodeBuilder.new(node, self)\r\n      else\r\n        NodeBuilder.new(@stack.last, self)\r\n      end\r\n    end","code-length":194,"reference":"Construct a new builder, and start building","result":"Define tags.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef <<(*args)\r\n      args.each do |arg|\r\n        if arg.respond_to?(:to_hexp)\r\n          @stack.last[2] << arg\r\n          self\r\n        else\r\n          ::Kernel.raise ::Hexp::FormatError, \"Inserting literal HTML into a builder with << is deliberately not supported by Hexp\"\r\n        end\r\n      end\r\n    end","code-length":105,"reference":"Add Hexp objects to the current tag this operator.","result":"Build a Hexp object.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef rewrite(css_selector = nil, &block)\r\n      return Rewriter.new(self, block) if css_selector.nil?\r\n      CssSelection.new(self, css_selector).rewrite(&block)\r\n    end","code-length":65,"reference":"Replace nodes in a tree","result":"Rewrite the css.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef select(css_selector = nil, &block)\r\n      if css_selector\r\n        CssSelection.new(self, css_selector).each(&block)\r\n      else\r\n        Selection.new(self, block)\r\n      end\r\n    end","code-length":70,"reference":"Select nodes based on a css selector ","result":"Create the selector.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add_configuration(config_hash)\r\n      config_hash.each do |key, val|\r\n        instance_eval { instance_variable_set(\"@#{key}\",val) }\r\n        self.class.instance_eval { attr_accessor key }\r\n      end\r\n    end","code-length":78,"reference":"Extend configuration variables ","result":"Add the configuration to the instance.","score":[0.193,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef pid_exists(pid)\r\n  return false if pid < 0\r\n  return true if pid == 0\r\n  ::Process.kill(0, pid)\r\n  return true\r\n  rescue Errno::ESRCH\r\n    return false\r\n  rescue Errno::EPERM\r\n    return true\r\n  rescue RangeError\r\n    return false\r\nend","code-length":93,"reference":"Check whether pid exists in the current process table.\"\"\"","result":"Check if a process with the given pid exists.","score":[0.1723,0.2222]}
{"code":"# is used to<extra_id_0>\r\ndef wait_pid(pid, timeout=nil)\r\n  def check_timeout(delay, stop_at, timeout)\r\n    if timeout\r\n      raise Timeout::Error.new(\"when waiting for (pid=#{pid})\") if Time.now >= stop_at\r\n    end\r\n    sleep(delay)\r\n    delay * 2 < 0.04 ? delay * 2 : 0.04\r\n  end\r\n  if timeout\r\n    waitcall = proc { ::Process.wait(pid, ::Process::WNOHANG)}\r\n    stop_at = Time.now + timeout\r\n  else\r\n    waitcall = proc { ::Process.wait(pid)}\r\n  end\r\n  delay = 0.0001\r\n  loop do\r\n    begin\r\n      retpid = waitcall.call()\r\n    rescue Errno::EINTR\r\n      delay = check_timeout(delay, stop_at, timeout)\r\n      next\r\n    rescue Errno::ECHILD\r\n      loop do\r\n        return nil unless pid_exists(pid)\r\n        delay = check_timeout(delay, stop_at, timeout)\r\n      end\r\n    end\r\n    unless retpid\r\n      delay = check_timeout(delay, stop_at, timeout)\r\n      next\r\n    end\r\n    if $?.signaled?\r\n      return $?.termsig\r\n    elsif $?.exited?\r\n      return $?.exitstatus\r\n    else\r\n      raise RuntimeError.new(\"unknown process exit status\")\r\n    end\r\n  end\r\nend","code-length":369,"reference":"Wait for process with pid 'pid' to terminate and return its exit status code as an integer.","result":"Wait for a process to exit.","score":[0.0519,0.1985]}
{"code":"# is used to<extra_id_0>\r\ndef upload_module_changes(parent_sha1, sha1s)\r\n    remote_path = fetch_module\r\n    tmp_git_path = clone_or_fetch_repository(remote_path, module_tmp_git_path(@remote_path))\r\n    RIM::git_session(tmp_git_path) do |dest|\r\n      local_branch = nil\r\n      remote_branch = nil\r\n      infos = nil\r\n      if @module_info.subdir\r\n        dest_path = File.join([tmp_git_path] + @module_info.subdir.split(\"\/\"))\r\n      else\r\n        dest_path = tmp_git_path\r\n      end\r\n      RIM::git_session(@ws_root) do |src|\r\n        infos = get_branches_and_revision_infos(src, dest, parent_sha1, sha1s)\r\n        if infos.branches.size == 1\r\n          remote_branch = infos.branches[0]\r\n          if dest.has_remote_branch?(remote_branch)\r\n            infos.rev_infos.each do |rev_info|\r\n              local_branch = create_update_branch(dest, infos.parent_sha1, rev_info.src_sha1) if !local_branch\r\n              copy_revision_files(\r\n                src,\r\n                rev_info.src_sha1,\r\n                dest_path,\r\n                rev_info.rim_info.ignores\r\n              )\r\n              commit_changes(dest, local_branch, rev_info.src_sha1, rev_info.message)\r\n            end\r\n          else\r\n            raise RimException.new(\"The target revision '#{@module_info.target_revision}' of module #{@module_info.local_path} is not a branch. No push can be performed.\")\r\n          end\r\n        elsif infos.branches.size > 1\r\n          raise RimException.new(\"There are commits for module #{@module_info.local_path} on multiple target revisions (#{infos.branches.join(\", \")}).\")\r\n        end\r\n      end\r\n      if local_branch && dest.rev_sha1(local_branch) != infos.parent_sha1  \r\n        push_branch = @review && @module_info.remote_branch_format && !@module_info.remote_branch_format.empty? \\\r\n            ? @module_info.remote_branch_format % remote_branch : remote_branch\r\n        dest.execute(\"git push #{@remote_url} #{local_branch}:#{push_branch}\")\r\n        dest.execute(\"git checkout --detach #{local_branch}\")\r\n        dest.execute(\"git branch -D #{local_branch}\")\r\n        @logger.info(\"Commited changes for module #{@module_info.local_path} to remote branch #{push_branch}.\")\r\n      else\r\n        @logger.info(\"No changes to module #{@module_info.local_path}.\")\r\n      end                              \r\n    end\r\n  end","code-length":722,"reference":"upload the content of the module","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get_branches_and_revision_infos(src_session, dest_session, parent_sha1, sha1s)\r\n    infos = []\r\n    branches = []\r\n    dest_parent_sha1 = nil\r\n    (sha1s.size() - 1).step(0, -1) do |i|\r\n      info = get_revision_info(src_session, dest_session, sha1s[i])\r\n      if !info.dest_sha1 && info.rim_info.target_revision\r\n        infos.unshift(info)\r\n        branches.push(info.rim_info.target_revision) if !branches.include?(info.rim_info.target_revision)\r\n      else\r\n        dest_parent_sha1 = info.dest_sha1\r\n        break\r\n      end\r\n    end\r\n    dest_parent_sha1 = get_riminfo_for_revision(src_session, parent_sha1).revision_sha1 if !dest_parent_sha1\r\n    dest_parent_sha1 = infos.first.rim_info.revision_sha1 if !dest_parent_sha1 && !infos.empty?\r\n    return Struct.new(:branches, :parent_sha1, :rev_infos).new(branches, dest_parent_sha1, infos)      \r\n  end","code-length":325,"reference":"search backwards for all revision infos","result":"Get the branches and revision infos.","score":[0.193,0.0833]}
{"code":"# is used to<extra_id_0>\r\ndef get_revision_info(src_session, dest_session, src_sha1)\r\n    module_status = StatusBuilder.new.rev_module_status(src_session, src_sha1, @module_info.local_path)\r\n    rim_info = get_riminfo_for_revision(src_session, src_sha1)\r\n    dest_sha1 = dest_session.rev_sha1(\"rim-#{src_sha1}\")\r\n    msg = src_session.execute(\"git show -s --format=%B #{src_sha1}\") \r\n    RevisionInfo.new(module_status && module_status.dirty? ? dest_sha1 : rim_info.revision_sha1, src_sha1, rim_info, msg)\r\n  end","code-length":195,"reference":"collect infos for a revision","result":"Build the revision info.","score":[0.2488,0.102]}
{"code":"# is used to<extra_id_0>\r\ndef commit_changes(session, branch, sha1, msg)\r\n    if session.status.lines.any?\r\n      session.execute(\"git add --all\")\r\n      msg_file = Tempfile.new('message')\r\n      begin\r\n        msg_file << msg\r\n        msg_file.close\r\n        session.execute(\"git commit -F #{msg_file.path}\")\r\n      ensure\r\n        msg_file.close(true)\r\n      end\r\n      session.execute(\"git tag rim-#{sha1} refs\/heads\/#{branch}\")\r\n    end\r\n  end","code-length":150,"reference":"commit changes to session","result":"Commit changes.","score":[0,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef get_riminfo_for_revision(session, sha1)\r\n    session.execute(\"git show #{sha1}:#{File.join(@module_info.local_path, RimInfo::InfoFileName)}\") do |out, e|\r\n      return RimInfo.from_s(!e ? out : \"\")\r\n    end\r\n  end","code-length":92,"reference":"get target revision for this module for workspace revision","result":"Get the revision information.","score":[0.0915,0.1176]}
{"code":"# is used to<extra_id_0>\r\ndef copy_revision_files(src_session, src_sha1, dest_dir, ignores)\r\n    Dir.mktmpdir do |tmp_dir|\r\n      tmp_dir = Dir.glob(tmp_dir)[0]\r\n      src_session.execute(\"git archive --format tar #{src_sha1} #{@module_info.local_path} | tar -C #{tmp_dir} -xf -\")\r\n      tmp_module_dir = File.join(tmp_dir, @module_info.local_path)\r\n      files = FileHelper.find_matching_files(tmp_module_dir, false, \"\/**\/*\", File::FNM_DOTMATCH)\r\n      files.delete(\".\")\r\n      files.delete(\"..\")\r\n      files.delete(RimInfo::InfoFileName)\r\n      files -= FileHelper.find_matching_files(tmp_module_dir, false, ignores)\r\n      prepare_empty_folder(dest_dir, \".git\/**\/*\")\r\n      files.each do |f|\r\n        src_path = File.join(tmp_module_dir, f)\r\n        if File.file?(src_path)\r\n          path = File.join(dest_dir, f)\r\n          FileUtils.mkdir_p(File.dirname(path))\r\n          FileUtils.cp(src_path, path)\r\n        end        \r\n      end\r\n    end \r\n  end","code-length":341,"reference":"copy files from given source revision into destination dir","result":"Copy revision files.","score":[0.0553,0.119]}
{"code":"# is used to<extra_id_0>\r\ndef rev_history_status(git_session, rev, options={})\r\r\n    stop_rev = options[:stop_rev]\r\r\n    relevant_revs = {}\r\r\n    if stop_rev\r\r\n      git_session.execute(\"git rev-list #{rev} \\\"^#{stop_rev}\\\"\").split(\"\\n\").each do |r|\r\r\n        relevant_revs[r] = true\r\r\n      end\r\r\n    elsif options[:gerrit]\r\r\n      git_session.execute(\"git rev-list #{rev} --not --all --\").split(\"\\n\").each do |r|\r\r\n        relevant_revs[r] = true\r\r\n      end\r\r\n    else\r\r\n      git_session.all_reachable_non_remote_revs(rev).each do |r| \r\r\n        relevant_revs[r] = true\r\r\n      end\r\r\n    end\r\r\n    rev = git_session.rev_sha1(rev)\r\r\n    build_rev_history_status(git_session, rev, relevant_revs, {}, :fast => options[:fast])\r\r\n  end","code-length":277,"reference":"status object tree for revision rev returns the root status object which points to any parent status objects note that merge commits mean that the status tree branches at the point were the merged branch branched off, the status tree joins i.e. the parent status objects are the same at this point stops traversing a specific branch when a commit is found which is an ancestor at the same time, gerrit doesn't \"know\" commits pushed in the ref-update hook yet so the status will be built for the new commits pushed in the ref-update hook the leafs of the tree are the stop commits or commits which have no parents if the leaves of the tree are remote commits, the fast check basically tells if any of the local commits is dirty or not","result":"Build the status of the rev history.","score":[0.0,0.0307]}
{"code":"# is used to<extra_id_0>\r\ndef rev_status(git_session, rev)\r\r\n    mod_dirs = module_dirs(git_session, rev)\r\r\n    mod_stats = []\r\r\n    git_session.within_exported_rev(rev, mod_dirs) do |d|\r\r\n      mod_dirs.each do |rel_path|\r\r\n        mod_stats << build_module_status(d, d+\"\/\"+rel_path)\r\r\n      end\r\r\n    end\r\r\n    stat = RevStatus.new(mod_stats)\r\r\n    stat.git_rev = git_session.rev_sha1(rev)\r\r\n    stat\r\r\n  end","code-length":167,"reference":"status object for single revision +rev+ without status of ancestors","result":"Build the status.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef rev_module_status(git_session, rev, local_path)\r\r\n    mod_stat = nil\r\r\n    if git_session.execute(\"git ls-tree -r --name-only #{rev}\").split(\"\\n\").include?(File.join(local_path, \".riminfo\"))\r\r\n      git_session.within_exported_rev(rev, [local_path]) do |d|\r\r\n        mod_stat = build_module_status(d, File.join(d, local_path))\r\r\n      end\r\r\n    end\r\r\n    mod_stat\r\r\n  end","code-length":155,"reference":"status object for a single module at +local_path+ in revision +rev+ returns nil if there is no such module in this revision","result":"Determine module status.","score":[0.0007,0.0249]}
{"code":"# is used to<extra_id_0>\r\ndef fs_status(dir)\r\r\n    RevStatus.new(\r\r\n      fs_rim_dirs(dir).collect { |d|\r\r\n        build_module_status(dir, d) \r\r\n      })\r\r\n  end","code-length":68,"reference":"status object for the current file system content of dir this can by any directory even outside of any git working copy","result":"Build the status.","score":[0.0007,0.0249]}
{"code":"# is used to<extra_id_0>\r\ndef build_rev_history_status(gs, rev, relevant_revs, status_cache={}, options={})\r\r\n    return status_cache[rev] if status_cache[rev]\r\r\n    stat = nil\r\r\n    if relevant_revs[rev]\r\r\n      parent_revs = gs.parent_revs(rev)\r\r\n      if parent_revs.size > 0\r\r\n        parent_stats = parent_revs.collect do |p|\r\r\n          build_rev_history_status(gs, p, relevant_revs, status_cache, options)\r\r\n        end\r\r\n\r\r\n        base_stat = parent_stats.first\r\r\n        \r\r\n        changed_files = gs.changed_files(rev, parent_revs.first)\r\r\n\r\r\n        module_dirs = base_stat.modules.collect{|m| m.dir}\r\r\n        changed_files.each do |f|\r\r\n          if File.basename(f.path) == RimInfo::InfoFileName\r\r\n            if f.kind == :added\r\r\n              module_dirs << File.dirname(f.path)\r\r\n            elsif f.kind == :deleted\r\r\n              module_dirs.delete(File.dirname(f.path))\r\r\n            end\r\r\n          end\r\r\n        end\r\r\n\r\r\n        check_dirs = module_dirs.select{|d| changed_files.any?{|f| f.path.start_with?(d)} }\r\r\n\r\r\n        module_stats = []\r\r\n        if check_dirs.size > 0\r\r\n          gs.within_exported_rev(rev, check_dirs) do |ws|\r\r\n            check_dirs.each do |d|\r\r\n              module_stats << build_module_status(ws, File.join(ws, d))\r\r\n            end\r\r\n          end\r\r\n        end\r\r\n        (module_dirs - check_dirs).each do |d|\r\r\n          base_mod = base_stat.modules.find{|m| m.dir == d}\r\r\n          module_stats << RevStatus::ModuleStatus.new(d, base_mod.rim_info, base_mod.dirty?)\r\r\n        end\r\r\n\r\r\n        stat = RevStatus.new(module_stats)\r\r\n        stat.git_rev = gs.rev_sha1(rev)\r\r\n        stat.parents.concat(parent_stats)\r\r\n      else\r\r\n        if options[:fast]\r\r\n          stat = rev_status_fast(gs, rev)\r\r\n        else\r\r\n          stat = rev_status(gs, rev)\r\r\n        end\r\r\n      end\r\r\n    else\r\r\n      if options[:fast]\r\r\n        stat = rev_status_fast(gs, rev)\r\r\n      else\r\r\n        stat = rev_status(gs, rev)\r\r\n      end\r\r\n    end\r\r\n    status_cache[rev] = stat\r\r\n  end","code-length":733,"reference":"building of the status of an ancestor chain works by checking the dirty state of modules only when any files affecting some module for this to work, the chain must be walked from older commit to newer ones at the end of the chain, the status must be calculated in the regular \"non-fast\" way","result":"Code too long,keep in 512.","score":[0.0,0.0102]}
{"code":"# is used to<extra_id_0>\r\ndef rev_status_fast(git_session, rev)\r\r\n    mod_dirs = module_dirs(git_session, rev)\r\r\n    mod_stats = []\r\r\n    git_session.within_exported_rev(rev, mod_dirs.collect{|d| \"#{d}\/#{RimInfo::InfoFileName}\"}) do |temp_dir|\r\r\n      mod_dirs.each do |rel_path|\r\r\n        mod_stats << RevStatus::ModuleStatus.new(\r\r\n          rel_path,\r\r\n          RimInfo.from_dir(\"#{temp_dir}\/#{rel_path}\"),\r\r\n          false\r\r\n        )\r\r\n      end\r\r\n    end\r\r\n    stat = RevStatus.new(mod_stats)\r\r\n    stat.git_rev = git_session.rev_sha1(rev)\r\r\n    stat\r\r\n  end","code-length":219,"reference":"creates a RevStatus object for +rev+ with all modules assumend to be clean","result":"Determine the status of a revision.","score":[0.0601,0.0407]}
{"code":"# is used to<extra_id_0>\r\ndef sync(message = nil, rebase = nil, split = true)\r\n    RIM::git_session(@ws_root) do |s|\r\n      branch = s.current_branch || ''\r\n      rim_branch = \"rim\/\" + branch\r\n      branch_sha1 = nil\r\n      changed_modules = nil\r\n      if branch.empty?\r\n        raise RimException.new(\"Not on a git branch.\")\r\n      elsif branch.start_with?(\"rim\/\")\r\n        raise RimException.new(\"The current git branch '#{branch}' is a rim integration branch. Please switch to a non rim branch to proceed.\")\r\n      else\r\n        branch = \"refs\/heads\/#{branch}\"\r\n        branch_sha1 = s.rev_sha1(rim_branch)\r\n        remote_rev = get_latest_remote_revision(s, branch)\r\n        rev = get_latest_clean_path_revision(s, branch, remote_rev)\r\n        if !s.has_branch?(rim_branch) || has_ancestor?(s, branch, s.rev_sha1(rim_branch)) || !has_ancestor?(s, rim_branch, remote_rev)\r\n          s.execute(\"git branch -f #{rim_branch} #{rev}\")\r\n          branch_sha1 = s.rev_sha1(rim_branch)\r\n        end\r\n        remote_url = \"file:\/\/\" + @ws_root\r\n        @logger.debug(\"Folder for temporary git repositories: #{@rim_path}\")\r\n        tmpdir = clone_or_fetch_repository(remote_url, module_tmp_git_path(\".ws\"), \"Cloning workspace git...\")\r\n        RIM::git_session(tmpdir) do |tmp_session|\r\n          tmp_session.execute(\"git reset --hard\")\r\n          tmp_session.execute(\"git clean -xdf\")\r\n          tmp_session.execute(\"git checkout -B #{rim_branch} -f remotes\/origin\/#{rim_branch}\")\r\n          changed_modules = sync_modules(tmp_session, message)\r\n          if !split\r\n            tmp_session.execute(\"git reset --soft #{branch_sha1}\")\r\n            commit(tmp_session, message ? message : get_commit_message(changed_modules)) if tmp_session.uncommited_changes?\r\n          end\r\n          tmp_session.execute(\"git push #{remote_url} #{rim_branch}:#{rim_branch}\")\r\n        end\r\n      end\r\n      if !changed_modules.empty?\r\n        if rebase\r\n          s.execute(\"git rebase #{rim_branch}\")\r\n          @logger.info(\"Changes have been commited to branch #{rim_branch} and workspace has been rebased successfully.\")\r\n        else\r\n          @logger.info(\"Changes have been commited to branch #{rim_branch}. Rebase to apply changes to workspace.\")\r\n        end\r\n      else\r\n        @logger.info(\"No changes.\")\r\n      end\r\n    end\r\n  end","code-length":742,"reference":"sync all module changes into rim branch","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef sync_modules(session, message)\r\n    module_helpers = []\r\n    @module_infos.each do |module_info|\r\n      module_helpers.push(SyncModuleHelper.new(session.execute_dir, @ws_root, module_info, @logger))\r\n    end\r\n    changed_modules = []\r\n    module_helpers.each do |m|\r\n      @logger.info(\"Synchronizing #{m.module_info.local_path}...\")\r\n      if m.sync(message)\r\n        changed_modules << m.module_info\r\n      end\r\n    end\r\n    changed_modules\r\n  end","code-length":161,"reference":"sync all modules","result":"Sync modules.","score":[0,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef has_ancestor?(session, rev, ancestor)\r\n    rev = session.rev_sha1(rev)\r\n    return rev == ancestor || session.is_ancestor?(ancestor, rev)\r\n  end","code-length":58,"reference":"check whether revision has a given ancestor","result":"Check if the ancestor exists.","score":[0.1611,0.1471]}
{"code":"# is used to<extra_id_0>\r\ndef get_parent(session, rev)\r\n    parents = session.parent_revs(rev)\r\n    !parents.empty? ? parents.first : nil \r\n  end","code-length":50,"reference":"get first parent node","result":"Get the parent of a revision.","score":[0.193,0.2381]}
{"code":"# is used to<extra_id_0>\r\ndef get_commit_message(changed_modules)\r\n    StringIO.open do |s|\r\n      s.puts \"rim sync.\"\r\n      s.puts\r\n      changed_modules.each do |m|\r\n        s.puts m.local_path\r\n      end\r\n      s.string\r\n    end\r\n  end","code-length":88,"reference":"create default commit message from array of changed modules","result":"Generate the commit message.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef pmmap_ext(data)\r\n    pmmap_ext = ['addr', 'perms', 'path', 'rss', 'size', 'pss', \r\n                 'shared_clean', 'shared_dirty', 'private_clean', \r\n                 'private_dirty', 'referenced', 'anonymous', 'swap']\r\n    os_list = []\r\n    data.each do |datum|\r\n      os = OpenStruct.new\r\n      pmmap_ext.each_index {|i| os[pmmap_ext[i]] = datum[i]}\r\n      os_list.push(os)\r\n    end\r\n    os_list\r\n  end","code-length":161,"reference":"data in pmmap_ext is an Array","result":"Generate the pmmap.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef pmmap_grouped(data)\r\n    pmmap_grouped = ['rss', 'size', 'pss', 'shared_clean', \r\n                     'shared_dirty', 'private_clean', 'private_dirty', \r\n                     'referenced', 'anonymous', 'swap']\r\n    os_list = []\r\n    data.each do |k, v|\r\n      os = OpenStruct.new\r\n      os.path = k\r\n      pmmap_grouped.each_index {|i| os[pmmap_grouped[i]] = v[i]}\r\n      os_list.push(os)\r\n    end\r\n    os_list\r\n  end","code-length":161,"reference":"data in pmmap_grouped is a Hash","result":"Group data.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef calc_checksum(mi, dir)\r\r\n    if check_required_attributes(mi)\r\r\n      sha1 = Digest::SHA1.new\r\r\n      files = FileHelper.find_matching_files(dir, false, \"\/**\/*\", File::FNM_DOTMATCH)\r\r\n      files.delete(\".\")\r\r\n      files.delete(\"..\")\r\r\n      files.delete(RimInfo::InfoFileName)\r\r\n      files -= FileHelper.find_matching_files(dir, false, mi.ignores)\r\r\n      files.sort!\r\r\n      files.each do |fn|\r\r\n        update_file(sha1, dir, fn)\r\r\n      end\r\r\n      ChecksumAttributes.each do |a|\r\r\n        sha1.update(mi.send(a))\r\r\n      end\r\r\n      sha1.hexdigest\r\r\n    else\r\r\n      nil\r\r\n    end\r\r\n  end","code-length":234,"reference":"returns nil if checksum can't be calculated due to missing info","result":"Calculate the checksum of the directory.","score":[0.0839,0.0952]}
{"code":"# is used to<extra_id_0>\r\ndef current_branch\r\r\n    out = execute \"git branch\"\r\r\n    out.split(\"\\n\").each do |l| \r\r\n      if !l.include?('(') && (l =~ \/^\\*\\s+(\\S+)\/)\r\r\n        return $1\r\r\n      end\r\r\n    end\r\r\n    nil\r\r\n  end","code-length":92,"reference":"returns the current branch","result":"Determine the current branch.","score":[0.4518,0.4688]}
{"code":"# is used to<extra_id_0>\r\ndef has_remote_branch?(branch)\r\r\n    out = execute(\"git ls-remote --heads\")\r\r\n    out.split(\"\\n\").each do |l|\r\r\n      return true if l.split(\/\\s+\/)[1] == \"refs\/heads\/#{branch}\"\r\r\n    end\r\r\n    false\r\r\n  end","code-length":89,"reference":"check whether remote branch exists","result":"Check if a branch has a remote branch.","score":[0.1652,0.283]}
{"code":"# is used to<extra_id_0>\r\ndef rev_sha1(rev)\r\r\n    sha1 = nil\r\r\n    execute \"git rev-list -n 1 #{rev} --\" do |out, e|\r\r\n      sha1 = out.strip if !e\r\r\n    end\r\r\n    sha1\r\r\n  end","code-length":78,"reference":"returns the SHA-1 representation of rev","result":"Calculate the sha1 of a revision.","score":[0.2296,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef rev_infos(rev, desired)\r\r\n    info = {}\r\r\n    desired.each_pair do |key, value|\r\r\n      execute \"git log -1 --format=#{value} #{rev} --\" do |out, e|\r\r\n        info[key] = out.strip if !e\r\r\n      end\r\r\n    end\r\r\n    info\r\r\n  end","code-length":101,"reference":"returns some informations about a revision","result":"Get the revision information.","score":[0.1938,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef remote_branch_revs\r\r\n    out = execute \"git show-ref\"\r\r\n    out.split(\"\\n\").collect { |l|\r\r\n      if l =~ \/refs\\\/remotes\\\/\/\r\r\n        l.split[0]\r\r\n      else\r\r\n        nil\r\r\n      end\r\r\n    }.compact\r\r\n  end","code-length":95,"reference":"returns the SHA-1 representations of the heads of all remote branches","result":"Store the remote branch revs.","score":[0.0861,0.2457]}
{"code":"# is used to<extra_id_0>\r\ndef export_rev(rev, dir, paths=[])\r\r\n    paths = paths.dup\r\r\n    loop do\r\r\n      path_args = \"\"\r\r\n      while !paths.empty? && path_args.size < 6000\r\r\n        path_args << \" \"\r\r\n        path_args << paths.shift\r\r\n      end\r\r\n      execute \"git archive --format tar #{rev} #{path_args} | tar -C #{dir} -xf -\"\r\r\n      break if paths.empty?\r\r\n    end\r\r\n  end","code-length":140,"reference":"export file contents of rev to dir if +paths+ is given and non-empty, checks out only those parts of the filesystem tree does not remove any files from dir which existed before","result":"Export a revision to a directory.","score":[0.0025,0.034]}
{"code":"# is used to<extra_id_0>\r\ndef within_exported_rev(rev, paths=[])\r\r\n    Dir.mktmpdir(\"rim\") do |d|\r\r\n      d = Dir.glob(d)[0]\r\r\n      c = File.join(d, \"content\")\r\r\n      FileUtils.mkdir(c)\r\r\n      export_rev(rev, c, paths)\r\r\n      yield c\r\r\n      FileUtils.rm_rf(c)\r\r\n      retries = 600\r\r\n      while File.exist?(c) && retries > 0\r\r\n        sleep(0.1)\r\r\n        FileUtils.rm_rf(c)\r\r\n        retries -= 1\r\r\n      end\r\r\n      if File.exist?(c)\r\r\n        @logger.warn \"could not delete temp dir: #{c}\"\r\r\n      end\r\r\n    end\r\r\n  end","code-length":212,"reference":"checks out rev to a temporary directory and yields this directory to the given block if +paths+ is given and non-empty, checks out only those parts of the filesystem tree returns the value returned by the block","result":"Generate the content dir.","score":[0.0001,0.0148]}
{"code":"# is used to<extra_id_0>\r\ndef upload\r\n    RIM::git_session(@ws_root) do |s|\r\n      branch = s.current_branch\r\n      if branch.nil?\r\n        raise RimException.new(\"Not on a git branch.\")\r\n      elsif !branch.start_with?(\"rim\/\")\r\n        begin\r\n          sha1 = s.rev_sha1(branch)\r\n          @logger.info(\"Uploading modules...\")\r\n          upload_modules(get_upload_revisions(s, sha1))\r\n        ensure\r\n          s.execute(\"git checkout -B #{branch}\")\r\n        end\r\n      else\r\n        raise RimException.new(\"The current git branch '#{branch}' is a rim integration branch. Please switch to a non rim branch to proceed.\")\r\n      end\r\n    end\r\n  end","code-length":205,"reference":"upload all module changes into corresponding remote repositories","result":"Upload modules.","score":[0,0.0676]}
{"code":"# is used to<extra_id_0>\r\ndef upload_modules(info)\r\n    each_module_parallel(\"uploading\", @module_helpers) do |m|\r\n      m.upload(info.parent, info.sha1s)\r\n    end\r\n  end","code-length":62,"reference":"upload all modules","result":"Upload modules.","score":[0,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef get_upload_revisions(session, rev)\r\n    non_remote_revs = {}\r\n    session.all_reachable_non_remote_revs(rev).each do |r| \r\n      non_remote_revs[r] = true\r\n    end\r\n    revisions = []\r\n    rev = session.rev_sha1(rev)\r\n    while rev && non_remote_revs[rev]\r\n      revisions.push(rev)\r\n      parents = session.parent_revs(rev)\r\n      rev = parents.size > 0 ? parents.first : nil\r\n    end\r\n    Struct.new(:parent, :sha1s).new(rev, revisions.reverse!)\r\n  end","code-length":176,"reference":"get revisions to upload i.e. the revisions up to the last remote revision the function returns the revisions in order of appearal i.e. the oldest first","result":"Get the upload revisions.","score":[0.0016,0.063]}
{"code":"# is used to<extra_id_0>\r\ndef fetch_module\r\n    FileUtils.mkdir_p git_path\r\n    RIM::git_session(git_path) do |s|\r\n      if !File.exist?(git_path + \"\/config\")\r\n        s.execute(\"git clone --mirror #{@remote_url} #{git_path}\") do |out, e|\r\n          raise RimException.new(\"Remote repository '#{@remote_url}' of module '#{@module_info.local_path}' not found.\") if e\r\n        end\r\n      else\r\n        s.execute(\"git remote update\")\r\n      end\r\n    end\r\n    git_path\r\n  end","code-length":160,"reference":"fetch module +mod+ into the .rim folder works both for initial fetch and updates","result":"Fetch module.","score":[0,0.0391]}
{"code":"# is used to<extra_id_0>\r\ndef assign(attribute, value)\r\n      unless value == :skip || attribute == :class\r\n        if item.respond_to?(\"#{attribute}=\")\r\n          item.send(\"#{attribute}=\", value)\r\n        elsif item.is_a?(Hash)\r\n          item[attribute] = value\r\n        end\r\n      end\r\n    end","code-length":93,"reference":"Assign the value to the given attribute of the item","result":"Assign the attribute to the item.","score":[0.1951,0.2604]}
{"code":"# is used to<extra_id_0>\r\ndef debug(*args)\r\n      item = build(*args)\r\n      invalid_item = Array(item).find(&:invalid?)\r\n      if invalid_item\r\n        if invalid_item.errors.respond_to?(:messages)\r\n          errors = invalid_item.errors.messages\r\n        else\r\n          errors = invalid_item.errors\r\n        end\r\n        raise \"Oops, the #{invalid_item.class} created by the Factory has the following errors: #{errors}\"\r\n      end\r\n      item\r\n    end","code-length":134,"reference":"Can be left in your tests as an alternative to build and to warn if your factory method ever starts producing invalid instances","result":"Debug the build method.","score":[0.0028,0.0237]}
{"code":"# is used to<extra_id_0>\r\ndef crank_it(what, overrides)\r\n        if what.to_s =~ \/(.*)_attrs$\/\r\n          what = $1\r\n          overrides = overrides.merge(:_return_attributes => true)\r\n        end\r\n        item = \"TBD\"\r\n        new_job(what, overrides) do\r\n          item = self.send(what)\r\n          item = apply_traits(what, item)\r\n        end\r\n        item\r\n      end","code-length":119,"reference":"Execute the requested factory method, crank out the target object!","result":"Create a crank job.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(method, *args, &block)\r\n      if view_context.respond_to?(method, true)\r\n        view_context.send(method, *args, &block)\r\n      else\r\n        super\r\n      end\r\n    end","code-length":72,"reference":"Send missing methods to view_context first","result":"Call methods.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef present(object, presenter: nil, **args)\r\n      if object.respond_to?(:to_ary)\r\n        object.map { |item| present(item, presenter: presenter, **args) }\r\n      else\r\n        presenter ||= presenter_klass(object)\r\n        wrapper = presenter.new(object, view_context, **args)\r\n        block_given? ? yield(wrapper) : wrapper\r\n      end\r\n    end","code-length":113,"reference":"Wrap an object or collection of objects with a presenter class.","result":"Present the object.","score":[0,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef push(gem, method, options = {})\r\n      push_command = PUSH_METHODS[method.to_s] or raise \"Unknown Gem push method #{method.inspect}.\"\r\n      push_command += [gem]\r\n      push_command += [\"--as\", options[:as]] if options[:as]\r\n      @cli_facade.execute(*push_command)\r\n    end","code-length":99,"reference":"Publish the gem.","result":"Push a Gem.","score":[0,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef interpolate interpolant\r\n      case @opts[:type]\r\n      when :linear\r\n        for_each (interpolant) { |x| linear_interpolation(x)  }\r\n      when :cubic\r\n        cubic_spline_interpolation interpolant\r\n      else\r\n        raise ArgumentError, \"1 D interpolation of type #{@opts[:type]} not supported\"\r\n      end\r\n    end","code-length":102,"reference":"Constructor for all One Dimensional interpolation operations.","result":"Create the function.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef lines_selector_for(target, attributes)\r\n      if (klass = @selectors.find { |s| s.handles? target, attributes })\r\n        klass.new(target, attributes, logger: logger)\r\n      end\r\n    end","code-length":67,"reference":"Finds and initializes a lines selector that can handle the specified include.","result":"Create a selector for the lines.","score":[0.0935,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef run\r\n      client_ip = @ip\r\n      key = \"request_count:#{client_ip}\"\r\n      result = { status: Constants::SUCCESS_STATUS, message: Constants::OK_MESSAGE }\r\n      requests_count = @storage.get(key)\r\n      unless requests_count\r\n        @storage.set(key, 0)\r\n        @storage.expire(key, @limits[\"time_period_seconds\"])\r\n      end\r\n      if requests_count.to_i >= @limits[\"max_requests_count\"]\r\n        result[:status] = Constants::EXPIRED_STATUS\r\n        result[:message] = message(period(key))\r\n      else\r\n        @storage.incr(key)\r\n      end\r\n      result\r\n    end","code-length":190,"reference":"Create a Core object.","result":"Run the task.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef date_select(method, options = {})\r\n      options[:include_blank] ||= false\r\n      options[:start_year]    ||= 1801\r\n      options[:end_year]      ||= Time.now.year\r\n      options[:label_for]       = \"#{object_name}_#{method}_1i\"\r\n      build_shell(method, options) { super }\r\n    end","code-length":100,"reference":"Standard Rails date selector.","result":"Generate the date_select.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef label(method, text = nil, options = {})\r\n      colon = false if options[:colon].nil?\r\n      options[:for] = options[:label_for]\r\n      required = options[:required]\r\n      options.delete :colon\r\n      options.delete :label_for\r\n      options.delete :required\r\n      text = @template.send(:h, text.blank?? method.to_s.humanize : text.to_s)\r\n      text << ':'.html_safe if colon\r\n      text << @template.content_tag(:span, \"*\", :class => \"required\") if required\r\n      super\r\n    end","code-length":159,"reference":"Render a field label.","result":"Generate labels.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef read(raw, predecessors=nil)\r\n        if raw.respond_to?(:read)\r\n          raw = raw.read(self.sizeof())\r\n        end\r\n        if raw.size < self.sizeof()\r\n          raise(ReadError, \"Expected #{self.sizeof} bytes, but only got #{raw.size} bytes\")\r\n        end\r\n        vals = \r\n          if @unpack_cb\r\n            @unpack_cb.call(raw, predecessors)\r\n          else\r\n            raw.unpack(self.format)\r\n          end\r\n        return(self.claim_value(vals, predecessors))\r\n      end","code-length":162,"reference":"Called when parsing.","result":"Read from a stream.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef pack_value(val, obj=nil)\r\n        begin\r\n          if @pack_cb\r\n            @pack_cb.call(val, obj)\r\n          else\r\n            varray = val.is_a?(Array) ? val : [val]\r\n            varray.pack(self.format)\r\n          end\r\n        rescue => e\r\n          raise(PackError, \"Error packing #{val.inspect} as type #{self.name.inspect} -- #{e.class} -> #{e}\")\r\n        end\r\n      end","code-length":138,"reference":"Called when composing raw data.","result":"Pack the value.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(sym, *args, &block)\r\n      return Lebowski::RSpec::Matchers::Be.new(sym, *args) if sym.to_s =~ \/^be_\/\r\n      return Lebowski::RSpec::Matchers::Has.new(sym, *args) if sym.to_s =~ \/^have_\/\r\n      return Lebowski::RSpec::Operators::That.new(sym, *args) if sym.to_s =~ \/^that_\/      \r\n      super\r\n    end","code-length":139,"reference":"Replacing RSpec's default method_missing implementation so that we can include our own special default hooks that allows spec tests to look more readable.","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef static_files\r\n      source = File.dirname(ENGINE.assets_path)\r\n      asset_files.map do |file|\r\n        dir = File.dirname(file)\r\n        file_name = File.basename(file)\r\n        Jekyll::StaticFile.new @site, source, dir, file_name\r\n      end\r\n    end","code-length":94,"reference":"This method searches for folders and files in the assets root directory.","result":"Generate static files.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef asset_files\r\n      asset_files = []\r\n      Find.find(ENGINE.assets_path).each do |path|\r\n        next if File.directory?(path)\r\n        next if path.include?(ENGINE.stylesheets_sass_path)\r\n        asset_files << path.sub(ENGINE.assets_path, 'assets')\r\n      end\r\n      asset_files\r\n    end","code-length":105,"reference":"Get paths and fils directory 'assets'","result":"Find and find asset files.","score":[0.1967,0.1695]}
{"code":"# is used to<extra_id_0>\r\ndef daily(time = Date.today, page_size = 50)\r\n      time      = time.strftime(\"%Y-%m-%d\") unless time.is_a?(String)\r\n      report_id = run_report_request('DailyActivityReport', {'report_date' => time}, page_size)\r\n      meta_data = get_meta_data_request(report_id)\r\n      data = []\r\n      meta_data[\"numberOfPages\"].to_i.times do |page_num|\r\n        data += get_data_request(report_id, page_num + 1)\r\n      end\r\n      data\r\n    end","code-length":162,"reference":"high level functions","result":"Generate the report.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef run_report_request(report_name, report_params = {}, page_size = 50)\r\n      response = request 'runReportRequest' do |xml|\r\n        xml.reportName report_name\r\n        report_params.each do |name, value|\r\n          xml.reportParam do\r\n            xml.paramName name\r\n            xml.paramValue value\r\n          end\r\n        end\r\n        xml.pageSize page_size\r\n      end\r\n      response.elements[\"runReportResponse\/reportId\"].get_text.value\r\n    end","code-length":139,"reference":"low level functions","result":"Create a report.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef generate_unique(length = 32, &blk)\r\n      unique = generate_random(length)\r\n      unique = generate_random(length) until blk.call(unique)\r\n      unique\r\n    end","code-length":59,"reference":"Generate a unique field","result":"Generate unique random strings.","score":[0.3799,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef draw_paperback(qr_code:, sixword_lines:, sixword_bytes:, labels:,\r\n                     passphrase_sha: nil, passphrase_len: nil,\r\n                     sixword_font_size: nil, base64_content: nil,\r\n                     base64_bytes: nil)\r\n    unless qr_code.is_a?(RQRCode::QRCode)\r\n      raise ArgumentError.new('qr_code must be RQRCode::QRCode')\r\n    end\r\n    pdf.font('Times-Roman')\r\n    debug_draw_axes\r\n    draw_header(labels: labels, passphrase_sha: passphrase_sha,\r\n                passphrase_len: passphrase_len)\r\n    add_newline\r\n    draw_qr_code(qr_modules: qr_code.modules)\r\n    pdf.stroke_color '000000'\r\n    pdf.fill_color '000000'\r\n    pdf.start_new_page\r\n    draw_sixword(lines: sixword_lines, sixword_bytes: sixword_bytes,\r\n                 font_size: sixword_font_size,\r\n                 is_encrypted: passphrase_len)\r\n    if base64_content\r\n      draw_base64(b64_content: base64_content, b64_bytes: base64_bytes,\r\n                  is_encrypted: passphrase_len)\r\n    end\r\n    pdf.number_pages('<page> of <total>', align: :right,\r\n                     at: [pdf.bounds.right - 100, -2])\r\n  end","code-length":376,"reference":"High level method to draw the paperback content on the pdf document ","result":"Draw the paperback.","score":[0.0203,0.0901]}
{"code":"# is used to<extra_id_0>\r\ndef produce_report(*args)\r\n      `gem install xcov` unless xcov_available?\r\n      unless xcov_available?\r\n        puts \"xcov is not available on this machine\"\r\n        return\r\n      end\r\n      require \"xcov\"\r\n      require \"fastlane_core\"\r\n      config = FastlaneCore::Configuration.create(Xcov::Options.available_options, convert_options(args.first))\r\n      Xcov.config = config\r\n      Xcov.ignore_handler = Xcov::IgnoreHandler.new\r\n      manager =  Xcov::Manager.new(config)\r\n      report_json = manager.parse_xccoverage\r\n      process_report(Xcov::Report.map(report_json))\r\n    end","code-length":188,"reference":"Produces and processes a report for use in the report method","result":"Produce a report.","score":[0.0284,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef output_report(report)\r\n      report_markdown = report.markdown_value\r\n      markdown(report_markdown)\r\n      threshold = Xcov.config[:minimum_coverage_percentage].to_i\r\n      if !threshold.nil? && (report.coverage * 100) < threshold\r\n        fail(\"Code coverage under minimum of #{threshold}%\")\r\n      end\r\n    end","code-length":98,"reference":"Outputs a processed report with Danger","result":"Output the report.","score":[0,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef process_report(report)\r\n      file_names = @dangerfile.git.modified_files.map { |file| File.basename(file) }\r\n      file_names += @dangerfile.git.added_files.map { |file| File.basename(file) }\r\n      report.targets.each do |target|\r\n        target.files = target.files.select { |file| file_names.include?(file.name) }\r\n      end\r\n      report\r\n    end","code-length":126,"reference":"Filters the files that haven't been modified in the current PR","result":"Process the report.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef update(data)\r\n      data.each_byte do |b|\r\n        b = revert_byte(b) if REVERSE_DATA\r\n        @crc = ((@table[((@crc >> 8) ^ b) & 0xff] ^ (@crc << 8)) & 0xffff)\r\n      end\r\n      return self\r\n    end","code-length":89,"reference":"Updates the CRC16 checksum.","result":"Update the CRC.","score":[0.2925,0.4808]}
{"code":"# is used to<extra_id_0>\r\ndef request(http_verb, url, options = {})\r\n      full_url = url + hash_to_params(options)\r\n      handle(access_token.request(http_verb, full_url))\r\n    end","code-length":62,"reference":"class << self","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef string(opts = {})\r\n      length, any, value = (opts[:length] || 8), opts[:any], opts[:value]\r\n      if value\r\n        string = value.to_s\r\n        Proc.new { string }\r\n      elsif any\r\n        Proc.new { self.any(any) }\r\n      else\r\n        Proc.new { Array.new(length){@chars[rand(@chars.size-1)]}.join }\r\n      end\r\n    end","code-length":123,"reference":"belows are data types ","result":"Generate a string.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef convert tag, val\r\n      return val unless val.kind_of?(String)\r\n      case tag\r\n      when 'partofset', 'track'\r\n        return val\r\n      end\r\n      case val\r\n      when REGEXP_TIMESTAMP\r\n        year, month, day, hour, minute = $~.captures[0,5].map {|cap| cap.to_i}\r\n        if month == 0 || day == 0\r\n          return nil\r\n        end\r\n        second = $6.to_f\r\n        zone = $7\r\n        zone = '+00:00' if zone == 'Z'\r\n        Time.new(year, month, day, hour, minute, second, zone)\r\n      when REGEXP_RATIONAL\r\n        return val if $2.to_i == 0\r\n        Rational($1, $2)\r\n      else\r\n        val\r\n      end\r\n    end","code-length":228,"reference":"Converts values on the basis of unified tag name and value.","result":"Convert strings to strings.","score":[0,0.0485]}
{"code":"# is used to<extra_id_0>\r\ndef to_h\r\n      @values.inject(Hash.new) do |h, a|\r\n        tag, val = a\r\n        h[Values.tag_map[tag]] = convert(Values.unify_tag(tag), val)\r\n        h\r\n      end\r\n    end","code-length":78,"reference":"Generates a hash representation of this instance with original tag names es keys and converted values as values","result":"Convert values to hash.","score":[0.0096,0.0602]}
{"code":"# is used to<extra_id_0>\r\ndef n(msg, title='', image=nil)\r\n      Compat::UI.notify(msg, :title => title, :image => image)\r\n    end","code-length":47,"reference":"Easy method to display a notification","result":"Escape the string.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef eager(command)\r\n      require 'pty'\r\n      begin\r\n        PTY.spawn command do |r, w, pid|\r\n          begin\r\n            $stdout.puts\r\n            r.each {|line| print line }\r\n          rescue Errno::EIO\r\n          end\r\n        end\r\n      rescue PTY::ChildExited\r\n        $stdout.puts \"The child process exited!\"\r\n      end\r\n    end","code-length":113,"reference":"Eager prints the result for stdout and stderr as it would be written when running the command from the terminal.","result":"Run the command in the eager mode.","score":[0.0395,0.2385]}
{"code":"# is used to<extra_id_0>\r\ndef wrap_list(list, width)\r\n      list.map do |text|\r\n        wrap_text(text, width)\r\n      end.flatten\r\n    end","code-length":49,"reference":"an array of text","result":"Wrap a list of strings.","score":[0.2403,0.122]}
{"code":"# is used to<extra_id_0>\r\ndef save\r\n      return if @data.empty?\r\n      output = {}\r\n      output[:data] = @data\r\n      output[:generated_at] = Time.now.to_s\r\n      output[:started_at] = @started_at\r\n      output[:format_version] = '1.0'\r\n      output[:rails_version] = Rails.version\r\n      output[:rails_path] = Rails.root.to_s\r\n      FileUtils.mkdir_p(@config.output_path)\r\n      filename = \"sql_tracker-#{Process.pid}-#{Time.now.to_i}.json\"\r\n      File.open(File.join(@config.output_path, filename), 'w') do |f|\r\n        f.write JSON.dump(output)\r\n      end\r\n    end","code-length":202,"reference":"save the data to file","result":"Save the data.","score":[0.2096,0.3906]}
{"code":"# is used to<extra_id_0>\r\ndef delete(key)\r\n      ref = @references.delete(key)\r\n      if ref\r\n        keys_to_id = @references_to_keys_map[ref.referenced_object_id]\r\n        if keys_to_id\r\n          keys_to_id.delete(key)\r\n          @references_to_keys_map.delete(ref.referenced_object_id) if keys_to_id.empty?\r\n        end\r\n        ref.object\r\n      else\r\n        nil\r\n      end\r\n    end","code-length":136,"reference":"Remove the entry associated with the key from the map.","result":"Delete the referenced object.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef merge(other_hash, &block)\r\n      to_h.merge(other_hash, &block).reduce(self.class.new) do |map, pair|\r\n        map[pair.first] = pair.last\r\n        map\r\n      end\r\n    end","code-length":74,"reference":"Returns a new struct containing the contents of `other` and the contents of `self`.","result":"Merge hash values.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add_strong_reference(obj)\r\n        @@lock.synchronize do\r\n          @@strong_references.last[obj] = true\r\n          unless @@gc_flag_set\r\n            @@gc_flag_set = true\r\n            ObjectSpace.define_finalizer(Object.new, @@finalizer)\r\n          end\r\n        end\r\n      end","code-length":94,"reference":"Create a strong reference to the object.","result":"Store the object's strong reference.","score":[0.1915,0.1471]}
{"code":"# is used to<extra_id_0>\r\ndef object\r\n      @ref.__getobj__\r\n    rescue => e\r\n      if (defined?(RefError) && e.is_a?(RefError)) || (defined?(::WeakRef::RefError) && e.is_a?(::WeakRef::RefError))\r\n        nil\r\n      else\r\n        raise e\r\n      end\r\n    end","code-length":98,"reference":"This implementation of a weak reference simply wraps the standard WeakRef implementation that comes with the Ruby standard library.","result":"Get the object.","score":[0.002,0.0575]}
{"code":"# is used to<extra_id_0>\r\ndef delete(key)\r\n      @lock.synchronize do\r\n        rkey = ref_key(key)\r\n        if rkey\r\n          @references_to_keys_map.delete(rkey)\r\n          @values.delete(rkey)\r\n        else\r\n          nil\r\n        end\r\n      end\r\n    end","code-length":90,"reference":"Remove the value associated with the key from the map.","result":"Delete the reference.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef monitor(reference)\r\n      obj = reference.object\r\n      if obj\r\n        @lock.synchronize do\r\n          @references[reference.referenced_object_id] = reference\r\n        end\r\n        ObjectSpace.define_finalizer(obj, @finalizer)\r\n      else\r\n        push(reference)\r\n      end\r\n    end","code-length":93,"reference":"Monitor a reference.","result":"Monitor the reference.","score":[0.4855,0.3333]}
{"code":"# is used to<extra_id_0>\r\ndef client(options={})\r\n      @client ||= ::OAuth2::Client.new(client_id, client_secret,\r\n        {\r\n          :site          => options.fetch(:site) { Nimbu.site },\r\n          :authorize_url => 'login\/oauth\/authorize',\r\n          :token_url     => 'login\/oauth\/access_token',\r\n          :ssl           => { :verify => false }\r\n        }\r\n      )\r\n    end","code-length":120,"reference":"Setup OAuth2 instance","result":"Initialize the client.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef default_middleware(options={})\r\n      Proc.new do |builder|\r\n        unless options[:with_attachments]\r\n          builder.use Nimbu::Request::Json\r\n        end\r\n        builder.use Faraday::Request::Multipart\r\n        builder.use Faraday::Request::UrlEncoded\r\n        builder.use Nimbu::Request::OAuth2, oauth_token if oauth_token?\r\n        builder.use Nimbu::Request::BasicAuth, authentication if basic_authed?\r\n        builder.use Nimbu::Request::UserAgent\r\n        builder.use Nimbu::Request::SiteHeader, subdomain\r\n        builder.use Nimbu::Request::ContentLocale, content_locale\r\n        builder.use Faraday::Response::Logger if ENV['DEBUG']\r\n        builder.use Nimbu::Response::RaiseError\r\n        unless options[:raw]\r\n          builder.use Nimbu::Response::Mashify\r\n          builder.use Nimbu::Response::Json\r\n        end\r\n        builder.adapter adapter\r\n      end\r\n    end","code-length":271,"reference":"Default middleware stack that uses default adapter as specified at configuration stage.","result":"Define the default_middleware.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef load\r\n      unless valid_params?\r\n        raise SmartAdapters::Exceptions::InvalidRequestParamsException\r\n      end\r\n      unless valid_format?\r\n        raise SmartAdapters::Exceptions::InvalidRequestFormatException\r\n      end\r\n      adapter_finder.new(request_manager)\r\n    end","code-length":77,"reference":"Initialise SmartAdapters delegator ","result":"Load the adapter.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef error\r\n      {\r\n        error: { \r\n          model: self.object[\"model\"],\r\n          model_human: self.object[\"model_human\"],\r\n          attribute: self.object[\"attribute\"],\r\n          attribute_human: self.object[\"attribute_human\"],\r\n          field: self.object[\"field\"],\r\n          message: self.object[\"message\"],\r\n          full_message: \"#{self.object[\"full_message\"]}\"\r\n        } \r\n      }\r\n    end","code-length":130,"reference":"for standard errors this method build a hash ","result":"Generate the error message.","score":[0,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef setup(options={})\r\n      options.each do |k,v|\r\n        self.set(k,v,true)\r\n      end\r\n      options = Nimbu.options.merge(options)\r\n      self.current_options = options\r\n      Configuration.keys.each do |key|\r\n        send(\"#{key}=\", options[key])\r\n      end\r\n      process_basic_auth(options[:basic_auth])\r\n    end","code-length":119,"reference":"Configure options and process basic authorization","result":"Setup the Nimbu instance.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef arguments(args=(not_set = true), options={}, &block)\r\n      if not_set\r\n        @arguments\r\n      else\r\n        @arguments = Arguments.new(self, options).parse(*args, &block)\r\n      end\r\n    end","code-length":70,"reference":"Acts as setter and getter for api requests arguments parsing.","result":"Set up the arguments.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef reset!\r\n      self.client_id          = DEFAULT_CLIENT_ID\r\n      self.client_secret      = DEFAULT_CLIENT_SECRET\r\n      self.oauth_token        = DEFAULT_OAUTH_TOKEN\r\n      self.endpoint           = DEFAULT_ENDPOINT\r\n      self.site               = DEFAULT_SITE\r\n      self.ssl                = DEFAULT_SSL\r\n      self.user_agent         = DEFAULT_USER_AGENT\r\n      self.connection_options = DEFAULT_CONNECTION_OPTIONS\r\n      self.mime_type          = DEFAULT_MIME_TYPE\r\n      self.login              = DEFAULT_LOGIN\r\n      self.password           = DEFAULT_PASSWORD\r\n      self.basic_auth         = DEFAULT_BASIC_AUTH\r\n      self.auto_pagination    = DEFAULT_AUTO_PAGINATION\r\n      self.content_locale     = DEFAULT_CONTENT_LOCALE\r\n      self.adapter            = DEFAULT_ADAPTER\r\n      self.subdomain          = DEFAULT_SUBDOMAIN\r\n      self\r\n    end","code-length":238,"reference":"Reset configuration options to their defaults","result":"Reset the connection.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef invalid_fts_filters(filters)\r\n      filters.select { |filter|\r\n        category, name, value = filter.values_at('category', 'name', 'value')\r\n        category == 'fts' && name == 'search' && value.to_s.length <= 1\r\n      }.map { |invalid_fts_filter|\r\n        error = <<-MSG.gsub(\/^\\s+\/, '').strip\r\n          Full-text search filter values must be larger than one.\r\n        MSG\r\n        invalid_fts_filter.merge(:error => error)\r\n      }\r\n    end","code-length":154,"reference":"Retrieve the filters that represent invalid full-text search values.","result":"Validate FTS search filters.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef extended(object)\r\n      each_param do |param|\r\n        object.params[param.name] = param.to_instance(object)\r\n      end\r\n    end","code-length":52,"reference":"Ensures that the module will initialize parameters, when extended into an Object.","result":"Extend an object.","score":[0.0203,0.2302]}
{"code":"# is used to<extra_id_0>\r\ndef params=(values)\r\n      values.each do |name,value|\r\n        if has_param?(name)\r\n          get_param(name).value = case value\r\n                                  when Parameters::ClassParam,\r\n                                       Parameters::InstanceParam\r\n                                    value.value\r\n                                  else\r\n                                    value\r\n                                  end\r\n        end\r\n      end\r\n    end","code-length":99,"reference":"Sets the values of the class parameters.","result":"Set the params.","score":[0.1076,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef parameter(name,options={})\r\n      name = name.to_sym\r\n      meta_def(name) do\r\n        get_param(name).value\r\n      end\r\n      meta_def(\"#{name}=\") do |value|\r\n        get_param(name).value = value\r\n      end\r\n      meta_def(\"#{name}?\") do\r\n        !!get_param(name).value\r\n      end\r\n      define_method(name) do\r\n        get_param(name).value\r\n      end\r\n      define_method(\"#{name}=\") do |value|\r\n        get_param(name).value = value\r\n      end\r\n      define_method(\"#{name}?\") do\r\n        !!get_param(name).value\r\n      end\r\n      new_param = Parameters::ClassParam.new(\r\n        name,\r\n        options[:type],\r\n        options[:description],\r\n        options[:default]\r\n      )\r\n      params[name] = new_param\r\n      return new_param\r\n    end","code-length":263,"reference":"Adds a new parameters to the class.","result":"Define parameters.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef has_param?(name)\r\n      name = name.to_sym\r\n      ancestors.each do |ancestor|\r\n        if ancestor.included_modules.include?(Parameters)\r\n          return true if ancestor.params.has_key?(name)\r\n        end\r\n      end\r\n      return false\r\n    end","code-length":86,"reference":"Determines if a class parameter exists with the given name.","result":"Check if a param has been defined.","score":[0.1488,0.2635]}
{"code":"# is used to<extra_id_0>\r\ndef get_param(name)\r\n      name = name.to_sym\r\n      ancestors.each do |ancestor|\r\n        if ancestor.included_modules.include?(Parameters)\r\n          if ancestor.params.has_key?(name)\r\n            return ancestor.params[name]\r\n          end\r\n        end\r\n      end\r\n      raise(Parameters::ParamNotFound,\"parameter #{name.to_s.dump} was not found in class #{self}\")\r\n    end","code-length":121,"reference":"Searches for the class parameter with the matching name.","result":"Get the parameter value.","score":[0.1088,0.1176]}
{"code":"# is used to<extra_id_0>\r\ndef set_param(name,value)\r\n      name = name.to_sym\r\n      ancestors.each do |ancestor|\r\n        if ancestor.included_modules.include?(Parameters)\r\n          if ancestor.params.has_key?(name)\r\n            return ancestor.params[name].set(value)\r\n          end\r\n        end\r\n      end\r\n      raise(Parameters::ParamNotFound,\"parameter #{name.to_s.dump} was not found in class #{self}\")\r\n    end","code-length":127,"reference":"Sets a class parameter.","result":"Set a parameter value.","score":[0.3195,0.4688]}
{"code":"# is used to<extra_id_0>\r\ndef each_param(&block)\r\n      ancestors.reverse_each do |ancestor|\r\n        if ancestor.included_modules.include?(Parameters)\r\n          ancestor.params.each_value(&block)\r\n        end\r\n      end\r\n      return self\r\n    end","code-length":75,"reference":"Iterates over the parameters of the class and it's ancestors.","result":"Iterate parameters.","score":[0,0.0543]}
{"code":"# is used to<extra_id_0>\r\ndef link(*things)\r\n      unless none?\r\n        raise \"Illegal state for link: #{state}\"\r\n      end\r\n      things.each do |thing|\r\n        case thing\r\n          when DataMapper::Adapters::AbstractAdapter\r\n            @adapters[thing] = :none\r\n          when DataMapper::Repository\r\n            link(thing.adapter)\r\n          when DataMapper::Model\r\n            link(*thing.repositories)\r\n          when DataMapper::Resource\r\n            link(thing.model)\r\n          when Array\r\n            link(*thing)\r\n          else\r\n            raise \"Unknown argument to #{self.class}\r\n        end\r\n      end\r\n      if block_given?\r\n        commit { |*block_args| yield(*block_args) }\r\n      else\r\n        self\r\n      end\r\n    end","code-length":206,"reference":"Create a new Transaction constructor.","result":"Link to other objects.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef commit\r\n      if block_given?\r\n        unless none?\r\n          raise \"Illegal state for commit with block: #{state}\"\r\n        end\r\n        begin\r\n          self.begin\r\n          rval = within { |*block_args| yield(*block_args) }\r\n        rescue Exception => exception\r\n          if begin?\r\n            rollback\r\n          end\r\n          raise exception\r\n        ensure\r\n          unless exception\r\n            if begin?\r\n              commit\r\n            end\r\n            return rval\r\n          end\r\n        end\r\n      else\r\n        unless begin?\r\n          raise \"Illegal state for commit without block: #{state}\"\r\n        end\r\n        each_adapter(:commit_adapter, [:log_fatal_transaction_breakage])\r\n        each_adapter(:close_adapter, [:log_fatal_transaction_breakage])\r\n        self.state = :commit\r\n      end\r\n    end","code-length":226,"reference":"Commit the transaction","result":"Commit transaction.","score":[0.3033,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef within\r\n      unless block_given?\r\n        raise 'No block provided'\r\n      end\r\n      unless begin?\r\n        raise \"Illegal state for within: #{state}\"\r\n      end\r\n      adapters = @adapters\r\n      adapters.each_key do |adapter|\r\n        adapter.push_transaction(self)\r\n      end\r\n      begin\r\n        yield self\r\n      ensure\r\n        adapters.each_key do |adapter|\r\n          adapter.pop_transaction\r\n        end\r\n      end\r\n    end","code-length":135,"reference":"Execute a block within this Transaction.","result":"Define within.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef next_message\r\n      read_header         if @state == :header\r\n      read_payload_length if @state == :payload_length\r\n      read_mask_key       if @state == :mask\r\n      read_payload        if @state == :payload\r\n      @state == :complete ? process_frame! : nil\r\n    rescue StandardError => ex\r\n      if @on_error\r\n        @on_error.call(ex.message)\r\n      else\r\n        raise ex\r\n      end\r\n    end","code-length":131,"reference":"Parse next message in buffer","result":"Determine the next message.","score":[0.2488,0.102]}
{"code":"# is used to<extra_id_0>\r\ndef reporter(query, options={}, &block)\r\n      @report ||= QueryReport::Report.new(params, view_context, options)\r\n      @report.query = query\r\n      @report.instance_eval &block\r\n      render_report(options) unless options[:skip_rendering]\r\n      @report\r\n    end","code-length":86,"reference":"Generates the reports ","result":"Generate the reporter.","score":[0.4082,0.625]}
{"code":"# is used to<extra_id_0>\r\ndef infer_type(field_name)\r\n      case field_name\r\n      when :email, :time_zone\r\n        field_name\r\n      when %r{(\\b|_)password(\\b|_)}\r\n        :password\r\n      else\r\n        type_mappings = {text: :textarea}\r\n        db_type = @object.column_for_attribute(field_name).type\r\n        case db_type\r\n        when :text\r\n          :textarea\r\n        when :decimal, :integer, :float\r\n          :numeric\r\n        else\r\n          db_type\r\n        end\r\n      end\r\n    end","code-length":160,"reference":"Infers the type of field to render based on the field name.","result":"Identify the type of the field.","score":[0.1572,0.3289]}
{"code":"# is used to<extra_id_0>\r\ndef validate_instance_node(instance_node)\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tvalidations_passed = !self.node_validations.collect { |node_validation|\r\n\t\t\t\tnode_validation.validate_instance_node(instance_node, self)\r\n\t\t\t}.include?(false)\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tparent_validations_passed = !self.survey.node_maps.select { |i| i.node == self}.collect { |node_map|\r\n\t\t\t\tif node_map.parent\r\n\t\t\t\t\tnode_map.parent.node.validate_parent_instance_node(instance_node, self)\r\n\t\t\t\t\r\n\t\t\t\telse\r\n\t\t\t\t\ttrue\r\n\t\t\t\tend\r\n\t\t\t}.include?(false)\r\n\t\t\tvalidations_passed && parent_validations_passed\r\n\t\tend","code-length":217,"reference":"Run all validations applied to this node","result":"Validate the instance node.","score":[0,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef instance_node_path_to_root?(instance_node)\r\n\t\t\tinstance_nodes = instance_node.instance.instance_nodes.select { |i| i.node == self }\r\n\t\t\t\r\n\t\t\tif self.class.ancestors.include?(::ActiveRecordSurvey::Node::Answer) &&\r\n\t\t\t\t(instance_nodes.length === 0)\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tif self.class.ancestors.include?(::ActiveRecordSurvey::Node::Question) &&\r\n\t\t\t\t(self.answers.length === 0) && \r\n\t\t\t\t(instance_nodes.length === 0)\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tpaths = self.survey.node_maps.select { |i| i.node == self }.collect { |node_map|\r\n\t\t\t\t\r\n\t\t\t\tif node_map.parent\r\n\t\t\t\t\tnode_map.parent.node.instance_node_path_to_root?(instance_node)\r\n\t\t\t\t\r\n\t\t\t\telse\r\n\t\t\t\t\ttrue\r\n\t\t\t\tend\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpaths.include?(true)\r\n\t\tend","code-length":293,"reference":"Whether there is a valid answer path from this node to the root node for the instance","result":"Determine if the instance node path to root is the same as the instance node.","score":[0.123,0.3476]}
{"code":"# is used to<extra_id_0>\r\ndef build_link(to_node)\r\n\t\t\t\r\n\t\t\tif !to_node.class.ancestors.include?(::ActiveRecordSurvey::Node::Question)\r\n\t\t\t\traise ArgumentError.new \"to_node must inherit from ::ActiveRecordSurvey::Node::Question\"\r\n\t\t\tend\r\n\t\t\tif self.survey.nil?\r\n\t\t\t\traise ArgumentError.new \"A survey is required before calling\r\n\t\t\tend\r\n\t\t\tfrom_node_maps = self.survey.node_maps.select { |i| i.node == self && !i.marked_for_destruction? }\r\n\t\t\t\r\n\t\t\tif from_node_maps.select { |i|\r\n\t\t\t\ti.children.length > 0\r\n\t\t\t}.length > 0\r\n\t\t\t\traise RuntimeError.new \"This node has already been linked\" \r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tto_node_maps = self.survey.node_maps.select { |i| i.node == to_node && !i.marked_for_destruction? }\r\n\t\t\tif to_node_maps.first.nil?\r\n\t\t\t\tto_node_maps << self.survey.node_maps.build(:survey => self.survey, :node => to_node)\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tto_node_map = to_node_maps.first\r\n\t\t\tto_node_map.survey = self.survey\r\n\t\t\t\r\n\t\t\tto_node_maps = to_node_maps.select { |i| i.parent.nil? }\r\n\t\t\twhile to_node_maps.length < from_node_maps.length do\r\n\t\t\t\tto_node_maps.push(to_node_map.recursive_clone)\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tfrom_node_maps.each_with_index { |from_node_map, index|\r\n\t\t\t\tfrom_node_map.children << to_node_maps[index]\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfrom_node_maps.each { |node_map|\r\n\t\t\t\t\r\n\t\t\t\tif node_map.has_infinite_loop?\r\n\t\t\t\t\traise RuntimeError.new \"Infinite loop detected\"\r\n\t\t\t\tend\r\n\t\t\t}\r\n\t\tend","code-length":544,"reference":"Build a link from this node to another node","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef before_destroy_rebuild_node_map\r\n\t\t\t\t\r\n\t\t\t\tself.survey.node_maps.select { |i|\r\n\t\t\t\t\ti.node == self\r\n\t\t\t\t}.each { |node_map|\r\n\t\t\t\t\t\r\n\t\t\t\t\tnode_map.children.each  { |child|\r\n\t\t\t\t\t\tnode_map.parent.children << child\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ttrue\r\n\t\t\tend","code-length":113,"reference":"Before a node is destroyed, will re-build the node_map links from parent to child if they exist","result":"Rebuild node map.","score":[0.0038,0.0321]}
{"code":"# is used to<extra_id_0>\r\ndef validate_instance_node(instance_node)\r\n\t\t\t\r\n\t\t\tsuper &&\r\n\t\t\t(instance_node.value.to_s.empty? || !instance_node.value.to_s.match(\/^(\\d+(\\.\\d+)?)$\/).nil?)\r\n\t\tend","code-length":77,"reference":"Accept integer, float, or empty values","result":"Validate the instance node.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef is_answered_for_instance?(instance)\r\n\t\t\tif instance_node = self.instance_node_for_instance(instance)\r\n\t\t\t\t\r\n\t\t\t\t!instance_node.value.to_s.empty? && instance_node.value.to_i >= 0\r\n\t\t\telse\r\n\t\t\t\tfalse\r\n\t\t\tend\r\n\t\tend","code-length":95,"reference":"Scale answers are considered answered if they have a value of greater than \"0\"","result":"Check answered for instance.","score":[0.0262,0.0385]}
{"code":"# is used to<extra_id_0>\r\ndef is_answered_for_instance?(instance)\r\n\t\t\tif instance_node = self.instance_node_for_instance(instance)\r\n\t\t\t\t\r\n\t\t\t\tinstance_node.value.to_s.strip.length > 0\r\n\t\t\telse\r\n\t\t\t\tfalse\r\n\t\t\tend\r\n\t\tend","code-length":85,"reference":"Text answers are considered answered if they have text entered","result":"Check answered for instance.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef recursive_clone\r\n\t\t\tnode_map = self.survey.node_maps.build(:survey => self.survey, :node => self.node)\r\n\t\t\tself.survey.node_maps.select { |i| i.parent == self && !i.marked_for_destruction? }.each { |child_node|\r\n\t\t\t\tchild_node.survey = self.survey\r\n\t\t\t\tnode_map.children << child_node.recursive_clone\r\n\t\t\t}\r\n\t\t\tnode_map\r\n\t\tend","code-length":135,"reference":"Recursively creates a copy of this entire node_map","result":"Recursively clone the node.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef ancestors_until_node_not_ancestor_of(klass)\r\n\t\t\tif !self.parent || !self.node.class.ancestors.include?(klass)\r\n\t\t\t\treturn []\r\n\t\t\tend\r\n\t\t\t[self] + self.parent.ancestors_until_node_not_ancestor_of(klass)\r\n\t\tend","code-length":92,"reference":"Gets all the ancestor nodes until one is not an ancestor of klass","result":"Find ancestors.","score":[0,0.042]}
{"code":"# is used to<extra_id_0>\r\ndef children_until_node_not_ancestor_of(klass)\r\n\t\t\tif !self.node.class.ancestors.include?(klass)\r\n\t\t\t\treturn []\r\n\t\t\tend\r\n\t\t\t[self] + self.children.collect { |i|\r\n\t\t\t\ti.children_until_node_not_ancestor_of(klass)\r\n\t\t\t}\r\n\t\tend","code-length":102,"reference":"Gets all the child nodes until one is not an ancestor of klass","result":"Collect children.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef has_infinite_loop?(path = [])\r\n\t\t\tself.survey.node_maps.select { |i| i.parent == self && !i.marked_for_destruction? }.each { |i|\r\n\t\t\t\t\r\n\t\t\t\tif path.include?(self.node) || i.has_infinite_loop?(path.clone.push(self.node))\r\n\t\t\t\t\treturn true\r\n\t\t\t\tend\r\n\t\t\t}\r\n\t\t\tpath.include?(self.node)\r\n\t\tend","code-length":136,"reference":"Check to see whether there is an infinite loop from this node_map","result":"Check if the node has an infinite loop.","score":[0.1318,0.2203]}
{"code":"# is used to<extra_id_0>\r\ndef validate_instance_node(instance_node, answer_node = nil)\r\n\t\t\tis_valid = (!instance_node.value.to_s.empty? && instance_node.value.to_f >= self.value.to_f)\r\n\t\t\tinstance_node.errors[:base] << { :nodes => { answer_node.id => [\"MINIMUM_VALUE\"] } } if !is_valid\r\n\t\t\tis_valid\r\n\t\tend","code-length":115,"reference":"Validate the instance_node value is greater than the minimum","result":"Validate the instance node.","score":[0.1294,0.1176]}
{"code":"# is used to<extra_id_0>\r\ndef validate_instance_node(instance_node, question_node = nil)\r\n\t\t\t\r\n\t\t\tif !question_node.class.ancestors.include?(::ActiveRecordSurvey::Node::Question)\r\n\t\t\t\treturn false \r\n\t\t\tend\r\n\t\t\tinstance = instance_node.instance\r\n\t\t\t\r\n\t\t\ttotal_answered = question_node.node_maps.collect { |question_node_map|\r\n\t\t\t\t\r\n\t\t\t\tquestion_node_map.children.collect { |i|\r\n\t\t\t\t\ti.children_until_node_not_ancestor_of(::ActiveRecordSurvey::Node::Answer)\r\n\t\t\t\t}.flatten.collect { |i|\r\n\t\t\t\t\ti.node.is_answered_for_instance?(instance)\r\n\t\t\t\t}\r\n\t\t\t}.flatten.select { |i| i }.count\r\n\t\t\tis_valid = (total_answered >= self.value.to_i)\r\n\t\t\tinstance_node.errors[:base] << { :nodes => { question_node.id => [\"MINIMUM_ANSWER\"] } } if !is_valid\r\n\t\t\tis_valid\r\n\t\tend","code-length":279,"reference":"Validate the instance_node to ensure a minimum number of answers are made","result":"Validate the instance node.","score":[0.0611,0.1674]}
{"code":"# is used to<extra_id_0>\r\ndef validate_node(instance)\r\n\t\t\t\r\n\t\t\t!self.survey.node_maps.select { |i|\r\n\t\t\t\ti.node == self\r\n\t\t\t}.collect { |node_map|\r\n\t\t\t\tnode_map.parent.node.validate_node(instance)\r\n\t\t\t}.include?(false)\r\n\t\tend","code-length":91,"reference":"Validate this node against an instance","result":"Validate the node.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef question\r\n\t\t\tself.survey.node_maps.select { |i|\r\n\t\t\t\ti.node == self\r\n\t\t\t}.collect { |node_map|\r\n\t\t\t\tif node_map.parent && node_map.parent.node\r\n\t\t\t\t\t\r\n\t\t\t\t\tif node_map.parent.node.class.ancestors.include?(::ActiveRecordSurvey::Node::Answer)\r\n\t\t\t\t\t\tnode_map.parent.node.question\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnode_map.parent.node\r\n\t\t\t\t\tend\r\n\t\t\t\t\r\n\t\t\t\telse\r\n\t\t\t\t\tnil\r\n\t\t\t\tend\r\n\t\t\t}.first\r\n\t\tend","code-length":163,"reference":"Returns the question that preceeds this answer","result":"Identify the question.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef next_question\r\n\t\t\tself.survey.node_maps.select { |i|\r\n\t\t\t\ti.node == self && !i.marked_for_destruction?\r\n\t\t\t}.each { |answer_node_map|\r\n\t\t\t\tanswer_node_map.children.each { |child|\r\n\t\t\t\t\tif !child.node.nil? && !child.marked_for_destruction?\r\n\t\t\t\t\t\tif child.node.class.ancestors.include?(::ActiveRecordSurvey::Node::Question)\r\n\t\t\t\t\t\t\treturn child.node\r\n\t\t\t\t\t\telsif child.node.class.ancestors.include?(::ActiveRecordSurvey::Node::Answer)\r\n\t\t\t\t\t\t\treturn child.node.next_question \r\n\t\t\t\t\t\tend\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn nil\r\n\t\t\t\t\tend\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn nil\r\n\t\tend","code-length":225,"reference":"Returns the question that follows this answer","result":"Determine the next question.","score":[0.1509,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef remove_link\r\n\t\t\t\r\n\t\t\treturn true if (question = self.next_question).nil?\r\n\t\t\tcount = 0\r\n\t\t\tto_remove = []\r\n\t\t\tself.survey.node_maps.each { |node_map|\r\n\t\t\t\tif node_map.node == question\r\n\t\t\t\t\tif count > 0\r\n\t\t\t\t\t\tto_remove.concat(node_map.self_and_descendants)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tnode_map.parent = nil\r\n\t\t\t\t\t\tnode_map.move_to_root unless node_map.new_record?\r\n\t\t\t\t\tend\r\n\t\t\t\t\tcount = count + 1\r\n\t\t\t\tend\r\n\t\t\t\tif node_map.node == self\r\n\t\t\t\t\tnode_map.children = []\r\n\t\t\t\tend\r\n\t\t\t}\r\n\t\t\tself.survey.node_maps.each { |node_map|\r\n\t\t\t\tif to_remove.include?(node_map)\r\n\t\t\t\t\tnode_map.parent = nil\r\n\t\t\t\t\tnode_map.mark_for_destruction\r\n\t\t\t\tend\r\n\t\t\t}\r\n\t\tend","code-length":276,"reference":"Removes the node_map from this answer to its next question","result":"Remove links.","score":[0,0.0543]}
{"code":"# is used to<extra_id_0>\r\ndef sibling_index\r\n\t\t\tnode_maps = self.survey.node_maps\r\n\t\t\tif node_map = node_maps.select { |i| i.node == self }.first\r\n\t\t\t\tparent = node_map.parent\r\n\t\t\t\tchildren = node_maps.select { |i| i.parent && i.parent.node === parent.node }\r\n\t\t\t\tchildren.each_with_index { |nm, i|\r\n\t\t\t\t\tif nm == node_map\r\n\t\t\t\t\t\treturn i\r\n\t\t\t\t\tend\r\n\t\t\t\t}\r\n\t\t\tend\r\n\t\tend","code-length":147,"reference":"Gets index in sibling relationship","result":"Determine the index of the sibling.","score":[0.193,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef move_up\r\n\t\t\tself.survey.node_maps.select { |i|\r\n\t\t\t\ti.node == self\r\n\t\t\t}.collect { |node_map|\r\n\t\t\t\tbegin\r\n\t\t\t\t\tnode_map.move_left\r\n\t\t\t\trescue\r\n\t\t\t\tend\r\n\t\t\t}\r\n\t\tend","code-length":88,"reference":"Moves answer up relative to other answers","result":"Move the node up.","score":[0,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef move_down\r\n\t\t\tself.survey.node_maps.select { |i|\r\n\t\t\t\ti.node == self\r\n\t\t\t}.collect { |node_map|\r\n\t\t\t\tbegin\r\n\t\t\t\t\tnode_map.move_right\r\n\t\t\t\trescue\r\n\t\t\t\tend\r\n\t\t\t}\r\n\t\tend","code-length":88,"reference":"Moves answer down relative to other answers","result":"Move the node down.","score":[0,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef validate_instance_node(instance_node)\r\n\t\t\t\r\n\t\t\tsuper &&\r\n\t\t\t(instance_node.value.to_s.empty? || !instance_node.value.to_s.match(\/^\\d+$\/).nil?) &&\r\n\t\t\t(instance_node.value.to_s.empty? || instance_node.value.to_i >= 1) &&\r\n\t\t\tinstance_node.value.to_i <= self.max_rank\r\n\t\tend","code-length":123,"reference":"Accept integer or empty values","result":"Validate the instance node.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef num_above\r\n\t\t\tcount = 0\r\n\t\t\tself.node_maps.each { |i|\r\n\t\t\t\t\r\n\t\t\t\tif i.parent.node.class.ancestors.include?(self.class)\r\n\t\t\t\t\tcount = count + 1 + i.parent.node.num_above\r\n\t\t\t\tend\r\n\t\t\t}\r\n\t\t\tcount\r\n\t\tend","code-length":100,"reference":"Calculate the number of Rank nodes above this one","result":"Calculate the number of nodes above the class.","score":[0.4489,0.5743]}
{"code":"# is used to<extra_id_0>\r\ndef num_below\r\n\t\t\tcount = 0\r\n\t\t\tself.node_maps.each { |node_map|\r\n\t\t\t\tnode_map.children.each { |child|\r\n\t\t\t\t\t\r\n\t\t\t\t\tif child.node.class.ancestors.include?(self.class)\r\n\t\t\t\t\t\tcount = count + 1 + child.node.num_below\r\n\t\t\t\t\tend\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcount\r\n\t\tend","code-length":118,"reference":"Calculate the number of Rank nodes below this one","result":"Calculate the number of nodes below this class.","score":[0.5247,0.7773]}
{"code":"# is used to<extra_id_0>\r\ndef validate_instance_node(instance_node, answer_node = nil)\r\n\t\t\tis_valid = (self.value.to_i >= instance_node.value.to_s.length.to_i)\r\n\t\t\tinstance_node.errors[:base] << { :nodes => { answer_node.id => [\"MAXIMUM_LENGTH\"] } } if !is_valid\r\n\t\t\tis_valid\r\n\t\tend","code-length":108,"reference":"Validate the instance_node value","result":"Validate the instance node.","score":[0.4518,0.4688]}
{"code":"# is used to<extra_id_0>\r\ndef build_first_question(question_node)\r\n\t\t\tif !question_node.class.ancestors.include?(::ActiveRecordSurvey::Node::Question)\r\n\t\t\t\traise ArgumentError.new \"must inherit from ::ActiveRecordSurvey::Node::Question\"\r\n\t\t\tend\r\n\t\t\tquestion_node_maps = self.node_maps.select { |i| i.node == question_node && !i.marked_for_destruction? }\r\n\t\t\t\r\n\t\t\tif question_node_maps.length === 0\r\n\t\t\t\t\r\n\t\t\t\tquestion_node_maps << self.node_maps.build(:node => question_node, :survey => self)\r\n\t\t\tend\r\n\t\tend","code-length":174,"reference":"Builds first question","result":"Build the first question.","score":[0.3195,0.3226]}
{"code":"# is used to<extra_id_0>\r\ndef edges\r\n\t\t\tself.node_maps.select { |i| !i.marked_for_destruction? }.select { |i|\r\n\t\t\t\ti.node && i.parent\r\n\t\t\t}.collect { |i|\r\n\t\t\t\t{\r\n\t\t\t\t\t:source => i.parent.node.id,\r\n\t\t\t\t\t:target => i.node.id,\r\n\t\t\t\t}\r\n\t\t\t}.uniq\r\n\t\tend","code-length":115,"reference":"All the connective edges","result":"Create the graph.","score":[0.2925,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef validate_parent_instance_node(instance_node, child_node)\r\n\t\t\t!self.node_validations.collect { |node_validation|\r\n\t\t\t\tnode_validation.validate_instance_node(instance_node, self)\r\n\t\t\t}.include?(false)\r\n\t\tend","code-length":80,"reference":"Stop validating at the Question node","result":"Validate the parent instance node.","score":[0.1967,0.1695]}
{"code":"# is used to<extra_id_0>\r\ndef update_question_type(klass)\r\n\t\t\tif self.next_questions.length > 0\r\n\t\t\t\traise RuntimeError.new \"No questions can follow when changing the question type\" \r\n\t\t\tend\r\n\t\t\tnm = self.survey.node_maps\r\n\t\t\tanswers = self.answers.collect { |answer|\r\n\t\t\t\tnm.select { |i|\r\n\t\t\t\t\ti.node == answer\r\n\t\t\t\t}\r\n\t\t\t}.flatten.uniq.collect { |answer_node_map|\r\n\t\t\t\tnode = answer_node_map.node\r\n\t\t\t\tanswer_node_map.send((answer_node_map.new_record?)? :destroy : :mark_for_destruction)\r\n\t\t\t\tnode\r\n\t\t\t}.collect { |answer|\r\n\t\t\t\tanswer.type = klass.to_s\r\n\t\t\t\tanswer = answer.becomes(klass)\r\n\t\t\t\tanswer.save if !answer.new_record?\r\n\t\t\t\tanswer\r\n\t\t\t}.uniq\r\n\t\t\tanswers.each { |answer|\r\n\t\t\t\tanswer.survey = self.survey\r\n\t\t\t\tself.build_answer(answer)\r\n\t\t\t}\r\n\t\tend","code-length":287,"reference":"Updates the answers of this question to a different type","result":"Update the question type of the.","score":[0.1402,0.3875]}
{"code":"# is used to<extra_id_0>\r\ndef remove_answer(answer_node)\r\n\t\t\t\r\n\t\t\tif self.survey.nil?\r\n\t\t\t\traise ArgumentError.new \"A survey must be passed if ActiveRecordSurvey::Node::Question is not yet added to a survey\"\r\n\t\t\tend\r\n\t\t\tif !answer_node.class.ancestors.include?(::ActiveRecordSurvey::Node::Answer)\r\n\t\t\t\traise ArgumentError.new \"::ActiveRecordSurvey::Node::Answer not passed\"\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif !self.answers.include?(answer_node)\r\n\t\t\t\traise ArgumentError.new \"Answer not linked to question\"\r\n\t\t\tend\r\n\t\t\tanswer_node.send(:remove_answer, self)\r\n\t\tend","code-length":182,"reference":"Removes an answer","result":"Remove an answer from the survey.","score":[0.273,0.8923]}
{"code":"# is used to<extra_id_0>\r\ndef build_answer(answer_node)\r\n\t\t\t\r\n\t\t\tif self.survey.nil?\r\n\t\t\t\traise ArgumentError.new \"A survey must be passed if ActiveRecordSurvey::Node::Question is not yet added to a survey\"\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif !self.answers.select { |answer|\r\n\t\t\t\tanswer.class != answer_node.class\r\n\t\t\t}.empty?\r\n\t\t\t\traise ArgumentError.new \"Cannot mix answer types on question\"\r\n\t\t\tend\r\n\t\t\t\r\n\t\t\tif answer_node.send(:build_answer, self)\r\n\t\t\t\t\r\n\t\t\t\tself.survey.node_maps.select { |i|\r\n\t\t\t\t\ti.node == answer_node && !i.marked_for_destruction?\r\n\t\t\t\t}.each { |answer_node_map|\r\n\t\t\t\t\tself.survey.node_maps.select { |j|\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t!j.marked_for_destruction? &&\r\n\t\t\t\t\t\tj.parent == answer_node_map.parent && j.node.class.ancestors.include?(::ActiveRecordSurvey::Node::Question)\r\n\t\t\t\t\t}.each { |j|\r\n\t\t\t\t\t\tanswer_node_map.survey = self.survey\r\n\t\t\t\t\t\tj.survey = self.survey\r\n\t\t\t\t\t\tanswer_node_map.children << j\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ttrue\r\n\t\t\tend\r\n\t\tend","code-length":359,"reference":"Build an answer off this node","result":"Build an answer for a question.","score":[0.3976,0.4907]}
{"code":"# is used to<extra_id_0>\r\ndef remove_link\r\n\t\t\treturn true if (questions = self.next_questions).length === 0\r\n\t\t\t\r\n\t\t\tself.survey.node_maps.select { |i|\r\n\t\t\t\ti.node == self\r\n\t\t\t}.each { |node_map|\r\n\t\t\t\tself.survey.node_maps.select { |j|\r\n\t\t\t\t\tnode_map.children.include?(j) \r\n\t\t\t\t}.each { |child|\r\n\t\t\t\t\tif child.node.class.ancestors.include?(::ActiveRecordSurvey::Node::Question)\r\n\t\t\t\t\t\tchild.parent = nil\r\n\t\t\t\t\t\tchild.send((child.new_record?)? :destroy : :mark_for_destruction )\r\n\t\t\t\t\tend\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tself.answers.collect { |i|\r\n\t\t\t\ti.remove_link\r\n\t\t\t}\r\n\t\tend","code-length":227,"reference":"Removes the node_map link from this question all of its next questions","result":"Remove the link to the survey node.","score":[0.094,0.1304]}
{"code":"# is used to<extra_id_0>\r\ndef before_destroy_rebuild_node_map\r\n\t\t\t\tself.survey.node_maps.select { |i|\r\n\t\t\t\t\ti.node == self\r\n\t\t\t\t}.each { |node_map|\r\n\t\t\t\t\t\r\n\t\t\t\t\tnode_map.children.each  { |child|\r\n\t\t\t\t\t\tif !child.node.class.ancestors.include?(::ActiveRecordSurvey::Node::Answer)\r\n\t\t\t\t\t\t\tnode_map.parent.children << child\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ttrue\r\n\t\t\tend","code-length":143,"reference":"Before a node is destroyed, will re-build the node_map links from parent to child if they exist","result":"Rebuild node map.","score":[0.0038,0.0321]}
{"code":"# is used to<extra_id_0>\r\ndef table_for(collection, *args, &block)\r\n      block = Tabletastic.default_table_block unless block_given?\r\n      klass = default_class_for(collection)\r\n      options = args.extract_options!\r\n      initialize_html_options(options, klass)\r\n      result = capture { block.call(TableBuilder.new(collection, klass, self)) }\r\n      content_tag(:table, result, options[:html])\r\n    end","code-length":119,"reference":"returns and outputs a table for the given active record collection","result":"Create a table.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef default_class_for(collection)\r\n      if collection.respond_to?(:klass)\r\n        collection.klass\r\n      elsif !collection.empty?\r\n        collection.first.class\r\n      end\r\n    end","code-length":62,"reference":"Finds the class representing the objects within the collection","result":"Create the class.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef events_for_targets(*list)\r\n      found_events = Array(list).flatten.compact.map {|s| events_for_target(s) }.flatten.compact\r\n      found_events\r\n    end","code-length":61,"reference":"Return all the events for all the specified targets.","result":"Generate the generated code.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef writer\r\n      @writer ||= begin\r\n        writer_matching_existing_parser = supported_writers.find { |writer| writer.format == format }\r\n        writer_matching_existing_parser || default_writer\r\n      end\r\n    end","code-length":67,"reference":"The writer for this view. If the view has already been parsed then use","result":"Create a new parser.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef animate(actor_or_actor_name,options,&block)\r\n      options[:actor] = actor(actor_or_actor_name)\r\n      options[:context] = self\r\n      animation_group = SceneAnimation.build options, &block\r\n      enqueue animation_group\r\n    end","code-length":78,"reference":"Define an animation from within another animation block, an event block or a method.","result":"Animate the scene.","score":[0,0.0388]}
{"code":"# is used to<extra_id_0>\r\ndef on_mouse_movement(*args,&block)\r\n      options = (args.last.is_a?(Hash) ? args.pop : {})\r\n      @mouse_movement_actions << ( block || lambda { |instance| send(options[:do]) } )\r\n    end","code-length":77,"reference":"Register for mouse movements events.","result":"Set the mouse movement.","score":[0.2488,0.102]}
{"code":"# is used to<extra_id_0>\r\ndef notification(param,&block)\r\n      custom_notifications[param.to_sym] = custom_notifications[param.to_sym] + [ block ]\r\n    end","code-length":49,"reference":"Register for a custom notification event.","result":"Add custom notifications.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef fire_events_for_held_buttons\r\n      held_actions.each do |key,action|\r\n        execute_block_for_target(&action) if window and window.button_down?(key)\r\n      end\r\n    end","code-length":68,"reference":"Fire the events mapped to the held buttons within the context of the specified target.","result":"Fire events for held buttons.","score":[0.0428,0.1071]}
{"code":"# is used to<extra_id_0>\r\ndef fire_events_for_notification(event,sender)\r\n      notification_actions = custom_notifications[event]\r\n      notification_actions.each do |action|\r\n        _fire_event_for_notification(event,sender,action)\r\n      end\r\n    end","code-length":73,"reference":"Fire all events mapped to the matching notification.","result":"Fire events for notifications.","score":[0.1398,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef _fire_event_for_notification(event,sender,action)\r\n      if action.arity == 2\r\n        target.instance_exec(sender,event,&action)\r\n      elsif action.arity == 1\r\n        target.instance_exec(sender,&action)\r\n      else\r\n        target.instance_eval(&action)\r\n      end\r\n    end","code-length":97,"reference":"Fire a single event based on the matched notification.","result":"Fire the event for notification.","score":[0.1527,0.2326]}
{"code":"# is used to<extra_id_0>\r\ndef add(model)\r\n      all_models_for(model).each do |model|\r\n        models_hash[model.to_s] = model.to_s\r\n        name_with_slashes = model.model_name\r\n        models_hash[name_with_slashes] = model.to_s\r\n        name_with_colons  = name_with_slashes.gsub('\/','::')\r\n        models_hash[name_with_colons] = model.to_s\r\n      end\r\n    end","code-length":135,"reference":"Add a model, and all it's subclasses, to the list of available models.","result":"Add new models.","score":[0.0173,0.0833]}
{"code":"# is used to<extra_id_0>\r\ndef after_initialize\r\n      to.each do |attribute,final|\r\n        start = actor.send(attribute)\r\n        animations.push build_animation_step(attribute,start,final)\r\n      end\r\n    end","code-length":62,"reference":"Additional initializion is required to calculate the attributes that are going to be animated and to determine each of their deltas.","result":"Initialize the actor.","score":[0.001,0.026]}
{"code":"# is used to<extra_id_0>\r\ndef fire_events_for_notification(event,sender)\r\n      current_state.each {|cs| cs.fire_events_for_notification(event,sender) }\r\n    end","code-length":53,"reference":"Fire notification events within the current game state","result":"Fire the events for a notification.","score":[0.182,0.1923]}
{"code":"# is used to<extra_id_0>\r\ndef add_events_for_target(target,events)\r\n      relay = EventRelay.new(target,window)\r\n      events.each do |target_event|\r\n        relay.send target_event.event, *target_event.buttons, &target_event.block\r\n      end\r\n      current_state.push relay\r\n    end","code-length":90,"reference":"An an event relay to the current game state","result":"Add events to a target.","score":[0.108,0.1163]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(name,*params,&block)\r\n      options = params.find {|param| param.is_a? Hash }\r\n      define_control(name,options)\r\n    end","code-length":57,"reference":"Creation through controls is usually done with an instance_eval of a block and this allows for a flexible interface.","result":"Define the control.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef start!\r\n      @window = Window.new width, height, fullscreen?\r\n      window.caption = name\r\n      window.scene = Scenes.generate(first_scene)\r\n      window.show\r\n    end","code-length":63,"reference":"Creates a window and starts the game with the game parameters.","result":"Start the application.","score":[0.0284,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef show\r\n      rectangle.color = starting_color\r\n      color = final_color\r\n      animate :rectangle, to: { red: color.red,\r\n                                green: color.green,\r\n                                blue: color.blue,\r\n                                alpha: color.alpha },\r\n                          interval: interval do\r\n        transition_to next_scene\r\n      end\r\n    end","code-length":97,"reference":"When the scene is shown set up the starting color for the rectangle and queue the animation to transition the color to the final color.","result":"Show the rectangle.","score":[0.0003,0.0219]}
{"code":"# is used to<extra_id_0>\r\ndef data(*args, &block)\r\n      options = args.extract_options!\r\n      if block_given?\r\n        yield self\r\n      else\r\n        @table_fields = args.empty? ? orm_fields : args.collect {|f| TableField.new(f.to_sym)}\r\n      end\r\n      action_cells(options[:actions], options[:action_prefix])\r\n      [\"\\n\", head, \"\\n\", body, \"\\n\"].join(\"\").html_safe\r\n    end","code-length":129,"reference":"builds up the fields that the table will include, returns table head and body with all data   the table","result":"Create the data block.","score":[0.0089,0.0571]}
{"code":"# is used to<extra_id_0>\r\ndef cell(*args, &proc)\r\n      options = args.extract_options!\r\n      options.merge!(:klass => klass)\r\n      args << options\r\n      @table_fields << TableField.new(*args, &proc)\r\n      return \"\"\r\n    end","code-length":73,"reference":"individually specify a column, which will build up the header, and method or block to call on each resource in the array","result":"Define the cell.","score":[0.0007,0.0249]}
{"code":"# is used to<extra_id_0>\r\ndef action_cells(actions, prefix = nil)\r\n      return if actions.blank?\r\n      actions = [actions] if !actions.respond_to?(:each)\r\n      actions = [:show, :edit, :destroy] if actions == [:all]\r\n      actions.each do |action|\r\n        action_link(action.to_sym, prefix)\r\n      end\r\n    end","code-length":103,"reference":"Used internally to build up cells for common CRUD actions","result":"Generate the actions cells.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef action_link(action, prefix)\r\n      html_class = \"actions #{action.to_s}_link\"\r\n      block = lambda do |resource|\r\n        compound_resource = [prefix, resource].compact\r\n        compound_resource.flatten! if prefix.kind_of?(Array)\r\n        case action\r\n        when :show\r\n          @template.link_to(link_title(action), compound_resource)\r\n        when :destroy\r\n          @template.link_to(link_title(action), compound_resource,\r\n                            :method => :delete, :data => { :confirm => confirmation_message })\r\n        else\r\n          @template.link_to(link_title(action),\r\n                            @template.polymorphic_path(compound_resource, :action => action))\r\n        end\r\n      end\r\n      self.cell(action, :heading => \"\", :cell_html => {:class => html_class}, &block)\r\n    end","code-length":236,"reference":"Dynamically builds links for the action","result":"Generate the link to the resource.","score":[0.193,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef add(scene)\r\n      all_scenes_for(scene).each { |scene| scenes_hash[scene.scene_name] = scene.to_s }\r\n    end","code-length":55,"reference":"Add a scene to the hash of scenes with the scene name of the scene as the key to retrieving this scene.","result":"Add a scene.","score":[0.0011,0.1271]}
{"code":"# is used to<extra_id_0>\r\ndef apply_post_filters(new_scene,options)\r\n      post_filters.inject(new_scene) {|scene,post| post.filter(scene,options) }\r\n    end","code-length":54,"reference":"Apply all the post filtering to the specified scene with the given options ","result":"Apply post filters.","score":[0.0173,0.0833]}
{"code":"# is used to<extra_id_0>\r\ndef hash_with_missing_scene_default\r\n      hash = HashWithIndifferentAccess.new do |hash,key|\r\n        missing_scene = hash[:missing_scene].constantize\r\n        missing_scene.missing_scene = key.to_sym\r\n        missing_scene\r\n      end\r\n      hash[:missing_scene] = \"Metro::MissingScene\"\r\n      hash\r\n    end","code-length":104,"reference":"Create a hash that will return a setup missing scene by default.","result":"Create hash with missing scene.","score":[0.078,0.1327]}
{"code":"# is used to<extra_id_0>\r\ndef all_scenes_for(scenes)\r\n      Array(scenes).map do |scene_class_name|\r\n        scene = scene_class_name.constantize\r\n        [ scene ] + all_scenes_for(scene.scenes)\r\n      end.flatten.compact\r\n    end","code-length":86,"reference":"Returns all subclassed scenes of the scene or scenes provided.","result":"Generate code.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef actor(actor_or_actor_name)\r\n      if actor_or_actor_name.is_a? String or actor_or_actor_name.is_a? Symbol\r\n        send(actor_or_actor_name)\r\n      else\r\n        actor_or_actor_name\r\n      end\r\n    end","code-length":86,"reference":"When an actor is defined, through the class method `draw` a getter and setter method is defined.","result":"Define the actor.","score":[0.0038,0.0321]}
{"code":"# is used to<extra_id_0>\r\ndef notification(event,sender=nil)\r\n      sender = sender || UnknownSender\r\n      state.fire_events_for_notification(event,sender)\r\n    end","code-length":48,"reference":"Post a custom notification event.","result":"Create a new instance of the class.","score":[0.1615,0.0962]}
{"code":"# is used to<extra_id_0>\r\ndef after(ticks,&block)\r\n      tick = OnUpdateOperation.new interval: ticks, context: self\r\n      tick.on_complete(&block)\r\n      enqueue tick\r\n    end","code-length":55,"reference":"Perform an operation after the specified interval.","result":"Trigger the after operation.","score":[0.1795,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef add_actors_to_scene\r\n      self.class.actors.each do |scene_actor|\r\n        actor_instance = scene_actor.create\r\n        actor_instance.scene = self\r\n        send \"#{scene_actor.name}=\", actor_instance\r\n      end\r\n    end","code-length":81,"reference":"Setups up the Actors for the Scene based on the ModelFactories that have been defined.","result":"Add actors to a scene.","score":[0,0.0357]}
{"code":"# is used to<extra_id_0>\r\ndef register_animations!\r\n      self.class.animations.each do |animation|\r\n        animate animation.actor, animation.options, &animation.on_complete_block\r\n      end\r\n    end","code-length":60,"reference":"Register all the animations that were defined for this scene.","result":"Register animations.","score":[0.0092,0.0543]}
{"code":"# is used to<extra_id_0>\r\ndef register_actor(actor_factory)\r\n      registering_actor = actor(actor_factory.name)\r\n      registering_actor.window = window\r\n      registering_actor.show\r\n      drawers.push(registering_actor)\r\n      updaters.push(registering_actor)\r\n      register_events_for_target(registering_actor,registering_actor.class.events)\r\n    end","code-length":106,"reference":"Registering an actor involves setting up the actor within the window, adding them to the list of things that need to be drawn and then registering any eventst that they might have.","result":"Register actor.","score":[0,0.0172]}
{"code":"# is used to<extra_id_0>\r\ndef base_update\r\n      updaters.each { |updater| updater.update }\r\n      update\r\n      updaters.reject! { |updater| updater.update_completed? }\r\n    end","code-length":55,"reference":"The `base_update` method is called by the Game Window.","result":"Update the base object.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef base_draw\r\n      drawers.each { |drawer| drawer.draw }\r\n      draw\r\n      drawers.reject! { |drawer| drawer.draw_completed? }\r\n    end","code-length":57,"reference":"The `base_draw` method is called by the Game Window.","result":"Draw the base draw.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef transition_to(scene_or_scene_name,options = {})\r\n      new_scene = Scenes.generate(scene_or_scene_name,options)\r\n      _prepare_transition(new_scene)\r\n      window.scene = new_scene\r\n    end","code-length":75,"reference":"`transition_to` performs the work of transitioning this scene to another scene.","result":"Create a transition.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef _prepare_transition(new_scene)\r\n      log.debug \"Preparing to transition from scene #{self} to #{new_scene}\"\r\n      new_scene.class.actors.find_all {|actor_factory| actor_factory.load_from_previous_scene? }.each do |actor_factory|\r\n        new_actor = new_scene.actor(actor_factory.name)\r\n        current_actor = actor(actor_factory.name)\r\n        new_actor._load current_actor._save\r\n      end\r\n      prepare_transition_to(new_scene)\r\n      new_scene.prepare_transition_from(self)\r\n    end","code-length":166,"reference":"Before a scene is transitioned away from to a new scene, this private method is here to allow for any housekeeping or other work that needs to be done before calling the subclasses implementation of `prepare_transition`.","result":"Create a new transition.","score":[0.0002,0.0572]}
{"code":"# is used to<extra_id_0>\r\ndef to_hash\r\n      drawn = drawers.find_all{|draw| draw.saveable_to_view }.inject({}) do |hash,drawer|\r\n        drawer_hash = drawer.to_hash\r\n        hash.merge drawer_hash\r\n      end\r\n      drawn\r\n    end","code-length":81,"reference":"A Scene represented as a hash currently only contains the drawers ","result":"Generate the hash.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef create(model_name,options={})\r\n      model_class = Metro::Models.find(model_name)\r\n      mc = model_class.new options\r\n      mc.scene = scene\r\n      mc.window = window\r\n      mc\r\n    end","code-length":72,"reference":"A helper method that allows the current model to generate another model.","result":"Create a new model.","score":[0.0432,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef _load(options = {})\r\n      options.keys.each do |key|\r\n        property_name = key.to_s.underscore.to_sym\r\n        if respond_to? \"#{property_name}=\"\r\n          send(\"#{property_name}=\",options.delete(key))\r\n        else\r\n          options[property_name] = options.delete(key)\r\n        end\r\n      end\r\n      properties.merge! options\r\n    end","code-length":120,"reference":"Create an instance of a model.","result":"Load the properties.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef activities(user_id, options = {})\r\n      perform_request(:get, '\/v2\/measure', WithingsSDK::Activity, 'activities', {\r\n        action: 'getactivity',\r\n        userid: user_id\r\n      }.merge(options))\r\n    end","code-length":75,"reference":"Get a list of activity measures for the specified user ","result":"Get the activity information.","score":[0.0938,0.1596]}
{"code":"# is used to<extra_id_0>\r\ndef body_measurements(user_id, options = {})\r\n      perform_request(:get, '\/measure', WithingsSDK::MeasurementGroup, 'measuregrps', {\r\n        action: 'getmeas',\r\n        userid: user_id\r\n      }.merge(options))\r\n    end","code-length":77,"reference":"Get a list of body measurements taken by Withings devices ","result":"Parse the body measurements.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef weight(user_id, options = {})\r\n      groups = body_measurements(user_id, options)\r\n      groups.map do |group|\r\n        group.measures.select { |m| m.is_a? WithingsSDK::Measure::Weight }.map do |m|\r\n          WithingsSDK::Measure::Weight.new(m.attrs.merge('weighed_at' => group.date))\r\n        end\r\n      end.flatten\r\n    end","code-length":122,"reference":"Return a list of weight body measurements ","result":"Calculate the weight of a body.","score":[0.2151,0.2174]}
{"code":"# is used to<extra_id_0>\r\ndef sleep_series(user_id, options = {})\r\n      perform_request(:get, '\/v2\/sleep', WithingsSDK::SleepSeries, 'series', {\r\n        action: 'get',\r\n        userid: user_id\r\n      }.merge(options))\r\n    end","code-length":77,"reference":"Get details about a user's sleep ","result":"Get the series for the specified user.","score":[0.1615,0.082]}
{"code":"# is used to<extra_id_0>\r\ndef perform_request(http_method, path, klass, key, options = {})\r\n      if @consumer_key.nil? || @consumer_secret.nil?\r\n        raise WithingsSDK::Error::ClientConfigurationError, \"Missing consumer_key or consumer_secret\"\r\n      end\r\n      options = WithingsSDK::Utils.normalize_date_params(options)\r\n      request = WithingsSDK::HTTP::Request.new(@access_token, { 'User-Agent' => user_agent })\r\n      response = request.send(http_method, path, options)\r\n      if key.nil?\r\n        klass.new(response)\r\n      elsif response.has_key? key\r\n        response[key].collect do |element|\r\n          klass.new(element)\r\n        end\r\n      else\r\n        [klass.new(response)]\r\n      end\r\n    end","code-length":217,"reference":"Helper function that handles all API requests ","result":"Create a new instance of the class.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef set_magic_content_type(override=false)\r\n      if override || file.content_type.blank? || generic_content_type?(file.content_type)\r\n        new_content_type = ::FileMagic.new(::FileMagic::MAGIC_MIME).file( file.path ).split(';').first\r\n        if file.respond_to?(:content_type=)\r\n          file.content_type = new_content_type\r\n        else\r\n          file.instance_variable_set(:@content_type, new_content_type)\r\n        end\r\n      end\r\n    rescue ::Exception => e\r\n      raise CarrierWave::ProcessingError, I18n.translate(:\"errors.messages.magic_mime_types_processing_error\", e: e, default: 'Failed to process file with FileMagic, Original Error: %{e}')\r\n    end","code-length":217,"reference":"Changes the file content_type using the ruby-filemagic gem","result":"Set the content type of the file.","score":[0.1665,0.1266]}
{"code":"# is used to<extra_id_0>\r\ndef send_request(channel_id, method, properties={})\r\n      Util.error_check :\"sending a request\",\r\n        @conn.send_method(Integer(channel_id), method.to_sym, properties)\r\n            nil\r\n    end","code-length":69,"reference":"Send a request on the given channel with the given type and properties.","result":"Send a request.","score":[0.0206,0.1563]}
{"code":"# is used to<extra_id_0>\r\ndef fetch_response(channel_id, method, timeout: protocol_timeout)\r\n      methods = Array(method).map(&:to_sym)\r\n      timeout = Float(timeout) if timeout\r\n      fetch_response_internal(Integer(channel_id), methods, timeout)\r\n    end","code-length":77,"reference":"Wait for a specific response on the given channel of the given type and return the event data for the response when it is received.","result":"Fetch a response.","score":[0.0003,0.0219]}
{"code":"# is used to<extra_id_0>\r\ndef on_event(channel_id, method, callable=nil, &block)\r\n      handler = block || callable\r\n      raise ArgumentError, \"expected block or callable as the event handler\" \\\r\n        unless handler.respond_to?(:call)\r\n            @event_handlers[Integer(channel_id)][method.to_sym] = handler\r\n      handler\r\n    end","code-length":96,"reference":"Register a handler for events on the given channel of the given type.","result":"Register the event handler.","score":[0.04,0.124]}
{"code":"# is used to<extra_id_0>\r\ndef download_source\r\n      Log.debug { \"         Reading #{@source.url.green}\" }\r\n      zip = Tempfile.new('gtfs')\r\n      zip.binmode\r\n      zip << open(@source.url).read\r\n      zip.rewind\r\n      extract_to_tempfiles(zip)\r\n      Log.debug { \"Finished reading #{@source.url.green}\" }\r\n    rescue StandardException => e\r\n      Log.error(e.message)\r\n      raise e\r\n    ensure\r\n      zip.try(:close)\r\n    end","code-length":141,"reference":"Download the data from the remote server","result":"Download the source.","score":[0.1522,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef check_files\r\n      @found_files = []\r\n      check_required_files\r\n      check_optional_files\r\n      @source.feed_definition.files.each do |req|\r\n        @found_files << req if filenames.include?(req.filename)\r\n      end\r\n    end","code-length":82,"reference":"Parse the filenames in the feed and check which required and optional files are present.","result":"Check the files.","score":[0.0075,0.0725]}
{"code":"# is used to<extra_id_0>\r\ndef check_columns\r\n      @found_files.each do |file|\r\n        @temp_files[file.filename].open do |data|\r\n          FileReader.new(data, file, validate: true)\r\n        end\r\n      end\r\n    end","code-length":70,"reference":"Check that every file has its required columns","result":"Check the columns of the table.","score":[0.1645,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef fetch_http_fallback_identifier(head_request)\r\n      if head_request.key?('last-modified')\r\n        head_request['last-modified']\r\n      elsif head_request.key?('content-length')\r\n        head_request['content-length']\r\n      else\r\n        Time.now.to_s\r\n      end\r\n    end","code-length":96,"reference":"Find a \"next best\" ID when the HEAD request does not return an \"ETag\" header.","result":"Fetch the fallback identifier.","score":[0.0204,0.036]}
{"code":"# is used to<extra_id_0>\r\ndef parameter(*names)\r\n      names.each do |name|\r\n        define_singleton_method(name) do |*values|\r\n          if (value = values.first)\r\n            instance_variable_set(\"@#{name}\", value)\r\n          else\r\n            instance_variable_get(\"@#{name}\")\r\n          end\r\n        end\r\n      end\r\n    end","code-length":101,"reference":"Creates simple configuration parameters which may be set by the user","result":"Define parameters.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef find_columns(validate)\r\n      @found_columns = []\r\n      prefix = \"#{filename.yellow}:\"\r\n      required = @definition.required_columns\r\n      unless required.empty?\r\n        Log.info { \"#{prefix} #{'required columns'.magenta}\" } if validate\r\n        missing = check_columns(validate, prefix, required, :green, :red)\r\n        raise RequiredColumnsMissing, missing if validate && missing.present?\r\n      end\r\n      optional = @definition.optional_columns\r\n      unless optional.empty?\r\n        Log.info { \"#{prefix} #{'optional columns'.cyan}\" } if validate\r\n        check_columns(validate, prefix, optional, :cyan, :light_yellow)\r\n      end\r\n      cols = @definition.columns.collect(&:name)\r\n      headers = @csv_headers.select { |h| cols.include?(h) }\r\n      @col_names ||= @found_columns.map(&:name)\r\n      ::Hash[*headers.inject([]) { |list, c| list << c << @definition[c] }]\r\n    end","code-length":272,"reference":"Check the list of headers in the file against the expected columns in the definition","result":"Find the columns in the CSV file.","score":[0.114,0.2641]}
{"code":"# is used to<extra_id_0>\r\ndef map(models, options)\r\n      models = models.values\r\n      case options[:platform].downcase\r\n      when \"objc\", \"obj-c\", \"objective-c\"\r\n        Nidyx::ObjCMapper.map(models, options)\r\n      end\r\n    end","code-length":77,"reference":"Proxies model mapping to the proper platform mapper ","result":"Map the models.","score":[0.0771,0.1333]}
{"code":"# is used to<extra_id_0>\r\ndef generate(path, name)\r\n      object = get_object(path)\r\n      type = object[TYPE_KEY]\r\n      if type == OBJECT_TYPE\r\n        generate_object(path, name)\r\n      elsif type == ARRAY_TYPE\r\n        generate_top_level_array(path)\r\n      elsif type.is_a?(Array)\r\n        if type.include?(OBJECT_TYPE)\r\n          raise UnsupportedSchemaError if type.include?(ARRAY_TYPE)\r\n          generate_object(path, name)\r\n        elsif type.include?(ARRAY_TYPE)\r\n          generate_top_leve_array(path)\r\n        else raise UnsupportedSchemaError; end\r\n      else raise UnsupportedSchemaError; end\r\n    end","code-length":185,"reference":"Generates a Model and adds it to the models array.","result":"Generate a new object.","score":[0.0713,0.1995]}
{"code":"# is used to<extra_id_0>\r\ndef resolve_array_refs(obj)\r\n      items = obj[ITEMS_KEY]\r\n      case items\r\n      when Array\r\n        return resolve_items_array(items)\r\n      when Hash\r\n        any_of = items[ANY_OF_KEY]\r\n        return resolve_items_array(any_of) if any_of.is_a?(Array)\r\n        resolve_reference_string(items[REF_KEY])\r\n        return [class_name_from_ref(items[REF_KEY])].compact\r\n      else\r\n        return []\r\n      end\r\n    end","code-length":150,"reference":"Resolves any references buied in the `items` property of an array definition.","result":"Resolve array refs.","score":[0.0203,0.0901]}
{"code":"# is used to<extra_id_0>\r\ndef run(schema_path, options)\r\n      schema = Nidyx::Reader.read(schema_path)\r\n      raw_models = Nidyx::Parser.parse(schema, options)\r\n      models = Nidyx::Mapper.map(raw_models, options)\r\n      Nidyx::Output.write(models, options[:output_directory])\r\n    end","code-length":96,"reference":"The Nidyx model generator.","result":"Run the schema.","score":[0,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef read(path)\r\n      schema = nil\r\n      begin\r\n        schema = JSON.parse(IO.read(path))\r\n        raise EmptySchemaError if empty_schema?(schema)\r\n      rescue JSON::JSONError => e\r\n        puts \"Encountered an error reading JSON from #{path}\"\r\n        puts e.message\r\n        exit 1\r\n      rescue EmptySchemaError\r\n        puts \"Schema read from #{path} is empty\"\r\n        exit 1\r\n      rescue StandardError => e\r\n        puts e.message\r\n        exit 1\r\n      end\r\n      schema\r\n    end","code-length":148,"reference":"Reads JSON from a file ","result":"Read a JSON schema.","score":[0.2959,0.3061]}
{"code":"# is used to<extra_id_0>\r\ndef sign_package params\r\n      params_str = create_sign_str params\r\n      if params_str =~ \/trade_type=APP\/\r\n        key = Wxpay.app_api_key\r\n      else\r\n        key = Wxpay.api_key\r\n      end\r\n      Digest::MD5.hexdigest(params_str+\"&key=#{key}\").upcase\r\n    end","code-length":103,"reference":"used in wechat pay api","result":"Sign packages.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef _each_resource_file(config)\r\n      folder = config.folder\r\n      folder.glob(\"**\/*.yml\").select(&to_filter_proc(config.file_filter)).each do |file|\r\n        yield file, folder\r\n      end\r\n    end","code-length":74,"reference":"Recursive implementation of `each_resource_file` for each folder in the configuration.","result":"Generate the resource file.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef each_resource(&bl)\r\n      return enum_for(:each_resource) unless block_given?\r\n      each_resource_file do |file, folder|\r\n        yield Webspicy.resource(file.load, file, self)\r\n      end\r\n    end","code-length":75,"reference":"Yields each resource in the current scope in turn.","result":"Iterate over all resources.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef to_real_url(url, test_case = nil, &bl)\r\n      case config.host\r\n      when Proc\r\n        config.host.call(url, test_case)\r\n      when String\r\n        url =~ \/^http\/ ? url : \"#{config.host}#{url}\"\r\n      else\r\n        return url if url =~ \/^http\/\r\n        return yield(url) if block_given?\r\n        raise \"Unable to resolve `#{url}` : no host resolver provided\\nSee `Configuration\r\n      end\r\n    end","code-length":137,"reference":"Convert an instantiated URL found in a webservice definition to a real URL, using the configuration host.","result":"Resolve URLs.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef to_filter_proc(filter)\r\n        case ff = filter\r\n        when NilClass then ->(f){ true }\r\n        when Proc     then ff\r\n        when Regexp   then ->(f){ ff =~ f.to_s }\r\n        else\r\n          ->(f){ ff === f }\r\n        end\r\n      end","code-length":88,"reference":"Returns a proc that implements file_filter strategy according to the type of filter installed","result":"Create a filter.","score":[0.0104,0.0388]}
{"code":"# is used to<extra_id_0>\r\ndef folder(folder = nil, &bl)\r\n      if folder.nil?\r\n        @folder\r\n      else\r\n        folder = folder.is_a?(String) ? @folder\/folder : Path(folder)\r\n        raise \"Folder `#{folder}` does not exists\" unless folder.exists? && folder.directory?\r\n        raise \"Folder must be a descendant\" unless folder.inside?(@folder)\r\n        child = dup do |c|\r\n          c.parent = self\r\n          c.folder = folder\r\n        end\r\n        yield(child) if block_given?\r\n        @children << child\r\n        child\r\n      end\r\n    end","code-length":164,"reference":"Adds a folder to the list of folders where test case definitions are to be found.","result":"Create a folder.","score":[0.0054,0.034]}
{"code":"# is used to<extra_id_0>\r\ndef data_system\r\n      schema = self.folder\/\"schema.fio\"\r\n      if schema.file?\r\n        Finitio::DEFAULT_SYSTEM.parse(schema.read)\r\n      elsif not(self.parent.nil?)\r\n        self.parent.data_system\r\n      else\r\n        Finitio::DEFAULT_SYSTEM\r\n      end\r\n    end","code-length":96,"reference":"Returns the Data system to use for parsing schemas","result":"Create the data system.","score":[0.0915,0.2206]}
{"code":"# is used to<extra_id_0>\r\ndef run(direction)\r\n      self.status.direction = direction\r\n      self.status.reset! if self.class.rerunnable_safe? && completed?(direction) \r\n      self.status.execution_time = time_it { self.send(direction) }\r\n      self.status.last_succesful_completion = Time.now\r\n    end","code-length":94,"reference":"Makes sure status get instanciated on migration's instanciation","result":"Run the given direction.","score":[0,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef failure=(exception)\r\n      self.status.error = MigrationError.new(\r\n        :error_message => exception.message, \r\n        :error_class => exception.class, \r\n        :error_backtrace => exception.backtrace)\r\n    end","code-length":68,"reference":"Sets an error to migration status","result":"Set the failure status.","score":[0,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef is_runnable?(direction)\r\n      self.class.rerunnable_safe? || \r\n      (direction == UP && status.current_status < status_complete) || \r\n      (direction == DOWN && status.current_status > 0)\r\n    end","code-length":70,"reference":"Checks if a migration can be run","result":"Check if the method is runnable.","score":[0.1634,0.3704]}
{"code":"# is used to<extra_id_0>\r\ndef completed?(direction) \r\n      return false if self.status.execution_time == 0\r\n      (direction == UP && self.status.current_status == self.status_complete) || \r\n      (direction == DOWN && self.status.current_status == 0)\r\n    end","code-length":75,"reference":"Checks if a migration as been completed","result":"Check if the status is completed.","score":[0.1634,0.2717]}
{"code":"# is used to<extra_id_0>\r\ndef step(step_message = nil, step_status = 1)\r\n      unless status.status_processed?(status.direction, step_status)\r\n        self.status.message = step_message\r\n        puts \"\\t #{step_message}\" \r\n        yield if block_given?\r\n        self.status.current_status += status.direction_to_i\r\n      end\r\n    end","code-length":101,"reference":"Executes a given block if the status has not being processed","result":"Execute a step.","score":[0.0284,0.1838]}
{"code":"# is used to<extra_id_0>\r\ndef time_it\r\n      puts \"Running #{self.class}[#{self.status.arguments}](#{self.status.direction})\"\r\n      start = Time.now\r\n      yield if block_given?\r\n      end_time = Time.now - start\r\n            puts \"Tasks #{self.class} executed in #{end_time} seconds. \\n\\n\"\r\n      end_time\r\n    end","code-length":103,"reference":"Executes a block and returns the time it took to be executed","result":"Run tasks.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef super_print(paragraphes, space_number = 50, title = true)\r\n      puts format_paragraph(space_number, title, *paragraphes)\r\n    end","code-length":49,"reference":"Prints a paragraphes","result":"Print the text.","score":[0,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef columns_hash\r\n      colModel.inject({}) { |h, col| h[col.name] = col; h }\r\n    end","code-length":43,"reference":"normally we need to keep columns an ordered array, sometimes its convenient to have a hash","result":"Store the columns in the hash.","score":[0.0365,0.0333]}
{"code":"# is used to<extra_id_0>\r\ndef render\r\n      @page_list.each do |page|\r\n        page.render_to_file(@config.dest_dir)\r\n        putc '.'; $stdout.flush\r\n      end\r\n      @dir_list.each do |directory|\r\n        src = File.join(@config.pages_dir, directory)\r\n        dst = File.join(@config.dest_dir, directory)\r\n        Render::Asset.render_dir(src, dst)\r\n        putc '.'; $stdout.flush\r\n      end\r\n      if @config.short_paths\r\n        render_short_path_symlinks\r\n      end\r\n      Render::Apache.write_htaccess(@config, @config.pages_dir, @config.dest_dir)\r\n      puts\r\n    end","code-length":195,"reference":"def reload_pages_if_needed  if ","result":"Render assets.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add_page(page)\r\n      @pages_by_name[page.name] ||= page\r\n      @pages_by_path[page.path.join('\/')] = page\r\n      add_aliases(I18n.default_locale, page, @pages_by_path)\r\n      page.locales.each do |locale|\r\n        next if locale == I18n.default_locale\r\n        add_aliases(locale, page, @pages_by_locale_path[locale])\r\n      end\r\n      @page_list << page\r\n    end","code-length":141,"reference":"registers a page with the site, indexing the page path in our various hashes","result":"Add a page to the page list.","score":[0.1106,0.282]}
{"code":"# is used to<extra_id_0>\r\ndef add_aliases(locale, page, path_hash)\r\n      page.aliases(locale).each do |alias_path|\r\n        alias_path_str = alias_path.join('\/')\r\n        if path_hash[alias_path_str]\r\n          Amber.logger.warn \"WARNING: page `#{page.path.join('\/')}` has alias `#{alias_path_str}`, but this path is already taken by `#{path_hash[alias_path_str].path.join('\/')}` (locale = #{locale}).\"\r\n        else\r\n          path_hash[alias_path_str] = page\r\n        end\r\n      end\r\n    end","code-length":168,"reference":"registers a page's aliases with the site","result":"Add page aliases to the path hash.","score":[0.1921,0.1429]}
{"code":"# is used to<extra_id_0>\r\ndef parse_headers(content_file)\r\n      headers = []\r\n      para1 = []\r\n      para2 = []\r\n      file_type = type_from_path(content_file)\r\n      File.open(content_file, :encoding => 'UTF-8') do |f|\r\n        while (line = f.gets) =~ \/^(- |)@\\w\/\r\n          if line !~ \/^-\/\r\n            line = '- ' + line\r\n          end\r\n          headers << line\r\n        end\r\n        while line = f.gets\r\n          break unless line =~ \/^\\s*$\/\r\n        end\r\n        para1 << line\r\n        while line = f.gets\r\n          break if line =~ \/^\\s*$\/\r\n          para1 << line\r\n        end\r\n        while line = f.gets\r\n          break if line =~ \/^\\s*$\/\r\n          para2 << line\r\n        end\r\n      end\r\n      headers = headers.join\r\n      para1 = para1.join\r\n      para2 = para2.join\r\n      excerpt = \"\"\r\n      if file_type == :textile\r\n        if para1 =~ \/^h[1-5]\\. \/\r\n          excerpt = para2\r\n        else\r\n          excerpt = para1\r\n        end\r\n      elsif file_type == :markdown\r\n        if para1 =~ \/^\r\n          excerpt = para2\r\n        else\r\n          excerpt = para1\r\n        end\r\n      end\r\n      return [headers, excerpt]\r\n    end","code-length":375,"reference":"parses a content_file's property headers and tries to extract the first paragraph.","result":"Parse the headers of a file.","score":[0.0935,0.1754]}
{"code":"# is used to<extra_id_0>\r\ndef variable_files\r\n      if @simple_page\r\n        directory = File.dirname(@file_path)\r\n        regexp = SIMPLE_VAR_MATCH_RE.call(@name)\r\n      else\r\n        directory = @file_path\r\n        regexp = VAR_FILE_MATCH_RE\r\n      end\r\n      hsh = {}\r\n      Dir.foreach(directory) do |file|\r\n        if file && match = regexp.match(file)\r\n          locale = match['locale'] || I18n.default_locale\r\n          hsh[locale.to_sym] = File.join(directory, file)\r\n        end\r\n      end\r\n      hsh\r\n    end","code-length":169,"reference":"VARIABLES","result":"Define the variable files.","score":[0,0.3846]}
{"code":"# is used to<extra_id_0>\r\ndef last_menu_at_depth(depth)\r\n      menu = self\r\n      depth.times { menu = menu.children.last }\r\n      menu\r\n    end","code-length":49,"reference":"returns the last list of children at the specified depth","result":"Store the menu.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef nameize(str)\r\n      str = str.dup\r\n      str.gsub!(\/&(\\w{2,6}?|word:]]]\/u, '')\r\n      str.strip!\r\n      str.downcase!\r\n      str.gsub!(\/\\ +\/u, '-')\r\n      CGI.escape(str)\r\n    end","code-length":93,"reference":"convert any string to one suitable for a url.","result":"Name the document.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef strip_html_tags(html)\r\n      Nokogiri::HTML::DocumentFragment.parse(html, 'UTF-8').children.collect{|child| child.inner_text}.join\r\n    end","code-length":58,"reference":"removes all html markup","result":"Strip HTML tags.","score":[0,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef populate_node(node, options)\r\n      @children.each do |item|\r\n        li = node.document.create_element(\"li\")\r\n        li.add_child(li.document.create_element(\"a\", item.text, :href => \"#{options[:href_base]}\r\n        if item.children.any?\r\n          ul = li.document.create_element(options[:tag])\r\n          item.populate_node(ul, options)\r\n          li.add_child(ul)\r\n        end\r\n        node.add_child(li)\r\n      end\r\n    end","code-length":151,"reference":"generates nokogiri html node tree from this toc","result":"Populate the node.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef to_html(options={})\r\n      html   = []\r\n      tag    = options[:tag]\r\n      indent = options[:indent] || 0\r\n      str    = options[:indent_str] || \"  \"\r\n      html << '%s<%s>' % [(str*indent), tag]\r\n      @children.each do |item|\r\n        html << '%s<li>' % (str*(indent+1))\r\n        html << '%s<a href=\"%s\r\n        if item.children.any?\r\n          html << item.to_html({\r\n            :indent => indent+2,\r\n            :indent_str => str,\r\n            :tag => tag,\r\n            :href_base => options[:href_base]\r\n          })\r\n        end\r\n        html << '%s<\/li>' % (str*(indent+1))\r\n      end\r\n      html << '%s<\/%s>' % [(str*indent), tag]\r\n      html.join(\"\\n\")\r\n    end","code-length":249,"reference":"generates html string from this toc","result":"Generate the HTML for the list.","score":[0,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef parent_for(heading)\r\n      heading = heading[1].to_i if heading.is_a?(String)\r\n      if children.any? && children.last.level < heading\r\n        children.last.parent_for(heading)\r\n      else\r\n        self\r\n      end\r\n    end","code-length":83,"reference":"Returns the appropriate TocItem for appending a new item at a particular heading level.","result":"Create the parent.","score":[0.0104,0.0388]}
{"code":"# is used to<extra_id_0>\r\ndef type_id(which)\r\n      which = which.to_s.humanize unless which.kind_of?(String)\r\n      which.downcase!\r\n      case which\r\n        when 'alliance' then 16159\r\n        when 'character' then 1377\r\n        when 'corporation' then 2\r\n        when 'constellation' then 4\r\n        when 'region' then 3\r\n        when 'solar system', 'solarsystem' then 5\r\n        when 'station' then 3867\r\n        else raise ArgumentError, \"Unknown type: #{which}\"\r\n      end\r\n    end","code-length":152,"reference":"Returns the numeric type ID for a string, so you don't have to manage \"magic numbers\" in your application.","result":"Identify the type.","score":[0.002,0.0287]}
{"code":"# is used to<extra_id_0>\r\ndef link_to_info(text, type_id, item_id = nil, *args)\r\n      function = \"CCPEVE.showInfo(#{type_id.inspect}\"\r\n      function.concat \", #{item_id.inspect}\" if item_id\r\n      function.concat \")\"\r\n      link_to_function text, function, *args\r\n    end","code-length":94,"reference":"Creates a hyperlink that results in the \"show info\" dialog being displayed on the client's screen.","result":"Create a link to the info page.","score":[0.0531,0.1692]}
{"code":"# is used to<extra_id_0>\r\ndef link_to_route(text, destination_id, source_id = nil, *args)\r\n      function = \"CCPEVE.showRouteTo(#{destination_id.inspect}\"\r\n      function.concat \", #{source_id.inspect}\" if source_id\r\n      function.concat \")\"\r\n      link_to_function text, function, *args\r\n    end","code-length":95,"reference":"Creates a hyperlink that results in showing the route to the destination_id from the source_id.","result":"Create a new link to the route.","score":[0.0806,0.2223]}
{"code":"# is used to<extra_id_0>\r\ndef link_to_trust_request(text, trust_url = \"http:\/\/#{request.host}\/\", *args)\r\n      trust_url = url_for(trust_url.merge(:only_path => false)) if trust_url.kind_of?(Hash)\r\n      link_to_function text, \"CCPEVE.requestTrust(#{trust_url.inspect})\", *args\r\n    end","code-length":103,"reference":"Produces a hyperlink that will result in a pop-up a trust prompt in the client, allowing the user to either grant the trust request, ignore it, or always ignore trust requests from your site.","result":"Prevent the link to the trust request.","score":[0.0057,0.0639]}
{"code":"# is used to<extra_id_0>\r\ndef request_trust(trust_url = \"http:\/\/#{request.host}\/\", *args)\r\n      trust_url = url_for(trust_url.merge(:only_path => false)) if trust_url.kind_of?(Hash)\r\n      javascript_tag \"CCPEVE.requestTrust(#{trust_url.inspect});\", *args\r\n    end","code-length":93,"reference":"This will generate a method call that produces a pop-up a trust prompt in the client, allowing the user to either grant the trust request, ignore it, or always ignore trust requests from your site.","result":"Prevent the page from being rendered.","score":[0.0018,0.0312]}
{"code":"# is used to<extra_id_0>\r\ndef render_to_file(dest_dir, options={})\r\n      render_content_files(dest_dir, options)\r\n      render_assets(dest_dir)\r\n      @props.locales.each do |locale|\r\n        if aliases(locale).any?\r\n          link_page_aliases(dest_dir, aliases(locale), locale)\r\n        end\r\n      end\r\n    end","code-length":103,"reference":"render without layout, possibly with via a rails request","result":"Render content files.","score":[0,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef symlink(from_path, to_path)\r\n      to_path = realpath(to_path)\r\n      target = from_path.relative_path_from(to_path).to_s.sub(\/^\\.\\.\\\/\/, '')\r\n      if !to_path.dirname.directory?\r\n        Amber.logger.warn { \"On page `#{@file_path}`, the parent directories for alias name `#{to_path}` don't exist. Skipping alias.\" }\r\n        return\r\n      end\r\n      if to_path.exist? && to_path.symlink?\r\n        File.unlink(to_path)\r\n      end\r\n      if !to_path.exist?\r\n        Amber.logger.debug { \"Symlink #{to_path} => #{target}\" }\r\n        FileUtils.ln_s(target, to_path)\r\n      end\r\n    end","code-length":214,"reference":"create a symlink. arguments must be of type Pathname.","result":"Create a symlink.","score":[0.0781,0.3505]}
{"code":"# is used to<extra_id_0>\r\ndef render_content_files(dest_dir, options)\r\n      view = Render::View.new(self, @config)\r\n      @config.locales.each do |file_locale|\r\n        content_file = content_file(file_locale)\r\n        next unless content_file\r\n        dest = destination_file(dest_dir, file_locale)\r\n        unless Dir.exist?(File.dirname(dest))\r\n          FileUtils.mkdir_p(File.dirname(dest))\r\n        end\r\n        if options[:force] || !File.exist?(dest) || File.mtime(content_file) > File.mtime(dest)\r\n          File.open(dest, 'w') do |f|\r\n            layout = @props.layout || 'default'\r\n            f.write view.render({page: self, layout: layout}, {locale: file_locale})\r\n          end\r\n        end\r\n      end\r\n    end","code-length":230,"reference":"called only by render_to_file","result":"Render content files.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef friend name, friend_id, note = nil\r\n      friend_wrapper(api_name = name, api_container = @userid, api_note = note, api_type = \"friend\")\r\n    end","code-length":58,"reference":"Friend a user ","result":"Create a friend.","score":[0.4082,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef get_user_listing username, opts = {}\r\n      opts[:type] = 'overview' if opts[:type].nil?\r\n      url = \"\/user\/%s%s.json\" % [username, ('\/' + opts[:type] if opts[:type] != 'overview')]\r\n      opts.delete :type\r\n      query = opts\r\n      get(url, query: query)\r\n    end","code-length":102,"reference":"Get a listing of user posts.","result":"Get user listing.","score":[0.1786,0.1754]}
{"code":"# is used to<extra_id_0>\r\ndef comment text, id\r\n      logged_in?\r\n      post('\/api\/comment', body: { text: text, thing_id: id, uh: @modhash, api_type: 'json'})\r\n    end","code-length":63,"reference":"Posts a comment to the site ","result":"Comment a thing.","score":[0.1502,0.1754]}
{"code":"# is used to<extra_id_0>\r\ndef submit title, subreddit, opts = {}\r\n      logged_in?\r\n      post = {\r\n        title: title,\r\n        sr: subreddit,\r\n        uh: @modhash,\r\n        kind: (opts[:url] ? \"link\" : \"self\"),\r\n        api_type: 'json'\r\n      }\r\n      post.merge! opts\r\n      post('\/api\/submit', body: post)\r\n    end","code-length":116,"reference":"Submit a link or self post ","result":"Submit a new submission.","score":[0.274,0.3233]}
{"code":"# is used to<extra_id_0>\r\ndef vote direction, id\r\n      logged_in?\r\n      post('\/api\/vote', body: {id: id, dir: direction, uh: @modhash, api_type: 'json'})\r\n    end","code-length":61,"reference":"Vote on a comment or link ","result":"Vote.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef correct?(str)\r\n      str = str.is_a?(String) ? str : str.to_s\r\n      str == (@answer.is_a?(String) ? @answer : @answer.to_s)\r\n    end","code-length":68,"reference":"Determine whether or not an answer is correct","result":"Check the correctness of a string.","score":[0,0.0641]}
{"code":"# is used to<extra_id_0>\r\ndef gotcha(options = {})\r\n      options[:label_options] ||= {}\r\n      options[:text_field_options] ||= {}\r\n      if gotcha = Gotcha.random\r\n        field = \"gotcha_response[#{gotcha.class.name.to_s}-#{Digest::MD5.hexdigest(gotcha.class.down_transform(gotcha.answer))}]\"\r\n        (label_tag field, gotcha.question, options[:label_options]) + \"\\n\" + (text_field_tag field, nil, options[:text_field_options])\r\n      else\r\n        raise \"No Gotchas Installed\"\r\n      end\r\n    end","code-length":166,"reference":"Propose a gotcha to the user - question and answer hash","result":"Generate a form.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef delete_image subreddit, image_name\r\n      logged_in?\r\n      post('\/api\/delete_sr_image', body: {r: subreddit, img_name: image_name, uh: @modhash, api_type: 'json'})\r\n    end","code-length":75,"reference":"Deletes an image from a subreddit.","result":"Delete a subreddit.","score":[0.2124,0.4483]}
{"code":"# is used to<extra_id_0>\r\ndef set_stylesheet stylesheet, subreddit\r\n      logged_in?\r\n      post('\/api\/subreddit_stylesheet', body: {op: 'save', r: subreddit, stylesheet_contents: stylesheet, uh: @modhash, api_type: 'json'})\r\n    end","code-length":75,"reference":"Set the subreddit stylesheet ","result":"Set the stylesheet.","score":[0.4137,0.4808]}
{"code":"# is used to<extra_id_0>\r\ndef subscribe subreddit, action = \"sub\"\r\n      logged_in?\r\n      post('\/api\/subscribe', body: {action: action, sr: subreddit, uh: @modhash, api_type: 'json'})\r\n    end","code-length":67,"reference":"Subscribe to a subreddit ","result":"Subscribe to a subreddit.","score":[0.658,0.7361]}
{"code":"# is used to<extra_id_0>\r\ndef my_reddits opts = {}\r\n      logged_in?\r\n      url = \"\/reddits\/mine\/%s.json\" % (opts[:condition] if opts[:condition])\r\n      opts.delete :condition\r\n      query = opts\r\n      get(url, query: query)\r\n    end","code-length":81,"reference":"Get subreddits I have","result":"Create a new instance.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get_reddits opts = {}\r\n      url = \"\/reddits\/%s.json\" % (opts[:condition] if opts[:condition])\r\n      opts.delete :condition\r\n      query = opts\r\n      get(url, query: query)\r\n    end","code-length":72,"reference":"Get a list of subreddits","result":"Get the reddits.","score":[0.2096,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef add_moderator container, user, subreddit\r\n      friend_wrapper container: container, name: user, r: subreddit, type: \"moderator\"\r\n    end","code-length":49,"reference":"Add a moderator to the subreddit ","result":"Escape the line.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef add_contributor container, user, subreddit\r\n      friend_wrapper container: container, name: user, r: subreddit, type: \"contributor\"\r\n    end","code-length":49,"reference":"Add a contributor to the subreddit","result":"Add a contributor to a container.","score":[0.6043,0.526]}
{"code":"# is used to<extra_id_0>\r\ndef ban_user container, user, subreddit\r\n      friend_wrapper container: container, name: user, r: subreddit, type: \"banned\"\r\n    end","code-length":48,"reference":"Ban a user from a subreddit","result":"Escape the string.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef remove_moderator container, user, subreddit\r\n      unfriend_wrapper container: container, name: user, r: subreddit, type: \"moderator\"\r\n    end","code-length":51,"reference":"Remove a moderator from a subreddit","result":"Remove the moderator.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef remove_contributor container, user, subreddit\r\n      unfriend_wrapper container: container, name: user, r: subreddit, type: \"contributor\"\r\n    end","code-length":51,"reference":"Remove a contributor from a subreddit","result":"Remove the user from the list.","score":[0.2296,0.1667]}
{"code":"# is used to<extra_id_0>\r\ndef unban_user container, user, subreddit\r\n      unfriend_wrapper container: container, name: user, r: subreddit, type: \"banned\"\r\n    end","code-length":51,"reference":"Unban a user from a subreddit","result":"Escape the html.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get *args, &block\r\n        response = self.class.get *args, &block\r\n        raise WebserverError, response.code unless response.code == 200\r\n        response\r\n      end","code-length":57,"reference":"HTTParty get wrapper. This serves to clean up code, as well as throw webserver errors wherever needed","result":"Make GET requests.","score":[0,0.0641]}
{"code":"# is used to<extra_id_0>\r\ndef log_in username, password\r\n      login = post(\"\/api\/login\", :body => {user: username, passwd: password, api_type: 'json'})\r\n      errors = login['json']['errors']\r\n      raise errors[0][1] unless errors.size == 0\r\n      set_cookies login.headers['set-cookie']\r\n      @modhash = login['json']['data']['modhash']\r\n      @username = username\r\n      @userid = 't2_' + get('\/api\/me.json')['data']['id']\r\n      return login\r\n    end","code-length":146,"reference":"Log into a reddit account.","result":"Log in with the user.","score":[0.2403,0.1]}
{"code":"# is used to<extra_id_0>\r\ndef auth modhash, cookies\r\n      set_cookies cookies\r\n      @modhash = modhash\r\n      meinfo = get(\"\/api\/me.json\")\r\n      @username = meinfo['data']['name']\r\n      @userid = 't2_' + meinfo['data']['id']\r\n    end","code-length":81,"reference":"Auth into reddit via modhash and cookie.","result":"Authenticate.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef delete_user password, reason = \"deleted by script command\"\r\n      logged_in?\r\n      delete = post('\/api\/delete_user', body: {\r\n        confirm: true,\r\n        delete_message: reason,\r\n        passwd: password,\r\n        uh: @modhash,\r\n        user: @username,\r\n        api_type: 'json'\r\n        })\r\n      return delete\r\n    end","code-length":112,"reference":"Deletes the current user.","result":"Delete user.","score":[0.1839,0.2632]}
{"code":"# is used to<extra_id_0>\r\ndef get_messages where = \"inbox\", opts = {}\r\n      query = {\r\n        mark: false\r\n      }\r\n      query.merge! opts\r\n      get(\"\/message\/#{where}.json\", query: query)\r\n    end","code-length":66,"reference":"Gets a listing of PMs ","result":"Get all messages.","score":[0,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef clear_flair_templates type, subreddit\r\n      logged_in?\r\n      post('\/api\/clearflairtemplates', body: { flair_type: type, r: subreddit, uh: @modhash, api_type: 'json'})\r\n    end","code-length":74,"reference":"Clear all the flair templates of a particular type ","result":"Clear flair templates.","score":[0.0657,0.119]}
{"code":"# is used to<extra_id_0>\r\ndef delete_user_flair user, subreddit\r\n      logged_in?\r\n      post('\/api\/deleteflair', body: {name: user, r: subreddit, uh: @modhash, api_type: 'json'})\r\n    end","code-length":70,"reference":"Deletes a user's flair ","result":"Delete user flairs.","score":[0,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef delete_flair_template id, subreddit\r\n      logged_in?\r\n      post('\/api\/deleteflairtemplate', body: {flair_template_id: id, r: subreddit, uh: @modhash, api_type: 'json'})\r\n    end","code-length":76,"reference":"Deletes a flair template by ID.","result":"Delete a flair template.","score":[0.274,0.5077]}
{"code":"# is used to<extra_id_0>\r\ndef flair_config subreddit, opts = {}\r\n      logged_in?\r\n      options = {\r\n        flair_enabled: true,\r\n        flair_position: 'right',\r\n        flair_self_assign_enabled: false,\r\n        link_flair_position: 'right',\r\n        link_flair_self_assign_enabled: false,\r\n        uh: @modhash,\r\n        r: subreddit,\r\n        api_type: 'json'\r\n      }\r\n      options.merge! opts\r\n      post('\/api\/flairconfig', body: options)\r\n    end","code-length":157,"reference":"Configures flair options for a subreddit.","result":"Set the position of the flair in the subreddit.","score":[0.1449,0.1587]}
{"code":"# is used to<extra_id_0>\r\ndef flair_csv csv, subreddit\r\n      logged_in?\r\n      post('\/api\/flaircsv.json', body: {flair_csv: csv, r: subreddit, uh: @modhash})\r\n    end","code-length":65,"reference":"Post flair in a CSV file to reddit ","result":"Store the flair csv.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef flair_template subreddit, opts = {}\r\n      logged_in?\r\n      params = {\r\n        flair_type: 'USER_FLAIR',\r\n        text_editable: false,\r\n        uh: @modhash,\r\n        r: subreddit,\r\n        api_type: 'json'\r\n      }\r\n      params.merge! opts\r\n      post('\/api\/flairtemplate', body: params)\r\n    end","code-length":117,"reference":"Create or edit a flair template.","result":"Create a template.","score":[0.1977,0.2632]}
{"code":"# is used to<extra_id_0>\r\ndef select_flair_template template_id, subreddit, opts = {}\r\n      logged_in?\r\n      params = {\r\n        flair_template_id: template_id,\r\n        uh: @modhash,\r\n        r: subreddit,\r\n        api_type: 'json'\r\n      }\r\n      params.merge! opts\r\n      post('\/api\/selectflair', body: params)\r\n    end","code-length":113,"reference":"Select a flair template and apply it to a user or link ","result":"Select a flair template.","score":[0.0891,0.1339]}
{"code":"# is used to<extra_id_0>\r\ndef flair_toggle enabled, subreddit\r\n      logged_in?\r\n      post('\/api\/setflairenabled', body: {flair_enabled: enabled, uh: @modhash, r: subreddit, api_type: 'json'})\r\n    end","code-length":74,"reference":"Toggle flair on and off for a subreddit ","result":"Set the flair_enabled flag.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get_comments opts = {}\r\n      query = { limit: 100 }\r\n      query.merge! opts\r\n      url = \"%s\/comments\/%s%s.json\" % [('\/r\/' + opts[:subreddit] if opts[:subreddit]), opts[:link_id], ('\/blah\/' + opts[:comment_id] if opts[:comment_id])]\r\n      get(url, query: query)\r\n    end","code-length":110,"reference":"Get a comment listing from the site","result":"Get comments from the subreddit.","score":[0.2521,0.4642]}
{"code":"# is used to<extra_id_0>\r\ndef get_listing opts = {}\r\n      url = \"%s\/%s.json\" % [('\/r\/' + opts[:subreddit] if opts[:subreddit] ), (opts[:page] if opts[:page])]\r\n      [:subreddit, :page].each {|k| opts.delete k}\r\n      query = opts\r\n      get(url, query: query)\r\n    end","code-length":101,"reference":"Gets a listing of links from reddit.","result":"Get listing.","score":[0,0.0769]}
{"code":"# is used to<extra_id_0>\r\ndef distinguish id, how = \"yes\"\r\n      logged_in?\r\n      hows = %w{yes no admin special}\r\n      post('\/api\/distinguish', body: {id: id, how: how, uh: @modhash, api_type: 'json'})\r\n    end","code-length":81,"reference":"Distinguish a thing","result":"Distinguish a user.","score":[0.5774,0.625]}
{"code":"# is used to<extra_id_0>\r\ndef remove id, spam = false\r\n      logged_in?\r\n      post('\/api\/remove', body: {id: id, spam: spam, uh: @modhash, api_type: 'json'})\r\n    end","code-length":63,"reference":"Removes a thing","result":"Remove a resource.","score":[0.4082,0.625]}
{"code":"# is used to<extra_id_0>\r\ndef get_modlog subreddit, opts = {}\r\n      logged_in?\r\n      options = {\r\n        limit: 100\r\n      }.merge opts\r\n      data = Nokogiri::HTML.parse(get(\"\/r\/#{subreddit}\/about\/log\", query: options).body).css('.modactionlisting tr')\r\n      processed = {\r\n        data:       [],\r\n        first:      data[0]['data-fullname'],\r\n        first_date: Time.parse(data[0].children[0].child['datetime']),\r\n        last:       data[-1]['data-fullname'],\r\n        last_date:  Time.parse(data[-1].children[0].child['datetime']),\r\n      }\r\n      data.each do |tr|\r\n        processed[:data] << {\r\n          fullname:     tr['data-fullname'],\r\n          time:         Time.parse(tr.children[0].child['datetime']),\r\n          author:       tr.children[1].child.content,\r\n          action:       tr.children[2].child['class'].split[1],\r\n          description:  tr.children[3].content,\r\n          href:         tr.children[3].css('a').count == 0 ? nil : tr.children[3].css('a')[0]['href']\r\n        }\r\n      end\r\n      return processed\r\n    end","code-length":337,"reference":"Gets a moderation log","result":"Escape html tags.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef post(query_params)\r\n      servers ||= SERVERS.map{|hostname| \"https:\/\/#{hostname}\/minfraud\/chargeback\"}\r\n      url = URI.parse(servers.shift)\r\n      req = Net::HTTP::Post.new(url.path, initheader = {'Content-Type' =>'application\/json'})\r\n      req.basic_auth Maxmind::user_id, Maxmind::license_key\r\n      req.body = query_params\r\n      h = Net::HTTP.new(url.host, url.port)\r\n      h.use_ssl = true\r\n      h.verify_mode = OpenSSL::SSL::VERIFY_NONE\r\n      h.open_timeout  = 60\r\n      h.read_timeout  = self.class.timeout || DefaultTimeout\r\n      h.ssl_timeout   = self.class.timeout || DefaultTimeout\r\n      h.start { |http| http.request(req) }\r\n    rescue Exception => e\r\n      retry if servers.size > 0\r\n      raise e\r\n    end","code-length":258,"reference":"Upon a failure at the first URL, will automatically retry with the","result":"Send a post request to the server.","score":[0.094,0.087]}
{"code":"# is used to<extra_id_0>\r\ndef lifespan=(lifespan)\r\n      @lifespan = lifespan\r\n      @@lifespans.each_with_index do |span, index|\r\n        if span[0] == lifespan && lifespan != \"Forever\"\r\n          self.expires = DateTime.now.advance(@@lifespans[index][1])\r\n        end\r\n      end\r\n    end","code-length":106,"reference":"Setter to convert user's choice of 'A Week', etc. to an actual DateTime","result":"Set the lifespan.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef div\r\n      cr_scanner = CodeRay.scan(self.clip, self.language)\r\n      if cr_scanner.loc <= 1\r\n        return cr_scanner.div\r\n      else\r\n        return cr_scanner.div(:line_numbers => :table)\r\n      end\r\n    end","code-length":81,"reference":"Creates the div for the clip","result":"Create a div.","score":[0,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef set_variables(instance_variables)\r\n      instance_variables.each { |name, value| instance_variable_set(\"@#{name}\", value) }\r\n      yield(self)\r\n      instance_variables.each { |name, _| remove_instance_variable(\"@#{name}\") }\r\n      self\r\n    end","code-length":87,"reference":"sets instance variables when block is yielded ","result":"Set instance variables.","score":[0.1076,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef render(object, method, *args, &block)\r\n      object.__send__ method, self, *args, &block\r\n      self\r\n    end","code-length":46,"reference":"renders +object+ with +method+ ","result":"Render the template.","score":[0,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef join(collection, glue = nil, &it)\r\n              when String\r\n                       lambda { text glue }\r\n                     when Proc\r\n                       glue\r\n                     else\r\n                       lambda {}\r\n                   end\r\n      collection.each_with_index do |obj, i|\r\n        glue_block.call() if i > 0\r\n        obj.is_a?(Proc) ? obj.call : it.call(obj)\r\n      end\r\n    end","code-length":116,"reference":"joins and renders +collection+ with +glue+ ","result":"Glue_block .","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef open_session(uri)\r\n      validate_presence_of uri, 'Channel URI'\r\n      response = @client.call(:open_publication_session, message: { 'ChannelURI' => uri })\r\n      response.to_hash[:open_publication_session_response][:session_id].to_s\r\n    end","code-length":86,"reference":"Creates a new ISBM ProviderPublication client.","result":"Open a session.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef post_publication(session_id, content, topics, expiry = nil)\r\n      validate_presence_of session_id, 'Session Id'\r\n      validate_presence_of content, 'Content'\r\n      validate_presence_of topics, 'Topics'\r\n      validate_xml content\r\n      topics = [topics].flatten\r\n      xml = Builder::XmlMarkup.new\r\n      xml.isbm :SessionID, session_id\r\n      xml.isbm :MessageContent do\r\n        xml << content\r\n      end\r\n      topics.each do |topic|\r\n        xml.isbm :Topic, topic\r\n      end\r\n      duration = expiry.to_s\r\n      xml.isbm :Expiry, duration unless duration.nil?\r\n      response = @client.call(:post_publication, message: xml.target!)\r\n      response.to_hash[:post_publication_response][:message_id].to_s\r\n    end","code-length":228,"reference":"Posts a publication message.","result":"Create a new publication.","score":[0.3195,0.125]}
{"code":"# is used to<extra_id_0>\r\ndef expire_publication(session_id, message_id)\r\n      validate_presence_of session_id, 'Session Id'\r\n      validate_presence_of message_id, 'Message Id'\r\n      @client.call(:expire_publication, message: { 'SessionID' => session_id, 'MessageID' => message_id })\r\n      return true\r\n    end","code-length":97,"reference":"Expires a posted publication message.","result":"Expire a publication.","score":[0.2096,0.3906]}
{"code":"# is used to<extra_id_0>\r\ndef validate_presence_of(value, name)\r\n      if value.respond_to?(:each)\r\n        value.each do |v|\r\n          if v.blank?\r\n            raise ArgumentError, \"Values in #{name} must not be blank\"\r\n          end\r\n        end\r\n      else\r\n        if value.blank?\r\n          raise ArgumentError, \"#{name} must not be blank\"\r\n        end\r\n      end\r\n    end","code-length":114,"reference":"Creates a new ISBM client.","result":"Validate presence of values.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef validate_xml(xml)\r\n      doc = Nokogiri.XML(xml)\r\n      raise ArgumentError, \"XML is not well formed: #{xml}\" unless doc.errors.empty?\r\n    end","code-length":57,"reference":"Validates the well formedness of the XML string and raises an error if any errors are encountered.","result":"Validate the XML.","score":[0.0038,0.0641]}
{"code":"# is used to<extra_id_0>\r\ndef default_savon_options(options)\r\n      options[:logger] = Rails.logger if options[:logger].nil? && defined?(Rails)\r\n      options[:log] = false if options[:log].nil?\r\n      options[:pretty_print_xml] = true if options[:pretty_print_xml].nil?\r\n    end","code-length":89,"reference":"Sets default values for certain Savon options.","result":"Create Savon.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef read_publication(session_id)\r\n      validate_presence_of session_id, 'Session Id'\r\n      response = @client.call(:read_publication, message: { 'SessionID' => session_id })\r\n      extract_message(response)\r\n    end","code-length":74,"reference":"Reads the first message, if any, in the session queue.","result":"Read a publication.","score":[0,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef open_session(uri, listener_url = nil)\r\n      validate_presence_of uri, 'Channel URI'\r\n      message = { 'ChannelURI' => uri }\r\n      message['ListenerURL'] = listener_url if listener_url\r\n      response = @client.call(:open_consumer_request_session, message: message)\r\n      response.to_hash[:open_consumer_request_session_response][:session_id].to_s\r\n    end","code-length":118,"reference":"Creates a new ISBM ConsumerRequest client.","result":"Open a session.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef post_request(session_id, content, topic, expiry = nil)\r\n      validate_presence_of session_id, 'Session Id'\r\n      validate_presence_of content, 'Content'\r\n      validate_presence_of topic, 'Topic'\r\n      validate_xml content\r\n      xml = Builder::XmlMarkup.new\r\n      xml.isbm :SessionID, session_id\r\n      xml.isbm :MessageContent do\r\n        xml << content\r\n      end\r\n      xml.isbm :Topic, topic\r\n      duration = expiry.to_s\r\n      xml.isbm :Expiry, duration unless duration.nil?\r\n      response = @client.call(:post_request, message: xml.target!)\r\n      response.to_hash[:post_request_response][:message_id].to_s\r\n    end","code-length":205,"reference":"Posts a request message on a channel.","result":"Send a message to a topic.","score":[0.2151,0.4574]}
{"code":"# is used to<extra_id_0>\r\ndef expire_request(session_id, message_id)\r\n      validate_presence_of session_id, 'Session Id'\r\n      validate_presence_of message_id, 'Message Id'\r\n      @client.call(:expire_request, message: { 'SessionID' => session_id, 'MessageID' => message_id })\r\n      return true\r\n    end","code-length":97,"reference":"Expires a posted request message.","result":"Expire a request.","score":[0.2096,0.3906]}
{"code":"# is used to<extra_id_0>\r\ndef read_response(session_id, request_message_id)\r\n      validate_presence_of session_id, 'Session Id'\r\n      validate_presence_of request_message_id, 'Request Message Id'\r\n      message = { 'SessionID' => session_id, 'RequestMessageID' => request_message_id }\r\n      response = @client.call(:read_response, message: message)\r\n      extract_message(response)\r\n    end","code-length":117,"reference":"Returns the first response message, if any, in the message queue associated with the request.","result":"Read the response.","score":[0.0075,0.0362]}
{"code":"# is used to<extra_id_0>\r\ndef remove_response(session_id, request_message_id)\r\n      validate_presence_of session_id, 'Session Id'\r\n      validate_presence_of request_message_id, 'Request Message Id'\r\n      message = { 'SessionID' => session_id, 'RequestMessageID' => request_message_id }\r\n      @client.call(:remove_response, message: message)\r\n      return true\r\n    end","code-length":111,"reference":"Deletes the first response message, if any, in the message queue associated with the request.","result":"Remove a response from a request message.","score":[0.0515,0.0352]}
{"code":"# is used to<extra_id_0>\r\ndef open_session(uri, topics, listener_url = nil, xpath_expression = nil, xpath_namespaces = [])\r\n      validate_presence_of uri, 'Channel URI'\r\n      validate_presence_of topics, 'Topics'\r\n      validate_presence_of xpath_expression, 'XPath Expression' if xpath_namespaces.present?\r\n      topics = [topics].flatten\r\n      xml = Builder::XmlMarkup.new\r\n      xml.isbm :ChannelURI, uri\r\n      topics.each do |topic|\r\n        xml.isbm :Topic, topic\r\n      end\r\n      xml.isbm :ListenerURL, listener_url unless listener_url.nil?\r\n      xml.isbm :XPathExpression, xpath_expression unless xpath_expression.nil?\r\n      xpath_namespaces.each do |prefix, name|\r\n        xml.isbm :XPathNamespace do\r\n          xml.isbm :NamespacePrefix, prefix\r\n          xml.isbm :NamespaceName, name\r\n        end\r\n      end\r\n      response = @client.call(:open_provider_request_session, message: xml.target!)\r\n      response.to_hash[:open_provider_request_session_response][:session_id].to_s\r\n    end","code-length":297,"reference":"Creates a new ISBM ProviderRequest client.","result":"Open a session.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef post_response(session_id, request_message_id, content)\r\n      validate_presence_of session_id, 'Session Id'\r\n      validate_presence_of request_message_id, 'Request Message Id'\r\n      validate_presence_of content, 'Content'\r\n      validate_xml content\r\n      xml = Builder::XmlMarkup.new\r\n      xml.isbm :SessionID, session_id\r\n      xml.isbm :RequestMessageID, request_message_id\r\n      xml.isbm :MessageContent do\r\n        xml << content\r\n      end\r\n      response = @client.call(:post_response, message: xml.target!)\r\n      response.to_hash[:post_response_response][:message_id].to_s\r\n    end","code-length":191,"reference":"Posts a response message on a channel.","result":"Send a message to a specific request.","score":[0.2125,0.4509]}
{"code":"# is used to<extra_id_0>\r\ndef create_channel(uri, type, description = nil, tokens = {})\r\n      validate_presence_of uri, 'Channel URI'\r\n      validate_presence_of type, 'Channel Type'\r\n      channel_type = type.to_s.downcase.capitalize\r\n      validate_inclusion_in channel_type, IsbmAdaptor::Channel::TYPES, 'Channel Type'\r\n      message = { 'ChannelURI' => uri,\r\n                  'ChannelType' => channel_type }\r\n      message['ChannelDescription'] = description unless description.nil?\r\n      message['SecurityToken'] = security_token_hash(tokens) if tokens.any?\r\n      @client.call(:create_channel, message: message)\r\n      return true\r\n    end","code-length":185,"reference":"Creates a new ISBM ChannelManagement client.","result":"Create a new channel.","score":[0.274,0.5077]}
{"code":"# is used to<extra_id_0>\r\ndef add_security_tokens(uri, tokens = {})\r\n      validate_presence_of uri, 'Channel URI'\r\n      validate_presence_of tokens, 'Security Tokens'\r\n      message = { 'ChannelURI' => uri,\r\n                  'SecurityToken' => security_token_hash(tokens) }\r\n      @client.call(:add_security_tokens, message: message)\r\n      return true\r\n    end","code-length":107,"reference":"Adds security tokens to a channel.","result":"Add security tokens to a channel.","score":[0.8034,0.9977]}
{"code":"# is used to<extra_id_0>\r\ndef remove_security_tokens(uri, tokens = {})\r\n      validate_presence_of uri, 'Channel URI'\r\n      validate_presence_of tokens, 'Security Tokens'\r\n      message = { 'ChannelURI' => uri,\r\n                  'SecurityToken' => security_token_hash(tokens) }\r\n      @client.call(:remove_security_tokens, message: message)\r\n      return true\r\n    end","code-length":107,"reference":"Removes security tokens from a channel.","result":"Remove security tokens from a channel.","score":[0.8034,0.9977]}
{"code":"# is used to<extra_id_0>\r\ndef get_channel(uri, &block)\r\n      validate_presence_of uri, 'Channel URI'\r\n      response = @client.call(:get_channel, message: { 'ChannelURI' => uri }, &block)\r\n      hash = response.to_hash[:get_channel_response][:channel]\r\n      IsbmAdaptor::Channel.from_hash(hash)\r\n    end","code-length":99,"reference":"Gets information about the specified channel.","result":"Get the channel.","score":[0.1786,0.2632]}
{"code":"# is used to<extra_id_0>\r\ndef get_channels(&block)\r\n      response = @client.call(:get_channels, {}, &block)\r\n      channels = response.to_hash[:get_channels_response][:channel]\r\n      channels = [channels].compact unless channels.is_a?(Array)\r\n      channels.map do |hash|\r\n        IsbmAdaptor::Channel.from_hash(hash)\r\n      end\r\n    end","code-length":107,"reference":"Gets information about all channels.","result":"Get the channels.","score":[0.2096,0.2083]}
{"code":"# is used to<extra_id_0>\r\ndef update_backend\r\n      if Idioma.configuration.redis_backend\r\n        if i18n_value.present?\r\n          Idioma::RedisBackend.update_phrase(self)\r\n        else\r\n          Idioma::RedisBackend.delete_phrase(self)\r\n        end\r\n      end\r\n    end","code-length":86,"reference":"Will update the i18n backend if it has been configured","result":"Update the backend.","score":[0.0396,0.2016]}
{"code":"# is used to<extra_id_0>\r\ndef set_phrase\r\n        @phrase = Phrase.find(params[:id])\r\n      rescue ActiveRecord::RecordNotFound\r\n        respond_to do |format|\r\n          format.json { render json: {}.to_json, status: :not_found }\r\n          format.html {\r\n            flash[:error] = t('idioma.record_not_found')\r\n            redirect_to phrases_path\r\n          }\r\n        end\r\n      end","code-length":116,"reference":"Use callbacks to share common setup or constraints between actions.","result":"Set the phrase.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef to_s\r\n      date = []\r\n      date << \"#{@years}Y\" unless @years.nil?\r\n      date << \"#{@months}M\" unless @months.nil?\r\n      date << \"#{@days}D\" unless @days.nil?\r\n      time = []\r\n      time << \"#{@hours}H\" unless @hours.nil?\r\n      time << \"#{@minutes}M\" unless @minutes.nil?\r\n      time << \"#{@seconds}S\" unless @seconds.nil?\r\n      result = nil\r\n      if !date.empty? || !time.empty?\r\n        result = 'P'\r\n        result += date.join unless date.empty?\r\n        result += 'T' + time.join unless time.empty?\r\n      end\r\n      result\r\n    end","code-length":192,"reference":"Creates a new Duration based on specified time components.","result":"Convert to ISO 8601 format.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef to_lat format = :dms, dp = 0\r\n      return lat if !format\r\n      GeoUnits::Converter.to_lat lat, format, dp\r\n    end","code-length":50,"reference":"Returns the latitude of this point; signed numeric degrees if no format, otherwise format & dp\n\n ","result":"Convert to a GeoUnit.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef projects\r\n      if @projects.nil?\r\n        response = self.get(\"projects\")\r\n        @projects = response.collect { |project_json| Project.new(project_json) }\r\n      end\r\n      @projects\r\n    end","code-length":68,"reference":"Returns the list of projects available to the authenticated user.","result":"Store the projects.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef project(id)\r\n      @url = \"projects\/#{id}\"\r\n      raise OptimizelyError::NoProjectID, \"A Project ID is required to retrieve the project.\" if id.nil?\r\n      response = self.get(@url)\r\n      Project.new(response)\r\n    end","code-length":78,"reference":"Returns the details for a specific project.","result":"Retrieve the project.","score":[0.128,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef experiments(project_id)\r\n      raise OptimizelyError::NoProjectID, \"A Project ID is required to retrieve experiments.\" if project_id.nil?\r\n      response = self.get(\"projects\/#{project_id}\/experiments\")\r\n      response.collect { |response_json| Experiment.new(response_json) }\r\n    end","code-length":90,"reference":"Returns the list of experiments for a specified project.","result":"Retrieve experiments.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef experiment(id)\r\n      @url = \"experiments\/#{id}\"\r\n      raise OptimizelyError::NoExperimentID, \"An Experiment ID is required to retrieve the experiment.\" if id.nil?\r\n      response = self.get(@url)\r\n      Experiment.new(response)\r\n    end","code-length":80,"reference":"Returns the details for a specific experiment.","result":"Retrieve an experiment.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef stats(experiment_id)\r\n      @url = \"experiments\/#{experiment_id}\/stats\"\r\n      raise OptimizelyError::NoExperimentID, \"An Experiment ID is required to retrieve the stats.\" if experiment_id.nil?\r\n      response = self.get(@url)\r\n      response.collect { |response_json| Stat.new(response_json) }\r\n    end","code-length":100,"reference":"Returns the stats for a specific experiment.","result":"Retrieve the stats for an experiment.","score":[0.3617,0.5435]}
{"code":"# is used to<extra_id_0>\r\ndef variations(experiment_id)\r\n      raise OptimizelyError::NoExperimentID, \"An Experiment ID is required to retrieve variations.\" if experiment_id.nil?\r\n      response = self.get(\"experiments\/#{experiment_id}\/variations\")\r\n      response.collect { |variation_json| Variation.new(variation_json) }\r\n    end","code-length":92,"reference":"Returns the list of variations for a specified experiment.","result":"Retrieve variations for an experiment.","score":[0.169,0.2972]}
{"code":"# is used to<extra_id_0>\r\ndef variation(id)\r\n      @url = \"variations\/#{id}\"\r\n      raise OptimizelyError::NoVariationID, \"A Variation ID is required to retrieve the variation.\" if id.nil?\r\n      response = self.get(@url)\r\n      Variation.new(response)\r\n    end","code-length":81,"reference":"Returns the details for a specific variation.","result":"Retrieve the variation.","score":[0.128,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef audiences(project_id)\r\n      raise OptimizelyError::NoProjectID, \"A Project ID is required to retrieve audiences.\" if project_id.nil?\r\n      response = self.get(\"projects\/#{project_id}\/audiences\")\r\n      response.collect { |audience_json| Audience.new(audience_json) }\r\n    end","code-length":94,"reference":"Returns the list of audiences for a specified project.","result":"Retrieve the project's audiences.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef audience(id)\r\n      @url = \"audiences\/#{id}\"\r\n      raise OptimizelyError::NoAudienceID, \"An Audience ID is required to retrieve the audience.\" if id.nil?\r\n      response = self.get(@url)\r\n      Audience.new(response)\r\n    end","code-length":81,"reference":"Returns the details for a specific audience.","result":"Retrieve the audience.","score":[0.128,0.1515]}
{"code":"# is used to<extra_id_0>\r\ndef get(url)\r\n      uri      = URI.parse(\"#{BASE_URL}#{url}\/\")\r\n      https    = Net::HTTP.new(uri.host, uri.port)\r\n      https.read_timeout = @options[:timeout] if @options[:timeout]\r\n      https.verify_mode = OpenSSL::SSL::VERIFY_NONE\r\n      https.use_ssl = true\r\n      request  = Net::HTTP::Get.new(uri.request_uri, @headers)\r\n      response = https.request(request)\r\n      if response.code != '200'\r\n        check_response(response.code, response.body)\r\n      else\r\n        parse_json(response.body)\r\n      end\r\n    end","code-length":181,"reference":"Return the parsed JSON data for a request that is done to the Optimizely REST API.","result":"Get a resource.","score":[0.0054,0.034]}
{"code":"# is used to<extra_id_0>\r\ndef lget (*keys)\r\n      h = keys.flatten.inject({}) { |hh, k| hh[k] = nil; hh }\r\n      r = @db.mget(h)\r\n      raise 'lget failure' if r == -1\r\n      h\r\n    end","code-length":78,"reference":"Connects to the Tyrant table listening at the given host and port.","result":"Store the value.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef get_random_number(bytes)\r\n      RbNaCl::Util.bin2hex(RbNaCl::Random.random_bytes(bytes).to_s).to_i(16)\r\n    end","code-length":58,"reference":"Create a random number of a specified Byte length returns Bignum","result":"Generate random numbers.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef get_random_number_with_bitlength(bits)\r\n      byte_length = (bits \/ 8.0).ceil + 10\r\n      random_num = get_random_number(byte_length)\r\n      random_num_bin_str = random_num.to_s(2)\r\n      random_num_bin_str.slice(0, bits).to_i(2)\r\n    end","code-length":106,"reference":"Creates a random number of a exact bitlength returns Bignum","result":"Generate a random number.","score":[0.1008,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef add (colname, operator, val, affirmative=true, no_index=false)\r\n      colname = colname.to_s\r\n      val = val.to_s\r\n      op = operator.is_a?(Fixnum) ? operator : OPERATORS[operator]\r\n      op = op | TDBQCNEGATE unless affirmative\r\n      op = op | TDBQCNOIDX if no_index\r\n      @query.addcond(colname, op, val)\r\n    end","code-length":128,"reference":"Adds a condition","result":"Add a new column to the query.","score":[0.1615,0.5515]}
{"code":"# is used to<extra_id_0>\r\ndef keys (options={})\r\n      if @db.respond_to? :fwmkeys\r\n        pref = options.fetch(:prefix, \"\")\r\n        @db.fwmkeys(pref, options[:limit] || -1)\r\n      elsif @db.respond_to? :range\r\n        @db.range(\"[min,max]\", nil)\r\n      else\r\n        raise NotImplementedError, \"Database does not support keys()\"\r\n      end\r\n    end","code-length":117,"reference":"Returns an array of all the primary keys in the db.","result":"Generate the keys.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef autocomplete_to_add_item(name, f, association, source, options = {})\r\n      new_object              = f.object.send(association).klass.new\r\n      options[:class]         = [\"autocomplete add-item\", options[:class]].compact.join \" \"\r\n      options[:data]          ||= {}\r\n      options[:data][:id]     = new_object.object_id\r\n      options[:data][:source] = source\r\n      options[:data][:item]   = f.fields_for(association, new_object, child_index: options[:data][:id]) do |builder|\r\n        render(association.to_s.singularize + \"_item\", f: builder).gsub \"\\n\", \"\"\r\n      end\r\n            text_field_tag \"autocomplete_nested_content\", nil, options\r\n    end","code-length":207,"reference":".nested-container   .nested-autocomplete   .nested-items    .nested-item     .nested-content     .nested-value     .remove-item","result":"Render the nested content.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef fetch( id )\r\n      r = nil\r\n      begin\r\n        r = lib.tcidbget( @db, id )\r\n      rescue => e\r\n        if lib.tcidbecode( @db ) == 22 then\r\n          return nil\r\n        else\r\n          raise_error\r\n        end\r\n      end\r\n      return r\r\n    end","code-length":97,"reference":"Return the document at the specified index","result":"Fetch a block.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef search( expression )\r\n      out_count = ::FFI::MemoryPointer.new :pointer\r\n      out_list  = ::FFI::MemoryPointer.new :pointer\r\n      out_list  = lib.tcidbsearch2( @db, expression, out_count )\r\n      count = out_count.read_int\r\n      results = out_list.get_array_of_uint64(0, count )\r\n      return results\r\n    end","code-length":117,"reference":"Return the document ids of the documents that matche the search expression down to 'Compound Expression of Search'","result":"Search for a string.","score":[0,0.0301]}
{"code":"# is used to<extra_id_0>\r\ndef char_freq(str)\r\n      freqs = Hash.new(0)\r\n      (1..4).each do |i|\r\n        str.chars.each_cons(i).inject(freqs) do |freq, ngram|\r\n          ngram = ngram.join\r\n          freq[ngram] = freq[ngram] + 1\r\n          freq\r\n        end\r\n      end\r\n      freqs\r\n    end","code-length":108,"reference":"Computes a hash of each character","result":"Calculate char frequency.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef top(n, scores)\r\n      scores.sort {|a,b| a[1] <=> b[1]}.map{|x| x[0]}.first(n)\r\n    end","code-length":57,"reference":"Return top scoring, sorted by lowest","result":"Evaluate the top function.","score":[0.1938,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef recolor(bg: 'g.prepend('    fg.prepend('    doc     = Nokogiri::XML(self.string)\r\r\n      doc.css('path')[0]['fill'] = bg\r\n      doc.css('path')[1]['fill'] = fg\r\n      doc.css('path')[0]['fill-opacity'] = bg_opacity.to_s\r\n      doc.css('path')[1]['fill-opacity'] = fg_opacity.to_s\r\n      @svgstr = doc.to_xml\r\r\n      self\r\r\n    end","code-length":144,"reference":"Modify the background and foreground colors and their opacities","result":"Recolor the background.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef compact_copy (target_path)\r\n      @other_db = Cabinet.new(target_path)\r\n      self.each { |k, v| @other_db[k] = v }\r\n      @other_db.close\r\n    end","code-length":71,"reference":"Copies the current cabinet to a new file.","result":"Compact the database.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef keys (options={})\r\n      if @type == \"tcf\"\r\n        min, max = \"min\", \"max\"\r\n        l        = lib.tcfdbrange2( as_fixed, min, Rufus::Tokyo.blen(min),\r\n                                              max, Rufus::Tokyo.blen(max), -1)\r\n      else\r\n        pre = options.fetch(:prefix, \"\")\r\n        l = lib.abs_fwmkeys(\r\n          @db, pre, Rufus::Tokyo.blen(pre), options[:limit] || -1)\r\n      end\r\n      l = Rufus::Tokyo::List.new(l)\r\n      options[:native] ? l : l.release\r\n    end","code-length":193,"reference":"Returns an array with all the keys in the databse in a Ruby array.","result":"Generate the keys.","score":[0.0104,0.0388]}
{"code":"# is used to<extra_id_0>\r\ndef get4 (k)\r\n      l = lib.tcbdbget4(as_btree, k, Rufus::Tokyo.blen(k))\r\n      Rufus::Tokyo::List.new(l).release\r\n    end","code-length":70,"reference":"This is a B+ Tree method only, returns all the values for a given key.","result":"Store the value of the key.","score":[0.0512,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef []= (k, v)\r\n      clib.tcmapput(pointer, k, Rufus::Tokyo::blen(k), v, Rufus::Tokyo::blen(v))\r\n      v\r\n    end","code-length":67,"reference":"Creates an empty instance of a Tokyo Cabinet in-memory map","result":"Store the map values.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef delete (k)\r\n      v = self[k]\r\n      return nil unless v\r\n      clib.tcmapout(pointer_or_raise, k, Rufus::Tokyo::blen(k)) ||\r\n        raise(\"failed to remove key '#{k}'\")\r\n      v\r\n    end","code-length":83,"reference":"Deletes an entry","result":"Remove keys from the hash.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef keys\r\n      clib.tcmapiterinit(pointer_or_raise)\r\n      a = []\r\n      klen = FFI::MemoryPointer.new(:int)\r\n      loop do\r\n        k = clib.tcmapiternext(@pointer, klen)\r\n        break if k.address == 0\r\n        a << k.get_bytes(0, klen.get_int(0))\r\n      end\r\n      return a\r\n    ensure\r\n      klen.free\r\n    end","code-length":129,"reference":"Returns an array of all the keys in the map","result":"Generate keys.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef []= (a, b, c=nil)\r\n      i, s = c.nil? ? [ a, b ] : [ [a, b], c ]\r\n      range = if i.is_a?(Range)\r\n        i\r\n      elsif i.is_a?(Array)\r\n        start, count = i\r\n        (start..start + count - 1)\r\n      else\r\n        [ i ]\r\n      end\r\n      range = norm(range)\r\n      values = s.is_a?(Array) ? s : [ s ]\r\n      range.each_with_index do |offset, index|\r\n        val = values[index]\r\n        if val\r\n          clib.tclistover(@pointer, offset, val, Rufus::Tokyo.blen(val))\r\n        else\r\n          outlen_op(:tclistremove, values.size)\r\n        end\r\n      end\r\n      self\r\n    end","code-length":239,"reference":"The put operation.","result":"Set the value of an array.","score":[0,0.303]}
{"code":"# is used to<extra_id_0>\r\ndef keys (options={})\r\n      pre = options.fetch(:prefix, \"\")\r\n      l = lib.tab_fwmkeys(\r\n        @db, pre, Rufus::Tokyo.blen(pre), options[:limit] || -1)\r\n      l = Rufus::Tokyo::List.new(l)\r\n      options[:native] ? l : l.release\r\n    end","code-length":106,"reference":"Returns an array of all the primary keys in the table in a Ruby array.","result":"Generate the keys.","score":[0.0075,0.0362]}
{"code":"# is used to<extra_id_0>\r\ndef lget (*keys)\r\n      keys.flatten.inject({}) { |h, k|\r\n        k = k.to_s\r\n        v = self[k]\r\n        h[k] = v if v\r\n        h\r\n      }\r\n    end","code-length":74,"reference":"No 'misc' methods for the table library, so this lget is equivalent to calling get for each key.","result":"Get a list of keys.","score":[0,0.0299]}
{"code":"# is used to<extra_id_0>\r\ndef raise_error\r\n      err_code = lib.tab_ecode(@db)\r\n      err_msg = lib.tab_errmsg(err_code)\r\n      raise TokyoError.new(\"(err #{err_code}) #{err_msg}\")\r\n    end","code-length":75,"reference":"Obviously something got wrong, let's ask the db about it and raise a TokyoError","result":"Avoid the following line.","score":[0.0262,0.0385]}
{"code":"# is used to<extra_id_0>\r\ndef each\r\n      (0..size-1).each do |i|\r\n        pk = @list[i]\r\n        if @opts[:pk_only]\r\n          yield(pk)\r\n        else\r\n          val = @table[pk]\r\n          val[:pk] = pk unless @opts[:no_pk]\r\n          yield(val)\r\n        end\r\n      end\r\n    end","code-length":104,"reference":"The classical each","result":"Generate code.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef find(icon)\r\r\n      str = icon.to_s.downcase\r\r\n      file = DB.files[str] ||\r\r\n               DB.files[str.sub(\/\\.svg$\/,'')] ||\r\r\n               not_found(str, icon)\r\r\n      Icon.new(file)\r\r\n    end","code-length":87,"reference":"Find the icon, possibly without the extension.","result":"Find icons.","score":[0.041,0.0769]}
{"code":"# is used to<extra_id_0>\r\ndef get_columns(table_name)\r\n\t\t\tcolumns_arr = []\r\n\t\t    pst = @db.prepare \"SELECT * FROM #{table_name} LIMIT 6\"\r\n\t\t    pst.columns.each do |c|\r\n\t\t    \tcolumns_arr.push(c)\r\n\t\t    end\r\n\t\t  columns_arr\r\n\t\tend","code-length":92,"reference":"Get all colums for a given table.","result":"Get the columns of a table.","score":[0.2151,0.2174]}
{"code":"# is used to<extra_id_0>\r\ndef is_numeric(table_name, column_name)\r\n\t\t\tif @db.execute(\"SELECT #{column_name} from #{table_name} LIMIT 1\").first.first.is_a? Numeric\r\n\t\t\t\treturn true\r\n\t\t\telse\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\tend","code-length":83,"reference":"If the column type is nominal return true.","result":"Check if a column is a numeric.","score":[0.1665,0.1899]}
{"code":"# is used to<extra_id_0>\r\ndef deal_with_valid_option(temp_tables, temp_columns, temp_column_types, res)\r\n\t\t\tif !temp_tables.empty?\r\n\t\t\t\tcheck_given_tables_validity(temp_tables)\r\n\t\t\t\ttemp_tables.each do |t|\r\n\t\t\t\t\tres << convert_table(t)\r\n\t\t\t\tend\r\n\t\t\telsif !temp_columns.keys.empty?\r\n\t\t\t\tcheck_given_columns_validity(temp_columns)\r\n\t\t\t\tres << convert_from_columns_hash(temp_columns)\r\n\t\t\telsif !temp_column_types.empty?\r\n\t\t\t\tcheck_given_columns_validity(temp_column_types)\r\n\t\t\t\tres << convert_from_column_types_hash(temp_column_types)\r\n\t\t\tend\r\n\t\tend","code-length":209,"reference":"If valid option was provided in convert method","result":"Deal with valid option.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef let_context(*args, &block)\r\n      context_string, hash =\r\n        case args.map(&:class)\r\n        when [String, Hash] then [\"#{args[0]} #{args[1]}\", args[1]]\r\n        when [Hash] then [args[0].inspect, args[0]]\r\n        end\r\n      context(context_string) do\r\n        hash.each { |var, value| let(var) { value } }\r\n        instance_eval(&block)\r\n      end\r\n    end","code-length":137,"reference":"This allows us to simplify the case where we want to have a context which contains one or more `let` statements","result":"Define the context for let.","score":[0.0116,0.0515]}
{"code":"# is used to<extra_id_0>\r\ndef subject_should_raise(*args)\r\n      error, message = args\r\n      it_string = \"subject should raise #{error}\"\r\n      it_string += \" (#{message.inspect})\" if message\r\n      it it_string do\r\n        expect { subject }.to raise_error error, message\r\n      end\r\n    end","code-length":86,"reference":"Allows you to simply specify that the subject should raise an exception","result":"Test subject should raise error.","score":[0.122,0.2606]}
{"code":"# is used to<extra_id_0>\r\ndef subject_should_not_raise(*args)\r\n      error, message = args\r\n      it_string = \"subject should not raise #{error}\"\r\n      it_string += \" (#{message.inspect})\" if message\r\n      it it_string do\r\n        expect { subject }.not_to raise_error error, message\r\n      end\r\n    end","code-length":91,"reference":"Allows you to simply specify that the subject should not raise an exception.","result":"Test subject should not raise.","score":[0.0999,0.2413]}
{"code":"# is used to<extra_id_0>\r\ndef login(user, options = {})\r\n      options[:scope] ||= Janus.scope_for(user)\r\n      set_user(user, options)\r\n      Janus::Manager.run_callbacks(:login, user, self, options)\r\n    end","code-length":70,"reference":"Logs a user in.","result":"Set the user.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef logout(*scopes)\r\n      scopes = janus_sessions.keys if scopes.empty?\r\n      scopes.each do |scope|\r\n        _user = user(scope)\r\n        unset_user(scope)\r\n        Janus::Manager.run_callbacks(:logout, _user, self, :scope => scope)\r\n      end\r\n      request.reset_session if janus_sessions.empty?\r\n    end","code-length":109,"reference":"Logs a user out from the given scopes or from all scopes at once if no scope is defined.","result":"Log out the user.","score":[0.0089,0.0857]}
{"code":"# is used to<extra_id_0>\r\ndef set_user(user, options = {})\r\n      scope = options[:scope] || Janus.scope_for(user)\r\n      janus_sessions[scope.to_s] = { 'user_class' => user.class.name, 'user_id' => user.id }\r\n    end","code-length":82,"reference":"Manually sets a user without going throught the whole login or authenticate process.","result":"Set the user.","score":[0.0146,0.0833]}
{"code":"# is used to<extra_id_0>\r\ndef unset_user(scope)\r\n      janus_sessions.delete(scope.to_s)\r\n      @users.delete(scope.to_sym) unless @users.nil?\r\n    end","code-length":57,"reference":"Manually removes the user without going throught the whole logout process.","result":"Unset the user.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef user(scope)\r\n      scope = scope.to_sym\r\n      @users ||= {}\r\n      if authenticated?(scope)\r\n        if @users[scope].nil?\r\n          begin\r\n          @users[scope] = user_class(scope).find(session(scope)['user_id'])\r\n          rescue ActiveRecord::RecordNotFound\r\n            unset_user(scope)\r\n          else\r\n            Janus::Manager.run_callbacks(:fetch, @users[scope], self, :scope => scope)\r\n          end\r\n        end\r\n        @users[scope]\r\n      end\r\n    end","code-length":152,"reference":"Returns the currently connected user.","result":"Access the user.","score":[0.2493,0.2083]}
{"code":"# is used to<extra_id_0>\r\ndef namespace\r\n      return '\r\n      @namespace || Tml.config.cache[:namespace] || Tml.config.application[:key][0..5]\r\n    end","code-length":49,"reference":"namespace of each cache key","result":"Define the namespace.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef extract_version(app, version = nil)\r\n      if version\r\n        Tml.cache.version.set(version.to_s)\r\n      else\r\n        version_data = app.api_client.get_from_cdn('version', {t: Time.now.to_i}, {uncompressed: true})\r\n        unless version_data\r\n          Tml.logger.debug('No releases have been generated yet. Please visit your Dashboard and publish translations.')\r\n          return\r\n        end\r\n        Tml.cache.version.set(version_data['version'])\r\n      end\r\n    end","code-length":153,"reference":"Pulls cache version from CDN","result":"Extract the version number.","score":[0.2488,0.2041]}
{"code":"# is used to<extra_id_0>\r\ndef warmup(version = nil, cache_path = nil)\r\n      if cache_path.nil?\r\n        warmup_from_cdn(version)\r\n      else\r\n        warmup_from_files(version, cache_path)\r\n      end\r\n    end","code-length":73,"reference":"Warms up cache from CDN or local files","result":"Create the warmup function.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef warmup_from_files(version = nil, cache_path = nil)\r\n      t0 = Time.now\r\n      Tml.logger = Logger.new(STDOUT)\r\n      Tml.logger.debug('Starting cache warmup from local files...')\r\n      version ||= Tml.config.cache[:version]\r\n      cache_path ||= Tml.config.cache[:path]\r\n      cache_path = \"#{cache_path}\/#{version}\"\r\n      Tml.cache.version.set(version.to_s)\r\n      Tml.logger.debug(\"Warming Up Version: #{Tml.cache.version}\")\r\n      application = JSON.parse(File.read(\"#{cache_path}\/application.json\"))\r\n      Tml.cache.store(Tml::Application.cache_key, application)\r\n      sources = JSON.parse(File.read(\"#{cache_path}\/sources.json\"))\r\n      application['languages'].each do |lang|\r\n        locale = lang['locale']\r\n        language = JSON.parse(File.read(\"#{cache_path}\/#{locale}\/language.json\"))\r\n        Tml.cache.store(Tml::Language.cache_key(locale), language)\r\n        sources.each do |src|\r\n          source = JSON.parse(File.read(\"#{cache_path}\/#{locale}\/sources\/#{src}.json\"))\r\n          Tml.cache.store(Tml::Source.cache_key(locale, src), source)\r\n        end\r\n      end\r\n      t1 = Time.now\r\n      Tml.logger.debug(\"Cache warmup took #{t1-t0}s\")\r\n    end","code-length":399,"reference":"Warms up cache from local files","result":"Warm up cache from local files.","score":[0.6043,0.83]}
{"code":"# is used to<extra_id_0>\r\ndef warmup_from_cdn(version = nil)\r\n      t0 = Time.now\r\n      Tml.logger = Logger.new(STDOUT)\r\n      Tml.logger.debug('Starting cache warmup from CDN...')\r\n      app = Tml::Application.new(key: Tml.config.application[:key], cdn_host: Tml.config.application[:cdn_host])\r\n      extract_version(app, version)\r\n      Tml.logger.debug(\"Warming Up Version: #{Tml.cache.version}\")\r\n      application = app.api_client.get_from_cdn('application', {t: Time.now.to_i})\r\n      Tml.cache.store(Tml::Application.cache_key, application)\r\n      sources = app.api_client.get_from_cdn('sources', {t: Time.now.to_i}, {uncompressed: true})\r\n      application['languages'].each do |lang|\r\n        locale = lang['locale']\r\n        language = app.api_client.get_from_cdn(\"#{locale}\/language\", {t: Time.now.to_i})\r\n        Tml.cache.store(Tml::Language.cache_key(locale), language)\r\n        sources.each do |src|\r\n          source = app.api_client.get_from_cdn(\"#{locale}\/sources\/#{src}\", {t: Time.now.to_i})\r\n          Tml.cache.store(Tml::Source.cache_key(locale, src), source)\r\n        end\r\n      end\r\n      t1 = Time.now\r\n      Tml.logger.debug(\"Cache warmup took #{t1-t0}s\")\r\n    end","code-length":417,"reference":"Warms up cache from CDN","result":"Warm up the cache from CDN.","score":[0.3021,0.7353]}
{"code":"# is used to<extra_id_0>\r\ndef default_cache_path\r\n      @cache_path ||= begin\r\n        path = Tml.config.cache[:path]\r\n        path ||= 'config\/tml'\r\n        FileUtils.mkdir_p(path)\r\n        FileUtils.chmod(0777, path)\r\n        path\r\n      end\r\n    end","code-length":84,"reference":"default cache path","result":"Generate the cache.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef download(cache_path = default_cache_path, version = nil)\r\n      t0 = Time.now\r\n      Tml.logger = Logger.new(STDOUT)\r\n      Tml.logger.debug('Starting cache download...')\r\n      app = Tml::Application.new(key: Tml.config.application[:key], cdn_host: Tml.config.application[:cdn_host])\r\n      extract_version(app, version)\r\n      Tml.logger.debug(\"Downloading Version: #{Tml.cache.version}\")\r\n      archive_name = \"#{Tml.cache.version}.tar.gz\"\r\n      path = \"#{cache_path}\/#{archive_name}\"\r\n      url = \"#{app.cdn_host}\/#{Tml.config.application[:key]}\/#{archive_name}\"\r\n      Tml.logger.debug(\"Downloading cache file: #{url}\")\r\n      open(path, 'wb') do |file|\r\n        file << open(url).read\r\n      end\r\n      Tml.logger.debug('Extracting cache file...')\r\n      version_path = \"#{cache_path}\/#{Tml.cache.version}\"\r\n      Tml::Utils.untar(Tml::Utils.ungzip(File.new(path)), version_path)\r\n      Tml.logger.debug(\"Cache has been stored in #{version_path}\")\r\n      File.unlink(path)\r\n      begin\r\n        current_path = 'current'\r\n        FileUtils.chdir(cache_path)\r\n        FileUtils.rm(current_path) if File.exist?(current_path)\r\n        FileUtils.ln_s(Tml.cache.version.to_s, current_path)\r\n        Tml.logger.debug(\"The new version #{Tml.cache.version} has been marked as current\")\r\n      rescue Exception => ex\r\n        Tml.logger.debug(\"Could not generate current symlink to the cache path: #{ex.message}\")\r\n      end\r\n      t1 = Time.now\r\n      Tml.logger.debug(\"Cache download took #{t1-t0}s\")\r\n    end","code-length":507,"reference":"downloads cache from the CDN","result":"Download the cache.","score":[0.2096,0.2083]}
{"code":"# is used to<extra_id_0>\r\ndef say(message, color=nil)\r\n      @shell ||= Thor::Shell::Basic.new\r\n      @shell.say message, color\r\n    end","code-length":47,"reference":"shortcut to say","result":"Escape the string.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef validate_cache_version(version)\r\n      if Tml.config.cache[:version]\r\n        return Tml.config.cache[:version]\r\n      end\r\n      return version unless version.is_a?(Hash)\r\n      return 'undefined' unless version['t'].is_a?(Numeric)\r\n      return version['version'] if cache.read_only?\r\n      if version_check_interval == -1\r\n        Tml.logger.debug('Cache version check is disabled')\r\n        return version['version']\r\n      end\r\n      expires_at = version['t'] + version_check_interval\r\n      if expires_at < Time.now.to_i\r\n        Tml.logger.debug('Cache version is outdated, needs refresh')\r\n        return 'undefined'\r\n      end\r\n      delta = expires_at - Time.now.to_i\r\n      Tml.logger.debug(\"Cache version is up to date, expires in #{delta}s\")\r\n      version['version']\r\n    end","code-length":249,"reference":"validate that current cache version hasn't expired","result":"Validate the cache version.","score":[0.1509,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef fetch\r\n      self.version = begin\r\n        ver = cache.fetch(CACHE_VERSION_KEY) do\r\n          {'version' => Tml.config.cache[:version] || 'undefined', 't' => cache_timestamp}\r\n        end\r\n        validate_cache_version(ver)\r\n      end\r\n    end","code-length":86,"reference":"fetches the version from the cache","result":"Fetch the cache version.","score":[0.274,0.4406]}
{"code":"# is used to<extra_id_0>\r\ndef [] file, *ps, &exe\r\n\t\t\topts = ::Hash === ps.last ? ps.pop : {}\r\n\t\t\topts[:env] = self\r\n\t\t\tname, type, flg = ps[0] || opts[:name], ps[1] || opts[:type], ps[2] || opts[:flags]\r\n\t\t\tps.push opts\r\n\t\t\t@dbs[ [file, name, flg | CREATE]] ||= (type || SBDB::Unknown).new file, *ps, &exe\r\n\t\tend","code-length":132,"reference":"Returns the DB like open, but if it's already opened, it returns the old instance.","result":"Create a new database.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef run_strategies(scope)\r\n      Janus::Manager.strategies.each { |name| break if run_strategy(name, scope) }\r\n    end","code-length":48,"reference":"Runs authentication strategies to log a user in.","result":"Run the code.","score":[0,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef run_strategy(name, scope)\r\n      strategy = \"Janus::Strategies::#{name.to_s.camelize}\".constantize.new(scope, self)\r\n      if strategy.valid?\r\n        strategy.authenticate!\r\n        if strategy.success?\r\n          send(strategy.auth_method, strategy.user, :scope => scope)\r\n          Janus::Manager.run_callbacks(:authenticate, strategy.user, self, :scope => scope)\r\n        end\r\n      end\r\n      strategy.success?\r\n    end","code-length":138,"reference":"Runs a given strategy and returns true if it succeeded.","result":"Run a strategy.","score":[0.0396,0.2016]}
{"code":"# is used to<extra_id_0>\r\ndef perform(script)\r\n      export_variables = @params.reverse_merge(\"PARADUCT_JOB_ID\" => @job_id, \"PARADUCT_JOB_NAME\" => job_name)\r\n      variable_string = export_variables.map { |key, value| %(export #{key}=\"#{value}\";) }.join(\" \")\r\n      Array.wrap(script).inject(\"\") do |stdout, command|\r\n        stdout << run_command(\"#{variable_string} #{command}\")\r\n        stdout\r\n      end\r\n    end","code-length":137,"reference":"run script with params ","result":"Perform the job.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef print_hex(data, chunk_index, cols=80)\r\n      case hex_style\r\n      when 'lower', 'lowercase'\r\n        print Sixword::Hex.encode(data)\r\n      when 'finger', 'fingerprint'\r\n        newlines_every = cols \/ 5\r\n        if chunk_index != 0\r\n          if chunk_index % newlines_every == 0\r\n            print \"\\n\"\r\n          else\r\n            print ' '\r\n          end\r\n        end\r\n        print Sixword::Hex.encode_fingerprint(data)\r\n      when 'colon', 'colons'\r\n        print ':' unless chunk_index == 0\r\n        print Sixword::Hex.encode_colons(data)\r\n      end\r\n    end","code-length":187,"reference":"Format data as hex in various styles.","result":"Print a chunk of data.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef read_input_by_6_words\r\n      word_arr = []\r\n      while true\r\n        line = stream.gets\r\n        if line.nil?\r\n          break\r\n        end\r\n        line.scan(\/\\S+\/) do |word|\r\n          word_arr << word\r\n          if word_arr.length == 6\r\n            yield word_arr\r\n            word_arr.clear\r\n          end\r\n        end\r\n      end\r\n      if !word_arr.empty?\r\n        yield word_arr\r\n      end\r\n    end","code-length":143,"reference":"Yield data 6 words at a time until EOF","result":"Read input by 6 words.","score":[0.108,0.0581]}
{"code":"# is used to<extra_id_0>\r\ndef select(query, filters)\r\n      where, *bind_values = conditions(query, filters)\r\n      [\r\n        [\r\n          from(filters),\r\n          where,\r\n          order_by(filters),\r\n          limits(filters)\r\n        ].join(\" \"),\r\n        *bind_values\r\n      ]\r\n    end","code-length":92,"reference":"Initialize a new QueryBuilder for +index_name+.","result":"Define the select method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef update(id, attributes)\r\n      set_attrs, *bind_values = update_attributes(attributes)\r\n      [\r\n        [\r\n          \"UPDATE #{@index_name} SET\",\r\n          set_attrs,\r\n          \"WHERE id = ?\"\r\n        ].join(\" \"),\r\n        *bind_values.push(id)\r\n      ]\r\n    end","code-length":98,"reference":"Build a SphinxQL query to update the record identified by +id+ with the given attributes.","result":"Update the index.","score":[0.0075,0.0725]}
{"code":"# is used to<extra_id_0>\r\ndef query(sql, *bind_values)\r\n      @pool.acquire { |conn| conn.query(sql, *bind_values).first }\r\n    end","code-length":48,"reference":"Execute a single read query.","result":"Generate the statement.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(method, *args, &block)\r\n      if method.to_s =~ \/^asynch?_(.*)\/\r\n        if instance_methods(false).detect{|meth| meth.to_s == $1 }\r\n          Woodhouse.dispatch(@worker_name, $1, args.first)\r\n        else\r\n          super\r\n        end\r\n      else\r\n        super\r\n      end\r\n    end","code-length":112,"reference":"You can dispatch a job +baz+ on class +FooBar+ by calling FooBar.async_baz.","result":"Super.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add_node(node)\r\n      if node.respond_to?(:to_sym)\r\n        node = Woodhouse::Layout::Node.new(node.to_sym)  \r\n      end\r\n      expect_arg :node, Woodhouse::Layout::Node, node\r\n      @nodes << node\r\n      node\r\n    end","code-length":90,"reference":"Adds a Node to this layout.","result":"Add nodes to the layout.","score":[0.2339,0.535]}
{"code":"# is used to<extra_id_0>\r\ndef node(name)\r\n      name = name.to_sym\r\n      @nodes.detect{|node|\r\n        node.name == name\r\n      }\r\n    end","code-length":51,"reference":"Looks up a Node by name and returns it.","result":"Create a node.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef canonical(attribute_list)\r\n      case attribute_list\r\n      when nil then {}\r\n      when Hash then attribute_list\r\n      when Array\r\n        attribute_list.map do |attributes|\r\n          case attributes\r\n          when Symbol\r\n            {attributes => AUTO}\r\n          when Hash\r\n            attributes\r\n          else\r\n            raise \"Unexpected attributes #{attributes}\"\r\n          end\r\n        end\r\n        .inject({}, :merge)\r\n      else\r\n        raise \"Unexpected attribute_list #{attribute_list}\"\r\n      end\r\n    end","code-length":141,"reference":"some of the values may be set to AUTO.","result":"Canonicalize the attributes.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef imagine(character_or_model, attributes = nil)\r\n      character = to_character(character_or_model)\r\n      prev, @building = @building, []\r\n      CharacterBuilder.new(character).build(attributes) do |ar|\r\n        ar.save!\r\n        @building.each do |built|\r\n          raise ActiveRecord::RecordInvalid, built unless built.persisted? || built.valid?\r\n        end\r\n        Scheherazade.log(:saving, character, ar)\r\n        handle_callbacks(@building)\r\n      end\r\n    ensure\r\n      @built.concat(@building)\r\n      @building = prev\r\n    end","code-length":173,"reference":"Creates a character with the given attributes","result":"Build images.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef with(temp_current)\r\n      keys = temp_current.keys.map{|k| to_character(k)}\r\n      previous_values = current.values_at(*keys)\r\n      current.merge!(Hash[keys.zip(temp_current.values)])\r\n      yield\r\n    ensure\r\n      current.merge!(Hash[keys.zip(previous_values)])\r\n    end","code-length":105,"reference":"Allows one to temporarily override the current characters while the given block executes","result":"Replace the current value.","score":[0.0476,0.0826]}
{"code":"# is used to<extra_id_0>\r\ndef failure(exception_class_or_message, message_or_nil = nil)\r\n      blank.tap do |d|\r\n        d.fail(\r\n          case exception_class_or_message\r\n          when Exception\r\n            raise ArgumentError, \"can't specify both exception and message\" if message_or_nil\r\n            exception_class_or_message\r\n          when Class\r\n            exception_class_or_message.new(message_or_nil)\r\n          else\r\n            RuntimeError.new(exception_class_or_message.to_s)\r\n          end)\r\n      end\r\n    end","code-length":152,"reference":"Return a Deferrable which immediately fails with an exception.","result":"Define a method for the failure.","score":[0.1171,0.0575]}
{"code":"# is used to<extra_id_0>\r\ndef file_length\r\n      if self.audio.is_a?(File) && self.audio.size > MAX_FILE_SIZE\r\n        self.errors.add :audio, \"It's length is excesive. #{MAX_FILE_SIZE} is the limit.\"\r\n        return false\r\n      end\r\n      return true\r\n    end","code-length":89,"reference":"Function to check that the file size isn't excesive.","result":"Determine file length.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef api_call method, payload\r\n      raise ArgumentError, \"API method not specified.\" if method.blank?\r\n      payload ||= {}\r\n      res = @conn.post method.to_s, payload\r\n      raise Faraday::Error, \"Wrong response: #{res.inspect}\" if (res.status != 200)\r\n      return res\r\n    end","code-length":92,"reference":"Function to call API passing a payload","result":"Call the API.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef multi_search(queries)\r\n      unless queries.kind_of?(Hash)\r\n        raise ArgumentError, \"Argument must be a Hash of named queries (#{queries.class} given)\"\r\n      end\r\n      stmts       = []\r\n      bind_values = []\r\n      queries.each do |key, args|\r\n        str, *values = @builder.select(*extract_query_data(args))\r\n        stmts.push(str, \"SHOW META\")\r\n        bind_values.push(*values)\r\n      end\r\n      rs = @conn.multi_query(stmts.join(\";\\n\"), *bind_values)\r\n      Hash[].tap do |result|\r\n        queries.keys.each do |key|\r\n          records, meta = rs.shift, rs.shift\r\n          result[key] = meta_to_hash(meta).tap do |r|\r\n            r[:records] = records.map { |hash|\r\n              hash.inject({}) { |o, (k, v)| o.merge!(k.to_sym => v) }\r\n            }\r\n          end\r\n        end\r\n      end\r\n    end","code-length":280,"reference":"Perform a a batch search on the index.","result":"Search multiple records in a single query.","score":[0.14,0.1266]}
{"code":"# is used to<extra_id_0>\r\ndef has_whereabouts klass=:address, *args\r\n      options = args.extract_options!\r\n      unless klass == :address || Object.const_defined?(klass.to_s.camelize)\r\n        create_address_class(klass.to_s.camelize)\r\n      end\r\n      has_one klass, :as => :addressable, :dependent => :destroy\r\n      accepts_nested_attributes_for klass\r\n      if options[:validate] && options[:validate].is_a?(Array)\r\n        validators = options[:validate]\r\n        set_validators(klass, validators)\r\n      else\r\n        validators = []\r\n      end\r\n      define_singleton_method validate_singleton_for(klass) do validators end\r\n      if options[:geocode] && options[:geocode] == true && defined?(Geocoder)\r\n        geocode = true\r\n        set_geocoding(klass)\r\n      else\r\n        geocode = false\r\n      end\r\n      define_singleton_method geocode_singleton_for(klass) do geocode end\r\n    end","code-length":265,"reference":"Accepts a symbol that will define the inherited type of Address.","result":"Define whereabouts.","score":[0,0.0495]}
{"code":"# is used to<extra_id_0>\r\ndef set_validators klass, fields=[]\r\n      _single = validate_singleton_for(klass)\r\n      klass.to_s.camelize.constantize.class_eval do\r\n        fields.each do |f|\r\n          validates_presence_of f, \r\n            :if => lambda {|a| a.addressable_type.constantize.send(_single).include?(f)}\r\n        end\r\n      end\r\n    end","code-length":113,"reference":"Sets validates_presence_of fields for the Address based on the singleton method created on the Address addressable_type class.","result":"Set the validators for a given class.","score":[0.0509,0.125]}
{"code":"# is used to<extra_id_0>\r\ndef create_address_class(class_name, &block)\r\n      klass = Class.new Address, &block\r\n      Object.const_set class_name, klass\r\n    end","code-length":52,"reference":"Generate a new class using Address as the superclass.","result":"Create the address class.","score":[0.0915,0.1176]}
{"code":"# is used to<extra_id_0>\r\ndef event_loop\r\n      Qwirk.logger.debug \"#{self}: Starting receive loop\"\r\n      @start_worker_time = Time.now\r\n      until @stopped || (config.stopped? && @impl.ready_to_stop?)\r\n        Qwirk.logger.debug \"#{self}: Waiting for read\"\r\n        @start_read_time = Time.now\r\n        msg = @impl.receive_message\r\n        if msg\r\n          @start_processing_time = Time.now\r\n          Qwirk.logger.debug {\"#{self}: Done waiting for read in #{@start_processing_time - @start_read_time} seconds\"}\r\n          delta = config.timer.measure do\r\n            @processing_mutex.synchronize do\r\n              on_message(msg)\r\n              @impl.acknowledge_message(msg)\r\n            end\r\n          end\r\n          Qwirk.logger.info {\"#{self}::on_message (#{'%.1f' % delta}ms)\"} if self.config.log_times\r\n          Qwirk.logger.flush if Qwirk.logger.respond_to?(:flush)\r\n        end\r\n      end\r\n      Qwirk.logger.info \"#{self}: Exiting\"\r\n    rescue Exception => e\r\n      @status = \"Terminated: #{e.message}\"\r\n      Qwirk.logger.error \"#{self}: Exception, thread terminating: #{e.message}\\n\\t#{e.backtrace.join(\"\\n\\t\")}\"\r\n    ensure\r\n      @status = 'Stopped'\r\n      Qwirk.logger.flush if Qwirk.logger.respond_to?(:flush)\r\n      config.worker_stopped(self)\r\n    end","code-length":421,"reference":"Start the event loop for handling messages off the queue","result":"Run the worker in a thread.","score":[0.0991,0.0521]}
{"code":"# is used to<extra_id_0>\r\ndef arel_attributes_values(include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes.keys)\r\n      attrs = {}\r\n      attribute_names.each do |name|\r\n        if (column = column_for_attribute(name)) && (include_primary_key || !column.primary)\r\n          if include_readonly_attributes || (!include_readonly_attributes && !self.class.readonly_attributes.include?(name))\r\n            value = read_attribute(name)\r\n            if self.class.columns_hash[name].type == :hstore && value && value.is_a?(Hash)\r\n              value = value.to_hstore\r\n            elsif value && self.class.serialized_attributes.has_key?(name) && (value.acts_like?(:date) || value.acts_like?(:time) || value.is_a?(Hash) || value.is_a?(Array))\r\n              value = value.to_yaml\r\n            end\r\n            attrs[self.class.arel_table[name]] = value\r\n          end\r\n        end\r\n      end\r\n      attrs\r\n    end","code-length":288,"reference":"This method is replaced for Rails 3 compatibility.","result":"Generate the attributes values.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef requires_version(cmd, version_)\r\n      v = check_version(version_)\r\n      raise NoMethodError, format('%s is not supported in Bugzilla %s', cmd, v[1]) unless v[0]\r\n    end","code-length":66,"reference":"def check_version rdoc","result":"Define methods.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef run\r\n      begin\r\n        Clacks.logger.info \"Clacks v#{Clacks::VERSION} started\"\r\n        if Clacks.config[:pop3]\r\n          run_pop3\r\n        elsif Clacks.config[:imap]\r\n          run_imap\r\n        else\r\n          raise \"Either a POP3 or an IMAP server must be configured\"\r\n        end\r\n      rescue Exception => e\r\n        fatal(e)\r\n      end\r\n    end","code-length":120,"reference":"default 10 minutes","result":"Start the application.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef imap_validate_options(options)\r\n      options ||= {}\r\n      options[:mailbox] ||= 'INBOX'\r\n      options[:count]   ||= 5\r\n      options[:order]   ||= :asc\r\n      options[:what]    ||= :first\r\n      options[:keys]    ||= 'ALL'\r\n      options[:delete_after_find] ||= false\r\n      options[:mailbox] = Net::IMAP.encode_utf7(options[:mailbox])\r\n      if options[:archivebox]\r\n        options[:archivebox] = Net::IMAP.encode_utf7(options[:archivebox])\r\n      end\r\n      options\r\n    end","code-length":163,"reference":"Follows mostly the defaults from the Mail gem","result":"Validate the options.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef imap_find(imap)\r\n      options = Clacks.config[:find_options]\r\n      delete_after_find = options[:delete_after_find]\r\n      begin\r\n        break if stopping?\r\n        uids = imap.uid_search(options[:keys] || 'ALL')\r\n        uids.reverse! if options[:what].to_sym == :last\r\n        uids = uids.first(options[:count]) if options[:count].is_a?(Integer)\r\n        uids.reverse! if (options[:what].to_sym == :last && options[:order].to_sym == :asc) ||\r\n                         (options[:what].to_sym != :last && options[:order].to_sym == :desc)\r\n        processed = 0\r\n        expunge = false\r\n        uids.each do |uid|\r\n          break if stopping?\r\n          source = imap.uid_fetch(uid, ['RFC822']).first.attr['RFC822']\r\n          mail = nil\r\n          begin\r\n            mail = Mail.new(source)\r\n            mail.mark_for_delete = true if delete_after_find\r\n            Clacks.config[:on_mail].call(mail)\r\n          rescue StandardError => e\r\n            Clacks.logger.error(e.message)\r\n            Clacks.logger.error(e.backtrace)\r\n          end\r\n          begin\r\n            imap.uid_copy(uid, options[:archivebox]) if options[:archivebox]\r\n            if delete_after_find && (mail.nil? || mail.is_marked_for_delete?)\r\n              expunge = true\r\n              imap.uid_store(uid, \"+FLAGS\", [Net::IMAP::DELETED])\r\n            end\r\n          rescue StandardError => e\r\n            Clacks.logger.error(e.message)\r\n          end\r\n          processed += 1\r\n        end\r\n        imap.expunge if expunge\r\n      end while uids.any? && processed == uids.length\r\n    end","code-length":477,"reference":"Keep processing emails until nothing is found anymore, or until a QUIT signal is received to stop the process.","result":"Find mails.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef rainbow(str)\r\n    i=0\r\n    ret = '' \r\n    str=str.to_s\r\n    while(i < str.length)\r\n      ch = str[i]\r\n      palette = $color_db[0][i % $color_db[0].length ]\r\n      ret << (colora(palette,str[i,1]))\r\n      i += 1\r\n    end\r\n    ret\r\n  end","code-length":117,"reference":"carattere per carattere...","result":"Generate the rainbow.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef large_enough_prime(input)\r\n      standard_primes.each do |prime|\r\n        return prime if prime > input\r\n      end\r\n      fail CannotFindLargeEnoughPrime, \"Input too large\"\r\n    end","code-length":65,"reference":"Retrieves the next largest prime for the largest number in batch","result":"Generate the code.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef enhance_content(value, separator = ', ')\r\n      value.is_a?(Array) ? value.join(separator) : value\r\n    end","code-length":45,"reference":"Combines array into a string with given separator","result":"Enhance the content.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef i_to_s(input)\r\n      if !input.is_a?(Integer) || input < 0\r\n        fail NotPositiveInteger, \"input must be a non-negative integer\"\r\n      end\r\n      output = \"\"\r\n      while input > 0\r\n        input, codepoint = input.divmod(charset.length)\r\n        output.prepend(codepoint_to_char(codepoint))\r\n      end\r\n      output\r\n    end","code-length":116,"reference":"The \"null-byte\" character is prepended to be the first character in the charset to avoid loosing the first character of the charset when it is also the first character in a string to convert.","result":"Convert the input to a string.","score":[0.0024,0.0481]}
{"code":"# is used to<extra_id_0>\r\ndef s_to_i(string)\r\n      string.chars.reduce(0) do |output, char|\r\n        output * charset.length + char_to_codepoint(char)\r\n      end\r\n    end","code-length":61,"reference":"Calculate an integer from a string.","result":"Convert strings to integers.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef char_to_codepoint(c)\r\n      codepoint = charset.index c\r\n      if codepoint.nil?\r\n        fail NotInCharset, \"Char \\\"#{c}\\\" not part of the supported charset\"\r\n      end\r\n      codepoint\r\n    end","code-length":69,"reference":"Convert a single character into its integer representation according to the charset.","result":"Convert char to codepoint.","score":[0.0514,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef subset?(string)\r\n      (Set.new(string.chars) - Set.new(charset)).empty?\r\n    end","code-length":41,"reference":"Check if the provided string can be represented by the charset.","result":"Check subset.","score":[0.0056,0.0495]}
{"code":"# is used to<extra_id_0>\r\ndef points(num_points, prime)\r\n      intercept = @coefficients[0]\r\n      (1..num_points).map do |x|\r\n        y = intercept\r\n        (1...@coefficients.length).each do |i|\r\n          y = (y + @coefficients[i] * x ** i) % prime\r\n        end\r\n        Point.new(x, y)\r\n      end\r\n    end","code-length":111,"reference":"Create a new instance of a Polynomial with n coefficients, when having the polynomial in standard polynomial form.","result":"Generate the points.","score":[0.0028,0.0303]}
{"code":"# is used to<extra_id_0>\r\ndef validate!\r\n      files = Dir.glob(File.join(@directory, '*.xml')).sort\r\n      threads = []\r\n      files.map do |path|\r\n        threads << Thread.new(path) do |path_t|\r\n          eadid = File.basename(path_t, '.xml')\r\n          begin\r\n            ead = Mead::Ead.new({:file => File.open(path_t), :eadid => eadid})\r\n          rescue => e\r\n            record_invalid(eadid, ead, e)\r\n            next\r\n          end\r\n          if ead.valid?\r\n            @valid << eadid\r\n          else\r\n            record_invalid(eadid, ead)\r\n          end\r\n        end\r\n      end\r\n      threads.each { |thread|  thread.join }\r\n      metadata\r\n    end","code-length":219,"reference":"Creates a new EadValidator when given the path to a directory as a String","result":"Validate the metadata.","score":[0.0104,0.0388]}
{"code":"# is used to<extra_id_0>\r\ndef notify_create\r\n      self.ChannelPublications.each do |publication, options|\r\n        if options[:actions].include? :create\r\n          records = self.class.scoped_collection(options[:scope])\r\n          if options[:scope]==:all or record_within_scope(records)\r\n            ActionCable.server.broadcast publication,\r\n              msg: 'create',\r\n              id: self.id,\r\n              data: self\r\n          end\r\n        end\r\n      end\r\n    end","code-length":129,"reference":"Broadcast notifications when a new record is created","result":"Notify the server about.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef notify_update\r\n      if self.respond_to?(:saved_changes)\r\n        changes = self.saved_changes.transform_values(&:second)\r\n      else\r\n        changes = self.changes.transform_values(&:second)\r\n      end\r\n      if !changes.empty?\r\n        self.ChannelPublications.each do |publication, options|\r\n          if options[:actions].include? :update\r\n            record = record_within_scope(options[:records])\r\n            was_in_scope = record.present?\r\n            options[:records].delete(record) if was_in_scope\r\n            if options[:track_scope_changes]==true\r\n              is_in_scope = false\r\n              if options[:scope]==:all\r\n                record = self\r\n                is_in_scope = true\r\n              else\r\n                record = record_within_scope(self.class.scoped_collection(options[:scope]))\r\n                if record.present?\r\n                  is_in_scope = true\r\n                end\r\n              end\r\n            else\r\n              is_in_scope = was_in_scope\r\n            end\r\n            if is_in_scope\r\n              if was_in_scope\r\n                changes.select!{|k,v| record.respond_to?(k)}\r\n                if !changes.empty?\r\n                  ActionCable.server.broadcast publication,\r\n                    msg: 'update',\r\n                    id: self.id,\r\n                    data: changes\r\n                end\r\n              else\r\n                ActionCable.server.broadcast publication,\r\n                  msg: 'create',\r\n                  id: record.id,\r\n                  data: record\r\n              end\r\n            elsif was_in_scope\r\n              ActionCable.server.broadcast publication,\r\n                msg: 'destroy',\r\n                id: self.id\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end","code-length":468,"reference":"Broadcast notifications when a record is updated.","result":"Notify the channel publication.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef notify_destroy\r\n      self.ChannelPublications.each do |publication, options|\r\n        if options[:scope]==:all or options[:actions].include? :destroy\r\n          if options[:scope]==:all or record_within_scope(self.class.scoped_collection(options[:scope])).present?\r\n            ActionCable.server.broadcast publication,\r\n              msg: 'destroy',\r\n              id: self.id\r\n          end\r\n        end\r\n      end\r\n    end","code-length":126,"reference":"Broadcast notifications when a record is destroyed.","result":"Notify the destroy of the channel.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef logger(obj)\r\n      %w(debug info warn error fatal level).each do |m|\r\n        next if obj.respond_to?(m)\r\n        raise ArgumentError, \"logger #{obj} does not respond to method #{m}\"\r\n      end\r\n      map[:logger] = obj\r\n    end","code-length":82,"reference":"Sets the Logger-like object.","result":"Define the logger.","score":[0.2925,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef fetch_rates\r\n      if self.class.superclass.eql?(Object)\r\n        raise Exception.new(\"This method should be invoked from CurrencySpy::Scraper sub class\")\r\n      else\r\n        check_currency_code_validity\r\n        rate_results = {}\r\n        RATE_DATA.each do |rate|\r\n          symbol = rate.to_sym\r\n          if self.class.instance_methods.include?(symbol)\r\n            value = self.send(symbol)\r\n            rate_results[symbol] = value unless value.nil?\r\n          end\r\n        end\r\n        rate_results\r\n      end\r\n    end","code-length":165,"reference":"Method which calls all rate fetching methods from the sub class and returns a Hash with appropriate values.","result":"Fetch rates from the currency.","score":[0.0252,0.189]}
{"code":"# is used to<extra_id_0>\r\ndef parse(target)\r\r\n      if (width = fmt.width) > 0\r\r\n        head, tail = src[0...width], src[width..-1] || \"\"\r\r\n      else\r\r\n        head, tail = src, \"\"\r\r\n      end\r\r\n\r\r\n      @prematch, @match, @postmatch = head.partition(target)\r\r\n\r\r\n      if found?\r\r\n        @src = @postmatch + tail\r\r\n        @match\r\r\n      else\r\r\n        nil\r\r\n      end\r\r\n    end","code-length":144,"reference":"Parse the source string for a target string or regex or return nil.","result":"Parse the source.","score":[0.0206,0.1563]}
{"code":"# is used to<extra_id_0>\r\ndef grab\r\r\n      width = fmt.width\r\r\n\r\r\n      if width > 0\r\r\n        result, @src = src[0...width], src[width..-1] || \"\"\r\r\n      elsif width == 0\r\r\n        result, @src = src[0...1], src[1..-1] || \"\"\r\r\n      elsif width == -1\r\r\n        result, @src = src, \"\"\r\r\n      else\r\r\n        result, @src = src[0..width], src[(width+1)..-1] || \"\"\r\r\n      end\r\r\n\r\r\n      result\r\r\n    end","code-length":159,"reference":"Grab some text","result":"Format the source.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get_comments(bugs)\r\n      params = {}\r\n      params['ids'] = case bugs\r\n      when Array\r\n        bugs\r\n      when Integer || String\r\n        [bugs]\r\n      else\r\n        raise ArgumentError, format('Unknown type of arguments: %s', bugs.class)\r\n      end\r\n      result = comments(params)\r\n      ret = result['bugs']\r\n      unless check_version(4.4)[0]\r\n        ret.each do |_id, o|\r\n          o['comments'].each do |c|\r\n            c['creation_time'] = c['time'] unless c.include?('creation_time')\r\n          end\r\n        end\r\n      end\r\n      ret\r\n    end","code-length":183,"reference":"def get_bugs rdoc","result":"Get the comments for a given bug.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef save_persist_state\r\n      return unless @persist_file\r\n      new_persist_options = {}\r\n      BaseWorker.worker_classes.each do |worker_class|\r\n        worker_class.each_config(@adapter_factory.worker_config_class) do |config_name, ignored_extended_worker_config_class, default_options|\r\n          static_options = default_options.merge(@worker_options[config_name] || {})\r\n          worker_config = self[config_name]\r\n          hash = {}\r\n          worker_config.bean_get_attributes do |attribute_info|\r\n            if attribute_info.attribute[:config_item] && attribute_info.ancestry.size == 1\r\n              param_name = attribute_info.ancestry[0].to_sym\r\n              value = attribute_info.value\r\n              hash[param_name] = value if static_options[param_name] != value\r\n            end\r\n          end\r\n          new_persist_options[config_name] = hash unless hash.empty?\r\n        end\r\n      end\r\n      if new_persist_options != @persist_options\r\n        @persist_options = new_persist_options\r\n        File.open(@persist_file, 'w') do |out|\r\n          YAML.dump(@persist_options, out )\r\n        end\r\n      end\r\n    end","code-length":335,"reference":"Store off any options that are no longer set to default","result":"Save the persist state.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef read_pages\r\n      results_projects = database.query(\"SELECT id, identifier, name FROM projects;\")\r\n      results_projects.each do |row_project|\r\n        namespaces << OpenStruct.new(identifier: row_project[\"identifier\"], name: row_project[\"name\"])\r\n      end\r\n      results_wikis = database.query(\"SELECT id, project_id FROM wikis;\")\r\n      results_pages = database.query(\"SELECT id, title, wiki_id FROM wiki_pages;\")\r\n      results_pages.each do |row_page|\r\n        results_contents = database.query(\"SELECT * FROM wiki_content_versions WHERE page_id='#{row_page[\"id\"]}' ORDER BY updated_on;\")\r\n        wiki_row = nil\r\n        project_row = nil\r\n        results_wikis.each do |wiki|\r\n          wiki_row = wiki if wiki[\"id\"] == row_page[\"wiki_id\"]\r\n        end\r\n        if wiki_row\r\n          results_projects.each do |project|\r\n            project_row = project if project[\"id\"] == wiki_row[\"project_id\"]\r\n          end\r\n        end\r\n        project_identifier = project_row ? project_row[\"identifier\"] + '\/' : \"\"\r\n        title = project_identifier + row_page[\"title\"]\r\n        titles << title\r\n        @latest_revisions = {}\r\n        results_contents.each do |row_content|\r\n          author = authors[row_content[\"author_id\"]] ? @authors[row_content[\"author_id\"]] : nil\r\n          page = Page.new({:id => row_content[\"id\"],\r\n                            :title => title,\r\n                            :body => row_content[\"data\"],\r\n                            :markup => :textile,\r\n                            :latest => false,\r\n                            :time => row_content[\"updated_on\"],\r\n                            :message => row_content[\"comments\"],\r\n                            :author => author,\r\n                            :author_name => author.name})\r\n          revisions << page\r\n          @latest_revisions[title] = page\r\n        end\r\n      end\r\n      titles.uniq!\r\n      @latest_revisions.each { |rev| rev[1].set_latest }\r\n      revisions.sort! { |a,b| a.time <=> b.time }\r\n      revisions\r\n    end","code-length":572,"reference":"after calling this action, I expect the titles and revisions to be filled","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef read_response(timeout, &block)\r\n      raise \"Invalid call to read_response for #{@producer}, not setup for responding\" unless @producer.response_options\r\n      @producer.impl.with_response(@adapter_info) do |consumer|\r\n        if block_given?\r\n          return read_multiple_response(consumer, timeout, &block)\r\n        else\r\n          tri = read_single_response(consumer, timeout)\r\n          if tri\r\n            response = tri[1]\r\n            raise response if response.kind_of?(Qwirk::RemoteException)\r\n            return response\r\n          else\r\n            @timeout = !tri\r\n            return nil\r\n          end\r\n        end\r\n      end\r\n    end","code-length":187,"reference":"Waits the given timeout for a response message on the queue.","result":"Read the response.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef add_filter(id, pattern, &block)\r\n      filter = LineFilter.new(id, pattern, block)\r\n      @filters << filter\r\n    end","code-length":48,"reference":"if a line doesn't match any of the patterns, then ","result":"Escape the string.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef write(template = nil)\r\n            if not template.nil? then\r\n                template = template.to_mixml_template\r\n            end\r\n            each_node do |node|\r\n                if template.nil? then\r\n                    node.write_xml_to($stdout)\r\n                    puts\r\n                else\r\n                    puts template.evaluate(node)\r\n                end\r\n            end\r\n        end","code-length":105,"reference":"Print selected nodes to stdout","result":"Write the nodes to the console.","score":[0.273,0.3676]}
{"code":"# is used to<extra_id_0>\r\ndef replace(template)\r\n            template = template.to_mixml_template\r\n            each_node do |node|\r\n                value = template.evaluate(node)\r\n                node.replace(value)\r\n            end\r\n        end","code-length":65,"reference":"Replace selected nodes with a template","result":"Replace nodes in a template.","score":[0.2589,0.2542]}
{"code":"# is used to<extra_id_0>\r\ndef rename(template)\r\n            template = template.to_mixml_template\r\n            each_node do |node|\r\n                value = template.evaluate(node)\r\n                node.name = value\r\n            end\r\n        end","code-length":64,"reference":"Rename selected nodes with a template","result":"Rename nodes.","score":[0.0677,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef commit_revision(page, markup)\r\n      gollum_page = gollum.page(page.title)\r\n      if gollum_page\r\n        gollum.update_page(gollum_page, gollum_page.name, gollum_page.format, page.body, build_commit(page))\r\n      else\r\n        gollum.write_page(page.title, markup, page.body, build_commit(page))\r\n      end\r\n    end","code-length":128,"reference":"Commit the given page into the gollum-wiki-repository.","result":"Commit a revision.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef commit_history(revisions, options = {}, &block)\r\n      options[:markup] = :markdown if !options[:markup]\r\n      revisions.each_with_index do |page, index|\r\n        block.call(page, index) if block_given?\r\n        commit_revision(page, options[:markup])\r\n      end\r\n    end","code-length":91,"reference":"Commit all revisions of the given history into this gollum-wiki-repository.","result":"Commit the history of the revisions.","score":[0.1667,0.3288]}
{"code":"# is used to<extra_id_0>\r\ndef scan_spec(fmt_string)\r\r\n      until fmt_string.empty?\r\r\n        if (match_data = PARSE_REGEX.match(fmt_string))\r\r\n          mid = match_data.to_s\r\r\n          pre = match_data.pre_match\r\r\n\r\r\n          @specs << FormatLiteral.new(pre) unless pre.empty?\r\r\n          @specs << case\r\r\n                    when match_data[:var] then FormatVariable.new(mid)\r\r\n                    when match_data[:set] then FormatSet.new(mid)\r\r\n                    when match_data[:rgx] then FormatRgx.new(mid)\r\r\n                    when match_data[:per] then FormatLiteral.new(\"\\%\")\r\r\n                    else fail \"Impossible case in scan_spec.\"\r\r\n                    end\r\r\n          fmt_string = match_data.post_match\r\r\n        else\r\r\n          @specs << FormatLiteral.new(fmt_string)\r\r\n          fmt_string = \"\"\r\r\n        end\r\r\n      end\r\r\n    end","code-length":264,"reference":"Scan the format string extracting literals and variables.","result":"Parse the format string.","score":[0.1662,0.2467]}
{"code":"# is used to<extra_id_0>\r\ndef to_textile str\r\n      body = body.dup\r\n      body.gsub!(\/\\r\/, '')\r\n      body.gsub!(\/\\{\\{\\{([^\\n]+?)\\}\\}\\}\/, '@\\1@')\r\n      body.gsub!(\/\\{\\{\\{\\n\r\n      body.gsub!(\/\\{\\{\\{(.+?)\\}\\}\\}\/m, '<pre>\\1<\/pre>')\r\n      body.gsub!(\/\\[\\[BR\\]\\]\/, '')\r\n      body.gsub!(\/\\[\\[PageOutline.*\\]\\]\/, '{{toc}}')\r\n      body.gsub!(\/\\[\\[Image\\((.+?)\\)\\]\\]\/, '!\\1!')\r\n      body.gsub!(\/=====\\s(.+?)\\s=====\/, \"h5. #{'\\1'} \\n\\n\")\r\n      body.gsub!(\/====\\s(.+?)\\s====\/,   \"h4. #{'\\1'} \\n\\n\")\r\n      body.gsub!(\/===\\s(.+?)\\s===\/,     \"h3. #{'\\1'} \\n\\n\")\r\n      body.gsub!(\/==\\s(.+?)\\s==\/,       \"h2. #{'\\1'} \\n\\n\")\r\n      body.gsub!(\/=\\s(.+?)\\s=[\\s\\n]*\/,  \"h1. #{'\\1'} \\n\\n\")\r\n      body.gsub!(\/\\|\\|\/,  \"|\")\r\n      body.gsub!(\/\\[(http[^\\s\\[\\]]+)\\s([^\\[\\]]+)\\]\/, ' \"\\2\":\\1' )\r\n      body.gsub!(\/\\[([^\\s]+)\\s(.+)\\]\/, ' [[\\1 | \\2]] ')\r\n      body.gsub!(\/([^\"\\\/\\!])(([A-Z][a-z0-9]+){2,})\/, ' \\1[[\\2]] ')\r\n      body.gsub!(\/\\!(([A-Z][a-z0-9]+){2,})\/, '\\1')\r\n      body.gsub!(\/'''(.+)'''\/, '*\\1*')\r\n      body.gsub!(\/''(.+)''\/, '_\\1_')\r\n      body.gsub!(\/`(.+)`\/, '@\\1@')\r\n      body.gsub!(\/^\\s\\s\\s\\*\/, '***')\r\n      body.gsub!(\/^\\s\\s\\*\/, '**')\r\n      body.gsub!(\/^\\s\\*\/, '*')\r\n      body.gsub!(\/^\\s\\s\\s\\d\\.\/, 'body.gsub!(\/^\\s\\s\\d\\.\/, '    body.gsub!(\/^\\s\\d\\.\/, '\r\n      body\r\n    end","code-length":669,"reference":"take an input stream and convert all wikka syntax to markdown syntax taken from 'trac_wiki_to_textile' at","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef debug2(s, opts = {} )\r\n    out = opts.fetch(:out, $stdout)\r\n    tag = opts.fetch(:tag, '_DFLT_')\r\n    really_write = opts.fetch(:really_write, true)\r\n    write_always = opts.fetch(:write_always, false)\r\n      raise \"ERROR: ':tags' must be an array in debug(), maybe you meant to use :tag?\" if ( opts[:tags] && opts[:tags].class != Array )\r\n    final_str = \"\r\n    final_str = \"\\033[1;30m\" +final_str + \"\\033[0m\" if opts.fetch(:coloured_debug, true)\r\n    if (debug_tags_enabled? )\r\n      puts( final_str ) if debug_tag_include?( opts )\r\n    else\r\n      puts( final_str ) if ((really_write && $DEBUG) || write_always) && ! opts[:tag]\r\n    end\r\n  end","code-length":244,"reference":"shouldnt work right now yet..","result":"Print debug messages.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef exec(command, options={}, &block)\r\n      raise ConnectionClosed.new('Connection is closed.') unless @channel\r\n      options = {\r\n          on_non_zero_exit_code: :default\r\n      }.merge(options || {})\r\n      options[:on_non_zero_exit_code] = @options[:on_non_zero_exit_code] if options[:on_non_zero_exit_code] == :default\r\n      push_buffer\r\n      if block_given?\r\n        buffer_input( &block )\r\n      end\r\n      @channel.send_data command + \"\\n\"\r\n      wait_for_prompt\r\n      if block_given?\r\n        buffer_input\r\n      end\r\n      ret = command_output(command)\r\n      pop_merge_buffer\r\n      if @options[:retrieve_exit_code]\r\n        push_buffer\r\n        retrieve_command = 'echo $?'\r\n        @channel.send_data retrieve_command + \"\\n\"\r\n        wait_for_prompt\r\n        @last_exit_code = command_output(retrieve_command).strip.to_i\r\n        pop_discard_buffer\r\n        if options[:on_non_zero_exit_code] == :raise_error\r\n          raise NonZeroExitCode.new(\"Exit code was #{@last_exit_code}.\") unless @last_exit_code == 0\r\n        end\r\n      end\r\n      ret\r\n    end","code-length":352,"reference":"Executes a command during the shell session.","result":"Execute a command.","score":[0.1076,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef upload(local_file, remote_file)\r\n      raise ConnectionClosed.new('Connection is closed.') unless @ssh\r\n      sftp.upload!(local_file, remote_file)\r\n    end","code-length":57,"reference":"Uses SFTP to upload a single file to the host.","result":"Upload files.","score":[0,0.0543]}
{"code":"# is used to<extra_id_0>\r\ndef download(remote_file, local_file)\r\n      raise ConnectionClosed.new('Connection is closed.') unless @ssh\r\n      sftp.download!(remote_file, local_file)\r\n    end","code-length":57,"reference":"Uses SFTP to download a single file from the host.","result":"Download files.","score":[0,0.0543]}
{"code":"# is used to<extra_id_0>\r\ndef write_file(remote_file, data)\r\n      raise ConnectionClosed.new('Connection is closed.') unless @ssh\r\n      sftp.file.open(remote_file, 'w') do |f|\r\n        f.write data\r\n      end\r\n    end","code-length":72,"reference":"Uses SFTP to write data to a single file.","result":"Write data to a file.","score":[0.239,0.5628]}
{"code":"# is used to<extra_id_0>\r\ndef distance(other)\r\n\t\t\tunless other.is_a? Point\r\n\t\t\t\traise ArgumentError.new 'other must be a Point.'\r\n\t\t\tend\r\n\t\t\tdlng = GpsUtils::to_radians(other.lng - @lng)\r\n\t\t\tdlat = GpsUtils::to_radians(other.lat - @lat)\r\n\t\t\tx = dlng * Math.cos(dlat \/ 2)\r\n\t\t\ty = GpsUtils::to_radians(other.lat - @lat)\r\n\t\t\tMath.sqrt(x**2 + y**2) * GpsUtils::R\r\n\t\tend","code-length":159,"reference":"Measure the distance between this point and another.","result":"Calculate the distance between two points.","score":[0.2849,0.3775]}
{"code":"# is used to<extra_id_0>\r\ndef cover?(point)\r\n\t\t\tp = [point.lat - @nw.lat, point.lng - @se.lng]\r\n\t\t\tp21x = p[0] * @p21\r\n\t\t\tp41x = p[1] * @p41\r\n\t\t\t0 < p21x and p21x < @p21ms and 0 <= p41x and p41x <= @p41ms\r\n\t\tend","code-length":111,"reference":"Initialize BoundingBox.","result":"Determine if the point is in the cover.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef send(method, *args, &block)\r\n      if respond_to?(method)\r\n        super\r\n      else\r\n        subject.send(method, *args, &block)\r\n      end\r\n    end","code-length":62,"reference":"for will paginate support","result":"Call the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef output(elapsed)\r\n      case @result\r\n      when MATCH_SUCCESS\r\n        color = :green\r\n        header = 'OK'\r\n      when MATCH_FAILURE\r\n        color = :red\r\n        header = 'FAIL'\r\n      when MATCH_WARNING\r\n        color = :light_red\r\n        header = 'WARN'\r\n      end\r\n      header = header.ljust(12).colorize(color)\r\n      str_elapsed = \"#{elapsed.round(2)}s\"\r\n      name = @name.to_s[0..17]\r\n      puts \"#{header}   #{name.ljust(20)}   #{str_elapsed.ljust(9)} #{@message}\"\r\n    end","code-length":175,"reference":"Called to output the result to the console.","result":"Print the message.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef get_userinfo(user)\r\n      p = {}\r\n      ids = []\r\n      names = []\r\n      if user.is_a?(Array)\r\n        user.each do |u|\r\n          names << u if u.is_a?(String)\r\n          id << u if u.is_a?(Integer)\r\n        end\r\n      elsif user.is_a?(String)\r\n        names << user\r\n      elsif user.is_a?(Integer)\r\n        ids << user\r\n      else\r\n        raise ArgumentError, format('Unknown type of arguments: %s', user.class)\r\n      end\r\n      result = get('ids' => ids, 'names' => names)\r\n      result['users']\r\n    end","code-length":188,"reference":"def session rdoc","result":"Get user info.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef options &block\r\n      options = Options.new\r\n      options.instance_eval(&block)\r\n      @options = options.to_hash\r\n    end","code-length":48,"reference":"define a DSL for options any string is processed as an option and it ends up in the ","result":"Define the options.","score":[0.0028,0.0606]}
{"code":"# is used to<extra_id_0>\r\ndef column name, &block\r\n      column = Column.new\r\n      column.instance_eval(&block)\r\n      @colspec << column.to_hash.merge({name: name})\r\n    end","code-length":58,"reference":"define a DSL for column specification - `name` is the name of the column - `block` contains two declarations, `process` and `check`, which are   used, respectively, to make a cell into the desired data and to check   whether the desired data is ok","result":"Define columns.","score":[0,0.0129]}
{"code":"# is used to<extra_id_0>\r\ndef bulk_declare hash, &block \r\n      hash.keys.each do |key|\r\n        column = Column.new\r\n        column.colref hash[key]\r\n        if block\r\n          column.instance_eval(&block)\r\n        end\r\n        @colspec << column.to_hash.merge({name: key})\r\n      end\r\n    end","code-length":96,"reference":"bulk declare columns we intend to read   colref 'B' end   colref 'C' end   process do |cell|     cell.strip   end end   colref 'B'   process do |cell|     cell.strip   end end   colref 'C'   process do |cell|     cell.strip   end end","result":"Bulk declare columns.","score":[0.0,0.059]}
{"code":"# is used to<extra_id_0>\r\ndef read args = {}\r\n      if args.class == Hash\r\n        hash = @options.merge(args)\r\n      else\r\n        puts \"dreader error at #{__callee__}: this function takes a Hash as input\"\r\n        exit\r\n      end\r\n      spreadsheet = Dreader::Engine.open_spreadsheet (hash[:filename])\r\n      sheet = spreadsheet.sheet(hash[:sheet] || 0)\r\n      @table = Array.new\r\n      @errors = Array.new\r\n      first_row = hash[:first_row] || 1\r\n      last_row = hash[:last_row] || sheet.last_row\r\n      (first_row..last_row).each do |row_number|\r\n        r = Hash.new\r\n        @colspec.each_with_index do |colspec, index|\r\n          cell = sheet.cell(row_number, colspec[:colref])\r\n                    colname = colspec[:name]\r\n          r[colname] = Hash.new\r\n          r[colname][:row_number] = row_number\r\n          r[colname][:col_number] = colspec[:colref]\r\n          begin\r\n            r[colname][:value] = value = colspec[:process] ? colspec[:process].call(cell) : cell\r\n          rescue => e\r\n            puts \"dreader error at #{__callee__}: 'process' specification for :#{colname} raised an exception at row #{row_number} (col #{index + 1}, value: #{cell})\"\r\n            raise e\r\n          end\r\n          begin\r\n            if colspec[:check] and not colspec[:check].call(value) then\r\n              r[colname][:error] = true\r\n              @errors << \"dreader error at #{__callee__}: value \\\"#{cell}\\\" for #{colname} at row #{row_number} (col #{index + 1}) does not pass the check function\"\r\n            else\r\n              r[colname][:error] = false\r\n            end\r\n          rescue => e\r\n            puts \"dreader error at #{__callee__}: 'check' specification for :#{colname} raised an exception at row #{row_number} (col #{index + 1}, value: #{cell})\"\r\n            raise e\r\n          end\r\n        end\r\n        @table << r\r\n      end\r\n      @table\r\n    end","code-length":571,"reference":"read a file and store it internally ","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef backtrace_lineno_for_config(file_path, exception)\r\n      if exception.kind_of? SyntaxError\r\n        if m = \/:(\\d+):\/.match(exception.message)\r\n          return m[1].to_i\r\n        end\r\n      end\r\n      if (exception.respond_to?(:backtrace_locations) &&\r\n          exception.backtrace_locations &&\r\n          exception.backtrace_locations.length > 0)\r\n        location = exception.backtrace_locations.find do |bt|\r\n          bt.path == file_path\r\n        end\r\n        return location ? location.lineno : nil\r\n      else\r\n        exception.backtrace.each do |line|\r\n          if line.start_with?(file_path)\r\n            if m = \/\\A.*\\:(\\d+)\\:in\/.match(line)\r\n              return m[1].to_i\r\n              break\r\n            end\r\n          end\r\n        end\r\n        return nil\r\n      end\r\n    end","code-length":246,"reference":"Provide a config source file path, and an exception.","result":"Determine the line number of the exception.","score":[0.1214,0.0568]}
{"code":"# is used to<extra_id_0>\r\ndef backtrace_from_config(file_path, exception)\r\n      filtered_trace = []\r\n      found          = false\r\n      if (exception.respond_to?(:backtrace_locations) &&\r\n          exception.backtrace_locations &&\r\n          exception.backtrace_locations.length > 0)\r\n        exception.backtrace_locations.each do |location|\r\n          filtered_trace << location\r\n          (found=true and break) if location.path == file_path\r\n        end\r\n      else\r\n        filtered_trace = []\r\n        exception.backtrace.each do |line|\r\n          filtered_trace << line\r\n          (found=true and break) if line.start_with?(file_path)\r\n        end\r\n      end\r\n      return found ? filtered_trace : []\r\n    end","code-length":197,"reference":"Extract just the part of the backtrace that is \"below\" the config file mentioned.","result":"Get the backtrace from the config file.","score":[0.1106,0.282]}
{"code":"# is used to<extra_id_0>\r\ndef drain_queue(queue)\r\n      result = []\r\n      queue_size = queue.size\r\n      begin\r\n        queue_size.times do\r\n          result << queue.deq(:raise_if_empty)\r\n        end\r\n      rescue ThreadError\r\n      end\r\n      return result\r\n    end","code-length":84,"reference":"Ruby stdlib queue lacks a 'drain' function, we write one.","result":"Avoid deadlocks.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get_hash(params = {}, sorted = true)\r\n      get_nodes(sorted).map{|n| n.to_hash(params[n.name])}\r\n    end","code-length":52,"reference":"Return all nodes in order as an hashalways_use","result":"Generate the hash.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef get_sentence(params = {}, sorted = true, separator = ' ')\r\n      build_sentence_from_hash(get_hash(params, sorted)).select(&:present?).join(separator)\r\n    end","code-length":60,"reference":"Returns the string representation of nodes and blocks by updating with given parameters","result":"Build the sentence.","score":[0.0146,0.0417]}
{"code":"# is used to<extra_id_0>\r\ndef get_nodes(sorted = true)\r\n      SentenceBuilder::Helper.to_boolean(sorted) ? @nodes.sort_by{|i| i.sort_by_value} : @nodes\r\n    end","code-length":58,"reference":"Return nodes by sorting option","result":"Build the nodes.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef build_sentence_from_hash(nodes)\r\n      result = []\r\n      nodes.each do |node|\r\n        if node[:current_value].nil?\r\n          if node[:always_use]\r\n            result << node[:sentence]\r\n          end\r\n        else\r\n          result << node[:sentence]\r\n        end\r\n      end\r\n      result\r\n    end","code-length":100,"reference":"By parsing each node's hash, create a sentence","result":"Build a sentence from a hash.","score":[0.1956,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef read_pages\r\n      sql = \"SELECT id, tag, body, time, latest, user, note FROM wikka_pages ORDER BY time;\"\r\n      results = database.query(sql)\r\n      results.each do |row|\r\n        titles << row[\"tag\"]\r\n        author = authors[row[\"user\"]]\r\n        page = Page.new({:id => row[\"id\"],\r\n                            :title =>   row[\"tag\"],\r\n                            :body =>    row[\"body\"],\r\n                            :markup =>  :wikka,\r\n                            :latest =>  row[\"latest\"] == \"Y\",\r\n                            :time =>    row[\"time\"],\r\n                            :message => row[\"note\"],\r\n                            :author =>  author,\r\n                            :author_name => row[\"user\"]})\r\n        revisions << page\r\n      end\r\n      titles.uniq!\r\n      revisions\r\n    end","code-length":222,"reference":"after calling this action, I expect the titles and ","result":"Read pages from the database.","score":[0.108,0.0581]}
{"code":"# is used to<extra_id_0>\r\ndef filter(params)\r\n      results = where(nil)\r\n      params.each do |key, value|\r\n        results = results.public_send(key, value) if value.present?\r\n      end\r\n      results\r\n    end","code-length":67,"reference":"Iterates over params hash and applies non-empty values as filters ","result":"Filter the query.","score":[0,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef sites\r\n      response = conn.get(\"#{base_url}\/site\", {}, query_headers)            \r\n      body = JSON.parse(response.body)\r\n      body.map { |b| Site.new(b) } \r\n    rescue JSON::ParserError\r\n      fail QueryError, \"Query Failed! HTTPStatus: #{response.status} - Response: #{body}\"\r\n    end","code-length":100,"reference":"Gets a list of all the sites for the company","result":"Define the method sites.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef site_query(*args)\r\n      response = conn.get(url_picker(*args), {}, query_headers)\r\n      if response.body['SiteId'] || response.body['PointId']\r\n        JSON.parse(response.body)\r\n      else\r\n        fail QueryError, \"Query Failed! HTTPStatus: #{response.status}\"\r\n      end\r\n    end","code-length":97,"reference":"Returns site attributes and history data if an optional query_hash is supplied","result":"Query the points.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef rate_time\r\n      regexp = Regexp.new(currency_code)\r\n      page.search(\"\/\/span[@name='pair']\").each do |td|\r\n        if regexp.match(td.content)\r\n          hour = td.next_element.next_element.content\r\n          return DateTime.parse(hour)\r\n        end\r\n      end\r\n    end","code-length":96,"reference":"The hour of the rate","result":"Calculate the rate time.","score":[0.3519,0.3827]}
{"code":"# is used to<extra_id_0>\r\ndef outfile= f\r\n      io = f.kind_of?(IO) ? f : File.new(f, \"w\")\r\n      @writer.output = io\r\n    end","code-length":52,"reference":"closing it.","result":"Set the output file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef log msg = \"\", obj = nil, level: Level::DEBUG, classname: nil, &blk\r\n      log_frames msg, obj, classname: classname, level: level, nframes: 0, &blk\r\n    end","code-length":61,"reference":"Logs the given message.","result":"Log to the console.","score":[0.3195,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef options\r\n      option_hash = {}\r\n      my_labels = option_names\r\n      my_inputs = option_fields\r\n      my_labels.count.times do |index|\r\n        option_hash[my_labels[index]] = my_inputs[index]\r\n      end\r\n      option_hash\r\n    end","code-length":87,"reference":"Returns all available options fields and their respective label as a Hash.","result":"Define the options.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef selected_options\r\n      selected = []\r\n      my_labels = option_names\r\n      inputs.each_with_index do |field, index|\r\n        selected << my_labels[index] if field.checked?\r\n      end\r\n      selected\r\n    end","code-length":73,"reference":"Returns the selected options of this OptionGroup.","result":"Determine which options are selected.","score":[0.1611,0.0735]}
{"code":"# is used to<extra_id_0>\r\ndef transmit_packet(packet, options={})\r\n      options = {\r\n        cache: false\r\n      }.merge(options)\r\n      packet = packet.as_json.deep_symbolize_keys\r\n      if validate_packet(packet, options)\r\n        if options[:cache]==true\r\n          if update_cache(packet)\r\n            transmit packet\r\n          end\r\n        else\r\n          transmit packet\r\n        end\r\n      end\r\n    end","code-length":119,"reference":"Transmits packets to connected client ","result":"Send packets to the server.","score":[0.3398,0.5889]}
{"code":"# is used to<extra_id_0>\r\ndef strict_ancestor_of?(block_start)\r\n      block_start && block_start.parent && (self == block_start.parent || strict_ancestor_of?(block_start.parent))\r\n    end","code-length":60,"reference":"Returns true if strict ancestor of","result":"Determine if a block starts with a strict ancestor.","score":[0.1449,0.1587]}
{"code":"# is used to<extra_id_0>\r\ndef built_in_object_ids\r\n      @built_in_object_ids ||= Hash.new do |hash, key|\r\n        hash[key] = where(built_in_key: key).pluck(:id).first\r\n      end\r\n    end","code-length":70,"reference":"memoized hash of built in object ids","result":"Store object ids.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef daemonize(safe = true)\r\n      $stdin.reopen '\/dev\/null'\r\n      exit if fork\r\n      Process.setsid\r\n      exit if fork\r\n      unless safe\r\n        ::Dir.chdir('\/')\r\n        ::File.umask(0000)\r\n      end\r\n      cfg_defaults = Clacks::Configurator::DEFAULTS\r\n      cfg_defaults[:stdout_path] ||= \"\/dev\/null\"\r\n      cfg_defaults[:stderr_path] ||= \"\/dev\/null\"\r\n    end","code-length":132,"reference":"See Stevens's \"Advanced Programming in the UNIX Environment\" chapter 13","result":"Daemonize the process.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef reopen_io(io, path)\r\n      io.reopen(::File.open(path, \"ab\")) if path\r\n      io.sync = true\r\n    end","code-length":51,"reference":"Redirect file descriptors inherited from the parent.","result":"Close the file.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef running?(path)\r\n      wpid = ::File.read(path).to_i\r\n      return if wpid <= 0\r\n      Process.kill(0, wpid)\r\n      wpid\r\n    rescue Errno::EPERM, Errno::ESRCH, Errno::ENOENT\r\n    end","code-length":82,"reference":"Read the working pid from the pid file.","result":"Check if the given path is running.","score":[0.14,0.0633]}
{"code":"# is used to<extra_id_0>\r\ndef write_pid(pid)\r\n      ::File.open(pid, 'w') { |f| f.write(\"#{Process.pid}\") }\r\n      at_exit { ::File.delete(pid) if ::File.exist?(pid) rescue nil }\r\n    end","code-length":74,"reference":"Write the pid.","result":"Write the pid file.","score":[0.4518,0.6048]}
{"code":"# is used to<extra_id_0>\r\ndef parse_mead(*args)\r\n      parts = @mead.split('-')\r\n      args.each_with_index do |field, i|\r\n        instance_variable_set('@' + field, parts[i])\r\n      end\r\n    end","code-length":71,"reference":"If a location is given then extraction can take place","result":"Parse the mead.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef load(*file_names)\r\n            file_names.flatten.each do |file_name|\r\n                xml = File.open(file_name, 'r') do |file|\r\n                    Nokogiri::XML(file) do |config|\r\n                        if @pretty then\r\n                            config.default_xml.noblanks\r\n                        end\r\n                    end\r\n                end\r\n                @documents << Document.new(file_name, xml)\r\n            end\r\n        end","code-length":124,"reference":"Intialize a new mixml tool","result":"Load documents.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef save_all\r\n            output_all do |document, options|\r\n                File.open(document.name, 'w') do |file|\r\n                    document.xml.write_xml_to(file, options)\r\n                end\r\n            end\r\n        end","code-length":72,"reference":"Save all loaded XML files ","result":"Save the document to a file.","score":[0.193,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef print_all\r\n            output_all do |document, options|\r\n                if @documents.size > 1 then\r\n                    puts '-' * document.name.length\r\n                    puts document.name\r\n                    puts '-' * document.name.length\r\n                end\r\n                puts document.xml.to_xml(options)\r\n            end\r\n        end","code-length":91,"reference":"Print all loaded XML files is printed before each file.","result":"Print all documents.","score":[0.056,0.2016]}
{"code":"# is used to<extra_id_0>\r\ndef work(*file_names, &block)\r\n            remove_all\r\n            file_names.each do |file_name|\r\n                load(file_name)\r\n                if not block.nil? then\r\n                    execute(&block)\r\n                end\r\n                flush\r\n                remove_all\r\n            end\r\n        end","code-length":88,"reference":"Perform work on a list of XML files ","result":"Remove_all.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef xpath(*paths, &block)\r\n            nodesets = []\r\n            process do |xml|\r\n                nodesets << xml.xpath(*paths)\r\n            end\r\n            selection = Selection.new(nodesets)\r\n            if block_given? then\r\n                Docile.dsl_eval(selection, &block)\r\n            end\r\n            selection\r\n        end","code-length":96,"reference":"Select nodes using an XPath expression and execute DSL commands for these nodes ","result":"Define xpath.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef css(*selectors, &block)\r\n            nodesets = []\r\n            process do |xml|\r\n                nodesets << xml.css(*selectors)\r\n            end\r\n            selection = Selection.new(nodesets)\r\n            if block_given? then\r\n                Docile.dsl_eval(selection, &block)\r\n            end\r\n            selection\r\n        end","code-length":96,"reference":"Select nodes using CSS selectors and execute DSL commands for these nodes ","result":"Define CSS selectors.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef execute(program = nil, &block)\r\n            if not program.nil? then\r\n                instance_eval(program)\r\n            end\r\n            if not block.nil? then\r\n                Docile.dsl_eval(self, &block)\r\n            end\r\n        end","code-length":75,"reference":"Execute a script or a block ","result":"Execute the program.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef with_nodes(selection)\r\n            selection.nodesets.each do |nodeset|\r\n                nodeset.each do |node|\r\n                    yield node\r\n                end\r\n            end\r\n        end","code-length":58,"reference":"Execute block for each node ","result":"Replace the code.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef tagify input\r\n      output = input.dup\r\n      raise StandardError, \"@tags is empty!\" if @tags.empty?\r\n      @tags.each {|key,value| output.gsub!(tag_start.to_s+key.to_s+tag_end.to_s, value.to_s)}\r\n      return output\r\n    end","code-length":94,"reference":"Tagifies the supplied input.","result":"Tagify the input.","score":[0.3479,0.6553]}
{"code":"# is used to<extra_id_0>\r\ndef option_group(*args)\r\n      selector = if args.first.respond_to?(:elements)\r\n                   args.first\r\n                 else\r\n                   extract_selector(args)\r\n                 end\r\n      OptionGroup.new(self, selector)\r\n    end","code-length":72,"reference":"Returns an OptionGroup ","result":"Create a option group.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef execute(args)\r\n      target_file = @config_file.nil? ? \"caramel.rb\" : @config_file\r\n      FileUtils.cp(File.dirname(__FILE__) +\"\/..\/caramel.rb\", target_file)\r\n      if commandparser.verbosity == :normal\r\n        puts \"Created new configuration file: #{target_file}\"\r\n      end\r\n    end","code-length":105,"reference":"Create a caramelize config file.","result":"Execute the command.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef has_machete_workflow_of(jobs_active_record_relation_symbol)\r\n      cattr_accessor :jobs_active_record_relation_symbol\r\n      self.jobs_active_record_relation_symbol = jobs_active_record_relation_symbol\r\n      self.send :include, OscMacheteRails::Workflow::JobsRelation\r\n      self.send :include, OscMacheteRails::Workflow::BuilderMethods\r\n      self.send :include, OscMacheteRails::Workflow::StatusMethods\r\n    end","code-length":139,"reference":"Registers a workflow relationship and sets up a hook to additional builder methods.","result":"Determine if the job has machete workflow.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef check_retry\r\n      if @finished_publishing && @pending_hash.empty? && @exception_count > 0 && (@retry || @auto_retry)\r\n        return if !@retry && @auto_retry && @exception_count == @exceptions_per_run.last\r\n        Qwirk.logger.info \"#{self}: Retrying exception records, exception count = #{@exception_count}\"\r\n        @exceptions_per_run << @exception_count\r\n        @exception_count = 0\r\n        @finished_publishing = false\r\n        @fail_thread = Thread.new(@exceptions_per_run.last) do |count|\r\n          begin\r\n            java.lang.Thread.current_thread.name = \"Qwirk fail task: #{task_id}\"\r\n            while !@stopped && (count > 0) && (object = @fail_consumer.receive)\r\n              count -= 1\r\n              publish(object)\r\n              @fail_consumer.acknowledge_message\r\n            end\r\n            @finished_publishing = true\r\n            @pending_hash_mutex.synchronize { check_finish }\r\n          rescue Exception => e\r\n            do_stop\r\n            Qwirk.logger.error \"#{self}: Exception, thread terminating: #{e.message}\\n\\t#{e.backtrace.join(\"\\n\\t\")}\"\r\n          end\r\n        end\r\n      end\r\n    end","code-length":339,"reference":"Must be called within a mutex synchronize","result":"Check if the task is finished.","score":[0,0.0725]}
{"code":"# is used to<extra_id_0>\r\ndef run\r\n            program :name, 'mixml'\r\n            program :version, Mixml::VERSION\r\n            program :description, 'XML helper tool'\r\n            $tool = Mixml::Tool.new\r\n            global_option('-p', '--pretty', 'Pretty print output') do |value|\r\n                $tool.pretty = value\r\n            end\r\n            global_option('-i', '--inplace', 'Replace the processed files with the new files') do |value|\r\n                $tool.save = value\r\n                $tool.print = !value\r\n            end\r\n            global_option('-q', '--quiet', 'Do not print nodes') do |value|\r\n                $tool.print = !value\r\n            end\r\n            command :pretty do |c|\r\n                c.description = 'Pretty print XML files'\r\n                c.action do |args, options|\r\n                    $tool.pretty = true\r\n                    $tool.work(args)\r\n                end\r\n            end\r\n            modify_command :write do |c|\r\n                c.description = 'Write selected nodes to the console'\r\n                c.suppress_output = true\r\n                c.optional_expression = true\r\n            end\r\n            select_command :remove do |c|\r\n                c.description = 'Remove nodes from the XML documents'\r\n            end\r\n            modify_command :replace do |c|\r\n                c.description = 'Replace nodes in the XML documents'\r\n            end\r\n            modify_command :append do |c|\r\n                c.description = 'Append child nodes in the XML documents'\r\n            end\r\n            modify_command :rename do |c|\r\n                c.description = 'Rename nodes in the XML documents'\r\n            end\r\n            modify_command :value do |c|\r\n                c.description = 'Set node values'\r\n            end\r\n            command :execute do |c|\r\n                c.description = 'Execute script on the XML documents'\r\n                c.option '-s', '--script STRING', String, 'Script file to execute'\r\n                c.option '-e', '--expression STRING', String, 'Command to execute'\r\n                c.action do |args, options|\r\n                    script = options.expression || File.read(options.script)\r\n                    $tool.work(args) do\r\n                        execute(script)\r\n                    end\r\n                end\r\n            end\r\n            run!\r\n        end","code-length":580,"reference":"Run the mixml command","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef list entities = @db.list\r\n      out\r\n      entities = entities.is_a?(Fixnum) ? @db.list[0...entities] : entities\r\n      entities.reject {|e| e[:status] == :removed }.each_with_index do |e, i|\r\n        out \" [#{i}]\".blue                     +\r\n            \"#{e.sticky?? \" + \".bold : \"   \"}\" +\r\n            e[:title].underline                +\r\n            \" #{e[:tags].join(' ')}\".cyan\r\n      end.tap do |list|\r\n        out \" ...\" if @db.list.length > entities.length && !entities.length.zero?\r\n        out \"  there are no koi in the water\".green if list.size.zero?\r\n      end\r\n      out\r\n      entities\r\n    end","code-length":209,"reference":"List current tasks","result":"Display the list of all the entities.","score":[0,0.1471]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing meth, *args, &blk\r\n      if meth.to_s.end_with?('?') && Status.include?(s = meth.to_s.chop.to_sym)\r\n        self[:status] == s\r\n      else\r\n        super\r\n      end\r\n    end","code-length":84,"reference":"Handle things like `self.removed?`","result":"Define methods.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef v3_get(path, options = {})\r\n      get_params = {\r\n        :method => \"get\"\r\n      }\r\n      get_params[:params] = options unless options.empty?\r\n      v3_do_request(get_params, path, :cache => true)\r\n    end","code-length":83,"reference":"Perform a GET request options hash should contain query parameters","result":"Get a resource.","score":[0.0396,0.1075]}
{"code":"# is used to<extra_id_0>\r\ndef v3_put(path, options = {})\r\n      expire_matching \"#{parent_path(path)}.*\"\r\n      put_params = { \r\n        :method => \"put\",\r\n        :body => options[:body] ? options[:body] : form_encode(options)\r\n      }\r\n      if options[:content_type]\r\n        put_params[:headers] = {\r\n          :'Content-Type' => content_type(options[:content_type])\r\n        }\r\n      end\r\n      v3_do_request(put_params, path)\r\n    end","code-length":147,"reference":"Perform a PUT request options hash should contain request body parameters","result":"Put a resource.","score":[0.0284,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef v3_do_request(params, path, options = {})\r\n      req = Typhoeus::Request.new(\"https:\/\/#{v3_hostname}#{path}\", v3_defaults.merge(params))\r\n      response = do_request(req, :xml, options)\r\n      options[:return_obj]==true ? response : response.body\r\n    end","code-length":97,"reference":"Wrap up parameters into a request and execute it","result":"Create a request.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef add(token, timestamp = nil)\r\n      @net.call_callbacks(:place, :add, Event.new(@name, [token], @net)) unless @net.nil?\r\n      if timestamp.nil?\r\n        @marking.add token\r\n      else\r\n        @marking.add token, timestamp\r\n      end\r\n    end","code-length":91,"reference":"Adds token with specified timestamp to the place.","result":"Add events to the place.","score":[0.2716,0.487]}
{"code":"# is used to<extra_id_0>\r\ndef authorize\r\n      client_id = Google::Auth::ClientId.from_file(CLIENT_SECRETS_PATH)\r\n      token_store = Google::Auth::Stores::FileTokenStore.new(file: CREDENTIALS_PATH)\r\n      authorizer = Google::Auth::UserAuthorizer.new(client_id, SCOPE, token_store)\r\n      user_id = 'default'\r\n      credentials = authorizer.get_credentials(user_id)\r\n      if credentials.nil?\r\n        url = authorizer.get_authorization_url(base_url: OOB_URI)\r\n        puts 'Open the following URL in the browser and enter the ' \\\r\n          \"resulting code after authorization:\\n\" + url\r\n        code = STDIN.gets\r\n        credentials = authorizer.get_and_store_credentials_from_code(\r\n          user_id: user_id, code: code, base_url: OOB_URI\r\n        )\r\n      end\r\n      credentials\r\n    end","code-length":241,"reference":"Ensure valid credentials, either by restoring from the saved credentials files or intitiating an OAuth2 authorization.","result":"Authorize the user.","score":[0.0054,0.034]}
{"code":"# is used to<extra_id_0>\r\ndef get(path, data = {})\r\n      format = data.delete(:format) || @format\r\n      get_params = {\r\n        :method => \"get\", \r\n        :verbose => DEBUG\r\n      }\r\n      get_params[:params] = data unless data.empty?\r\n      get = Typhoeus::Request.new(\"#{protocol}#{@server}#{path}\", get_params)\r\n      do_request(get, format, :cache => true)\r\n    end","code-length":124,"reference":"GET data from the API, passing in a hash of parameters","result":"Get a resource.","score":[0.0284,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef post(path, data = {})\r\n      format = data.delete(:format) || @format\r\n      expire_matching \"#{raw_path(path)}.*\"\r\n      query_params = {}\r\n      query_params[:returnUnit] = data.delete(:returnUnit) if data[:returnUnit]\r\n      query_params[:returnPerUnit] = data.delete(:returnPerUnit) if data[:returnPerUnit]\r\n      post_params = {\r\n        :verbose => DEBUG,\r\n        :method => \"post\",\r\n        :body => form_encode(data)\r\n      }\r\n      post_params[:params] = query_params unless query_params.empty?\r\n      post = Typhoeus::Request.new(\"#{protocol}#{@server}#{path}\", post_params)\r\n      do_request(post, format)      \r\n    end","code-length":211,"reference":"POST to the AMEE API, passing in a hash of values","result":"Create a new request.","score":[0.0555,0.0485]}
{"code":"# is used to<extra_id_0>\r\ndef raw_post(path, body, options = {})\r\n      format = options.delete(:format) || @format\r\n      expire_matching \"#{raw_path(path)}.*\"\r\n      post = Typhoeus::Request.new(\"#{protocol}#{@server}#{path}\", \r\n        :verbose => DEBUG,\r\n        :method => \"post\",\r\n        :body => body,\r\n        :headers => { :'Content-type' => options[:content_type] || content_type(format)  }\r\n      )\r\n      do_request(post, format)\r\n    end","code-length":147,"reference":"POST to the AMEE API, passing in a string of data","result":"Store the raw post data.","score":[0.0724,0.0962]}
{"code":"# is used to<extra_id_0>\r\ndef put(path, data = {})\r\n      format = data.delete(:format) || @format\r\n      expire_matching \"#{parent_path(path)}.*\"\r\n      query_params = {}\r\n      query_params[:returnUnit] = data.delete(:returnUnit) if data[:returnUnit]\r\n      query_params[:returnPerUnit] = data.delete(:returnPerUnit) if data[:returnPerUnit]\r\n      put_params = {\r\n        :verbose => DEBUG,\r\n        :method => \"put\",\r\n        :body => form_encode(data)\r\n      }\r\n      put_params[:params] = query_params unless query_params.empty?\r\n      put = Typhoeus::Request.new(\"#{protocol}#{@server}#{path}\", put_params)\r\n      do_request(put, format)\r\n    end","code-length":210,"reference":"PUT to the AMEE API, passing in a hash of data","result":"Update the cache.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef raw_put(path, body, options = {})\r\n      format = options.delete(:format) || @format\r\n      expire_matching \"#{parent_path(path)}.*\"\r\n      put = Typhoeus::Request.new(\"#{protocol}#{@server}#{path}\", \r\n        :verbose => DEBUG,\r\n        :method => \"put\",\r\n        :body => body,\r\n        :headers => { :'Content-type' => options[:content_type] || content_type(format)  }\r\n      )\r\n      do_request(put, format)\r\n    end","code-length":147,"reference":"PUT to the AMEE API, passing in a string of data","result":"Perform the PUT request.","score":[0.066,0.0971]}
{"code":"# is used to<extra_id_0>\r\ndef authenticate\r\n      request = Typhoeus::Request.new(\"#{protocol}#{@server}\/auth\/signIn\", \r\n        :method => \"post\",\r\n        :verbose => DEBUG,\r\n        :headers => {\r\n          :Accept => content_type(:xml),\r\n        },\r\n        :body => form_encode(:username=>@username, :password=>@password)\r\n      )\r\n      hydra.queue(request)\r\n      hydra.run\r\n      response = request.response\r\n      @auth_token = response.headers_hash['AuthToken']\r\n      d {request.url}\r\n      d {response.code}\r\n      d {@auth_token}\r\n      connection_failed if response.code == 0\r\n      unless authenticated?\r\n        raise AMEE::AuthFailed.new(\"Authentication failed. Please check your username and password. (tried #{@username},#{@password})\")\r\n      end\r\n      if response.body.is_json?\r\n        @version = JSON.parse(response.body)[\"user\"][\"apiVersion\"].to_f\r\n      elsif response.body.is_xml?\r\n        @version = REXML::Document.new(response.body).elements['Resources'].elements['SignInResource'].elements['User'].elements['ApiVersion'].text.to_f\r\n      else\r\n        @version = 1.0\r\n      end\r\n    end","code-length":337,"reference":"Post to the sign in resource on the API, so that all future requests are signed","result":"Authenticate the user.","score":[0.0054,0.034]}
{"code":"# is used to<extra_id_0>\r\ndef response_ok?(response, request)\r\n            d {request.object_id}\r\n      d {request}\r\n      d {response.object_id}\r\n      d {response.code}\r\n      d {response.headers_hash}\r\n      d {response.body}\r\n      case response.code.to_i\r\n      when 502, 503, 504\r\n          raise AMEE::ConnectionFailed.new(\"A connection error occurred while talking to AMEE: HTTP response code #{response.code}.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}\")\r\n      when 408\r\n        raise AMEE::TimeOut.new(\"Request timed out.\")\r\n      when 404\r\n        raise AMEE::NotFound.new(\"The URL was not found on the server.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}\")\r\n      when 403\r\n        raise AMEE::PermissionDenied.new(\"You do not have permission to perform the requested operation.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}\\n#{request.body}\\Response: #{response.body}\")\r\n      when 401\r\n        authenticate\r\n        return false\r\n      when 400\r\n        if response.body.include? \"would have resulted in a duplicate resource being created\"\r\n          raise AMEE::DuplicateResource.new(\"The specified resource already exists. This is most often caused by creating an item that overlaps another in time.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}\\n#{request.body}\\Response: #{response.body}\")\r\n        else\r\n          raise AMEE::BadRequest.new(\"Bad request. This is probably due to malformed input data.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}\\n#{request.body}\\Response: #{response.body}\")\r\n        end\r\n      when 200, 201, 204\r\n        return response\r\n      when 0\r\n        connection_failed\r\n      end\r\n      raise AMEE::UnknownError.new(\"An error occurred while talking to AMEE: HTTP response code #{response.code}.\\nRequest: #{request.method.upcase} #{request.url}\\n#{request.body}\\Response: #{response.body}\")\r\n    end","code-length":585,"reference":"run each request through some basic error checking, and if needed log requests","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef do_request(request, format = @format, options = {})\r\n      v3_request = request.url.include?(\"\/#{v3_hostname}\/\")\r\n      if !@auth_token && !v3_request\r\n        d \"Authenticating first before we hit #{request.url}\"\r\n        authenticate \r\n      end\r\n      request.headers['Accept'] = content_type(format)\r\n      request.headers['X-AMEE-Source'] = @amee_source if @amee_source\r\n      path_and_query = '\/' + request.url.split('\/', 4)[3]\r\n      if options[:cache]\r\n        response = cache(path_and_query) { run_request(request, :xml) }\r\n      else\r\n        response = run_request(request, :xml)\r\n      end\r\n      response\r\n    end","code-length":214,"reference":"Wrapper for sending requests through to the API.","result":"Handle the request.","score":[0.0771,0.0667]}
{"code":"# is used to<extra_id_0>\r\ndef run_request(request, format)\r\n      v3_request = request.url.include?(\"\/#{v3_hostname}\/\")\r\n      retries = [1] * @retries\r\n      begin \r\n        begin\r\n          d \"Queuing the request for #{request.url}\"\r\n          add_authentication_to(request) if @auth_token && !v3_request\r\n          hydra.queue request\r\n          hydra.run\r\n        end while !response_ok?(request.response, request)\r\n        @auth_token = request.response.headers_hash['AuthToken']\r\n        return request.response\r\n      rescue AMEE::ConnectionFailed, AMEE::TimeOut => e\r\n        if delay = retries.shift\r\n          sleep delay\r\n          retry\r\n        else\r\n          raise\r\n        end\r\n      end\r\n    end","code-length":210,"reference":"run request.","result":"Run the request.","score":[0.4082,0.4762]}
{"code":"# is used to<extra_id_0>\r\ndef timed_place(name, keys = {})\r\n      place = create_or_find_place(name, keys, TimedPlace)\r\n      @timed_places[place] = true\r\n      place\r\n    end","code-length":60,"reference":"Create and return a new timed place for this model.","result":"Create a timed place.","score":[0.0938,0.1596]}
{"code":"# is used to<extra_id_0>\r\ndef transition(name)\r\n      t = find_transition name\r\n      if t.nil?\r\n        t = Transition.new name, self\r\n        @transitions << t\r\n      end\r\n      t\r\n    end","code-length":61,"reference":"Create and return new transition for this model.","result":"Define the transition.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef sim\r\n      @stopped = catch :stop_simulation do\r\n        begin\r\n          fired = fire_transitions\r\n          advanced = move_clock_to find_next_time\r\n        end while fired || advanced\r\n      end\r\n      @stopped = false if @stopped == nil\r\n    rescue StandardError => e\r\n      raise SimulationError.new(e)\r\n    end","code-length":98,"reference":"Starts simulation of this net.","result":"Simulate the simulation.","score":[0,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef output(place, &block)\r\n      raise \"This is not a Place object!\" unless place.kind_of? Place\r\n      raise \"Tried to define output arc without expression! Block is required!\" unless block_given?\r\n      @outputs << OutputArc.new(place, block)\r\n    end","code-length":78,"reference":"Add output arc to the +place+.","result":"Define output arcs.","score":[0.1502,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef fire(clock = 0)\r\n      mapping = Enumerator.new do |y|\r\n                  get_sentry.call(input_markings, clock, y)\r\n                end.first\r\n      return false if mapping.nil?\r\n      tcpn_binding = TCPNBinding.new mapping, input_markings\r\n      call_callbacks :before, Event.new(@name, tcpn_binding, clock, @net)\r\n      tokens_for_outputs = @outputs.map do |o|\r\n        o.block.call(tcpn_binding, clock)\r\n      end\r\n      mapping.each do |place_name, token|\r\n        unless token.kind_of? Token\r\n          t = if token.instance_of? Array\r\n                token\r\n              else\r\n                [ token ]\r\n              end\r\n          t.each do |t|\r\n            unless t.kind_of? Token\r\n              raise InvalidToken.new(\"#{t.inspect} put by sentry for transition `#{name}` in binding for `#{place_name}`\")\r\n            end\r\n          end\r\n        end\r\n        deleted = find_input(place_name).delete(token)\r\n        if deleted.nil?\r\n          raise InvalidToken.new(\"#{token.inspect} put by sentry for transition `#{name}` does not exists in `#{place_name}`\")\r\n        end\r\n      end\r\n      @outputs.each do |o|\r\n        token = tokens_for_outputs.shift\r\n        o.place.add token unless token.nil?\r\n      end\r\n      call_callbacks :after, Event.new(@name, mapping, clock, @net)\r\n      true\r\n    rescue InvalidToken\r\n      raise\r\n    rescue RuntimeError => e\r\n      raise FiringError.new(self, e)\r\n    end","code-length":436,"reference":"fire this transition if possible returns true if fired false otherwise","result":"Fire the event.","score":[0,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef send_request(text)\r\n      begin\r\n        request = Net::HTTP::Post.new(@url.path, {\r\n          'Content-Type' => 'text\/xml',\r\n          'SOAPAction' => '\"http:\/\/typograf.artlebedev.ru\/webservices\/ProcessText\"'\r\n        })\r\n        request.body = form_xml(text, @options)\r\n        response = Net::HTTP.new(@url.host, @url.port).start do |http|\r\n          http.request(request)\r\n        end\r\n      rescue StandardError => exception\r\n        raise NetworkError.new(exception.message, exception.backtrace)\r\n      end\r\n      if !response.is_a?(Net::HTTPOK)\r\n        raise NetworkError, \"#{response.code}: #{response.message}\"\r\n      end\r\n      if RESULT =~ response.body\r\n        body = $1.gsub(\/&gt;\/, '>').gsub(\/&lt;\/, '<').gsub(\/&amp;\/, '&')\r\n        body.force_encoding(\"UTF-8\").chomp\r\n      else\r\n        raise NetworkError, \"Can't match result #{response.body}\"\r\n      end\r\n    end","code-length":296,"reference":"Process text with remote web-service","result":"Send a request to the server.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef install_librarian(opts = {})\r\n      librarian_version = opts[:librarian_version] ||= nil\r\n      hosts.each do |host|\r\n        install_package host, 'rubygems'\r\n        install_package host, 'git'\r\n        if librarian_version\r\n          on host, \"gem install --no-ri --no-rdoc librarian-puppet -v '#{librarian_version}'\" \r\n        else\r\n          on host, 'gem install --no-ri --no-rdoc librarian-puppet' \r\n        end\r\n      end\r\n    end","code-length":163,"reference":"Install rubygems and the librarian-puppet gem onto each host","result":"Install librarian.","score":[0.0151,0.0602]}
{"code":"# is used to<extra_id_0>\r\ndef librarian_install_modules(directory, module_name)\r\n      hosts.each do |host|\r\n        sut_dir = File.join('\/tmp', module_name)\r\n        scp_to host, directory, sut_dir\r\n        on host, \"cd #{sut_dir} && librarian-puppet install --clean --verbose --path #{host['distmoduledir']}\"\r\n        puppet_module_install(:source => directory, :module_name => module_name)\r\n      end\r\n    end","code-length":135,"reference":"Copy the module under test to a temporary directory onto the host, and execute librarian-puppet to install dependencies into the 'distmoduledir'.","result":"Install the specified module.","score":[0.0046,0.0518]}
{"code":"# is used to<extra_id_0>\r\ndef get_crisis(identifier, params = nil)\r\n            return nil if identifier.nil? or identifier.empty?\r\n            endpoint = \"\/v1\/crises\/#{identifier}.json?auth_token=#{@auth_token}\"\r\n            endpoint += \"&#{URI.encode_www_form params}\" if params\r\n            response = self.get(endpoint)\r\n            Sigimera::Crisis.new JSON.parse response.body if response and response.body\r\n        end","code-length":117,"reference":"This method returns a single crisis.","result":"Get crisis.","score":[0.0677,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef get_crises_stat\r\n            response = self.get(\"\/v1\/stats\/crises.json?auth_token=#{@auth_token}\")\r\n            JSON.parse response.body if response and response.body\r\n        end","code-length":65,"reference":"This method returns statistic information about the crises.","result":"Get the crises stat.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef get_user_stat\r\n            response = self.get(\"\/v1\/stats\/users.json?auth_token=#{@auth_token}\")\r\n            JSON.parse response.body if response and response.body\r\n        end","code-length":63,"reference":"This method returns statistic information about user.","result":"Get user stats.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef posify *source_methods, &block\r\n      include ModelClassAdditions\r\n      self.pose_content = proc do\r\n        text_chunks = source_methods.map { |source| send(source) }\r\n        text_chunks << instance_eval(&block) if block\r\n        text_chunks.reject(&:blank?).join(' ')\r\n      end\r\n    end","code-length":100,"reference":"Defines the searchable content in ActiveRecord objects.","result":"Generate the posification.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef add(objects)\r\n      unless objects.kind_of? Array\r\n        objects = [ objects ]\r\n      end\r\n      objects.each do |object|\r\n        value = object\r\n        if object.instance_of? Hash\r\n          value = object[:val]\r\n        end\r\n        add_token prepare_token(value)\r\n      end\r\n    end","code-length":97,"reference":"Creates new token of the +object+ and adds it to the marking.","result":"Add tokens to the token list.","score":[0.1112,0.2769]}
{"code":"# is used to<extra_id_0>\r\ndef delete(tokens)\r\n      unless tokens.instance_of? Array\r\n        tokens = [ tokens ]\r\n      end\r\n      removed = tokens.map do |token|\r\n        validate_token!(token)\r\n        delete_token(token)\r\n      end\r\n      if removed.size == 1\r\n        removed.first\r\n      else\r\n        removed\r\n      end\r\n    end","code-length":103,"reference":"Deletes the +token+ from the marking.","result":"Delete tokens.","score":[0,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef add_joins arel\r\n      @query.joins.inject(arel) do |memo, join_data|\r\n        add_join memo, join_data\r\n      end\r\n    end","code-length":55,"reference":"Creates a JOIN to the given expression.","result":"Add joins to the query.","score":[0.2278,0.433]}
{"code":"# is used to<extra_id_0>\r\ndef add_wheres arel\r\n      @query.where.inject(arel) { |memo, where| memo.where where }\r\n    end","code-length":44,"reference":"Adds the WHERE clauses from the given query to the given arel construct.","result":"Escape the string.","score":[0.0146,0.0417]}
{"code":"# is used to<extra_id_0>\r\ndef load_classes result\r\n      return if @query.ids_requested?\r\n      result.each do |clazz, ids|\r\n        if ids.size > 0\r\n          result[clazz] = clazz.where(id: ids)\r\n          if @query.has_select\r\n            result[clazz] = result[clazz].select(@query.options[:select])\r\n          end\r\n        end\r\n      end\r\n    end","code-length":113,"reference":"Converts the ids to classes, if the user wants classes.","result":"Load classes.","score":[0.0092,0.0543]}
{"code":"# is used to<extra_id_0>\r\ndef search_word word\r\n      empty_result.tap do |result|\r\n        data = Assignment.joins(:word) \\\r\n                         .select('pose_assignments.posable_id, pose_assignments.posable_type') \\\r\n                         .where('pose_words.text LIKE ?', \"#{word}%\") \\\r\n                         .where('pose_assignments.posable_type IN (?)', @query.class_names)\r\n        data = add_joins data\r\n        data = add_wheres data\r\n        Assignment.connection.select_all(data.to_sql).each do |pose_assignment|\r\n          result[pose_assignment['posable_type']] << pose_assignment['posable_id'].to_i\r\n        end\r\n      end\r\n    end","code-length":186,"reference":"Finds all matching ids for a single word of the search query.","result":"Search for a word.","score":[0.0611,0.2282]}
{"code":"# is used to<extra_id_0>\r\ndef search_words\r\n      {}.tap do |result|\r\n        @query.query_words.each do |query_word|\r\n          search_word(query_word).each do |class_name, ids|\r\n            merge_search_result_word_matches result, class_name, ids\r\n          end\r\n        end\r\n      end\r\n    end","code-length":94,"reference":"Returns all matching ids for all words of the search query.","result":"Search for words.","score":[0.0284,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef client_login_authorization_header(http_method, uri)\r\n      if @user && @password && !@auth_token\r\n        email            = CGI.escape(@user)\r\n        password         = CGI.escape(@password)\r\n        http             = Net::HTTP.new('www.google.com', 443)\r\n        http.use_ssl     = true\r\n        http.verify_mode = OpenSSL::SSL::VERIFY_NONE\r\n        resp, data = http.post('\/accounts\/ClientLogin',\r\n                               \"accountType=HOSTED_OR_GOOGLE&Email=#{email}&Passwd=#{password}&service=wise\",\r\n                               { 'Content-Type' => 'application\/x-www-form-urlencoded' })\r\n        handle_response(resp)\r\n        @auth_token = (data || resp.body)[\/Auth=(.*)\/n, 1]\r\n      end\r\n      @auth_token ? { 'Authorization' => \"GoogleLogin auth=#{@auth_token}\" } : {}\r\n    end","code-length":250,"reference":"Deprecated and Not recommended","result":"Generate the header.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef app_folder(app_name = self.current_app)\r\n      if self.type == :multi\r\n        if app_name.in? self.main_apps\r\n          \"#{self.folder}\/main_apps\/#{app_name}\"\r\n        elsif app_name.in? self.engines\r\n          \"#{self.folder}\/engines\/#{app_name}\"\r\n        end\r\n      elsif self.type == :single\r\n        self.folder\r\n      end\r\n    end","code-length":122,"reference":"Ottiene la directory corrente nella cartella dell'app specificata.","result":"Create the app folder.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef app_version_file(app_name = self.current_app)\r\n      Dir.glob(\"#{app_folder(app_name)}\/lib\/**\/version.rb\").min_by do |filename|\r\n        filename.chars.count\r\n      end\r\n    end","code-length":73,"reference":"Determina il file di versione dell'app.","result":"Determine the version file.","score":[0,0.0862]}
{"code":"# is used to<extra_id_0>\r\ndef app_version(app_name = self.current_app)\r\n      if File.exists? app_version_file(app_name).to_s\r\n        File.read(app_version_file(app_name))\r\n          .match(\/VERSION = '([0-9\\.]+)'\\n\/)\r\n          .try(:captures).try(:first)\r\n      else\r\n        `git tag`.split(\"\\n\").first\r\n      end\r\n    end","code-length":120,"reference":"Ritorna la versione dell'app.","result":"Determine the version of the current app.","score":[0,0.1163]}
{"code":"# is used to<extra_id_0>\r\ndef bump_app_version_to(version)\r\n      if File.exists? self.app_version_file\r\n        version_file = self.app_version_file\r\n        version_content = File.read(\"#{version_file}\")\r\n        File.open(version_file, 'w+') do |f|\r\n          f.puts version_content.gsub(\/VERSION = '[0-9\\.]+'\\n\/, \"VERSION = '#{version}'\\n\")\r\n        end\r\n      end\r\n    end","code-length":131,"reference":"Alza la versione dell'app corrente a quella specificata.","result":"Update the version number.","score":[0,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef load_project\r\n      config_file = Dir.glob(\"#{Dir.pwd}\/**\/dev.yml\").first\r\n      raise ExecutionError.new \"No valid configuration files found. Searched for a file named 'dev.yml' \"\\\r\n        \"in folder #{Dir.pwd} and all its subdirectories.\" if config_file.nil?\r\n      @project = Dev::Project.new(config_file)\r\n    end","code-length":106,"reference":"Inizializza l'eseguibile, in base al comando passato.","result":"Load the project.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef help\r\n      puts\r\n      print \"Dev\".green\r\n      print \" - available commands:\\n\"\r\n      puts\r\n            print \"\\tversion\\t\\t\".limegreen \r\n        print \"Prints current version.\\n\"\r\n        puts\r\n      print \"\\tfeature\\t\\t\".limegreen\r\n        print \"Opens or closes a feature for the current app.\\n\"\r\n        print \"\\t\\t\\tWarning: the app is determined from the current working directory!\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev feature open my-new-feature\".springgreen\r\n        print \" (opens a new feature for the current app)\"\r\n        print \".\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev feature close my-new-feature\".springgreen\r\n        print \" (closes a developed new feature for the current app)\"\r\n        print \".\\n\"\r\n        puts\r\n      print \"\\thotfix\\t\\t\".limegreen\r\n        print \"Opens or closes a hotfix for the current app.\\n\"\r\n        print \"\\t\\t\\tWarning: the app is determined from the current working directory!\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev hotfix open 0.2.1\".springgreen\r\n        print \" (opens a new hotfix for the current app)\"\r\n        print \".\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev hotfix close 0.2.1\".springgreen\r\n        print \" (closes a developed new hotfix for the current app)\"\r\n        print \".\\n\"\r\n        puts\r\n      print \"\\trelease\\t\\t\".limegreen\r\n        print \"Opens or closes a release for the current app.\\n\"\r\n        print \"\\t\\t\\tWarning: the app is determined from the current working directory!\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev release open 0.2.0\".springgreen\r\n        print \" (opens a new release for the current app)\"\r\n        print \".\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev release close 0.2.0\".springgreen\r\n        print \" (closes a developed new release for the current app)\"\r\n        print \".\\n\"\r\n        puts\r\n      print \"\\tpull\\t\\t\".limegreen\r\n        print \"Pulls specified app's git repository, or pulls all apps if none are specified.\\n\"\r\n        print \"\\t\\t\\tWarning: the pulled branch is the one the app is currently on!\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev pull [myapp]\".springgreen\r\n        print \".\\n\"\r\n        puts\r\n      print \"\\tpush\\t\\t\".limegreen\r\n        print \"Commits and pushes the specified app.\\n\"\r\n        print \"\\t\\t\\tWarning: the pushed branch is the one the app is currently on!\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev push myapp \\\"commit message\\\"\".springgreen\r\n        print \".\\n\"\r\n        puts\r\n      print \"\\ttest\\t\\t\".limegreen\r\n        print \"Runs the app's test suite. Tests must be written with rspec.\\n\"\r\n        print \"\\t\\t\\tIt is possibile to specify which app's test suite to run.\\n\"\r\n        print \"\\t\\t\\tIf nothing is specified, all main app's test suites are run.\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev test mymainapp myengine\".springgreen\r\n        print \" (runs tests for 'mymainapp' and 'myengine')\"\r\n        print \".\\n\"\r\n        print \"\\t\\t\\tExample: \"\r\n        print \"dev test\".springgreen\r\n        print \" (runs tests for all main apps and engines within this project)\"\r\n        print \".\\n\"\r\n        puts\r\n    end","code-length":991,"reference":"Stampa i comandi possibili.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add(objects, timestamp = @time)\r\n      unless objects.kind_of? Array\r\n        objects = [ objects ]\r\n      end\r\n      objects.each do |object|\r\n        if object.instance_of? Hash\r\n          timestamp = object[:ts] || 0\r\n          object = object[:val]\r\n        end\r\n        token = prepare_token(object, timestamp)\r\n        timestamp = token.timestamp\r\n        if timestamp > @time\r\n          add_to_waiting token\r\n        else\r\n          add_token token\r\n        end\r\n      end\r\n    end","code-length":148,"reference":"Create a new TimedHashMarking","result":"Add objects to the queue.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef time=(time)\r\n      if time < @time\r\n        raise InvalidTime.new(\"You are trying to put back clock from #{@time} back to #{time}\")\r\n      end\r\n      @time = time\r\n      @waiting.keys.sort.each do |timestamp|\r\n        if timestamp > @time\r\n          @next_time = timestamp\r\n          break\r\n        end\r\n        @waiting[timestamp].each { |token| add_token token }\r\n        @waiting.delete timestamp\r\n      end\r\n      @next_time = 0 if @waiting.empty?\r\n      @time\r\n    end","code-length":153,"reference":"Set current time for the marking.","result":"Set the clock.","score":[0.1786,0.1754]}
{"code":"# is used to<extra_id_0>\r\ndef send_message data, binary=false\r\n      if established?\r\n        unless @closing\r\n          @socket.send_data(@encoder.encode(data.to_s, binary ? BINARY_FRAME : TEXT_FRAME))\r\n        end\r\n      else\r\n        raise WebSocketError.new \"can't send on a closed channel\"\r\n      end\r\n    end","code-length":93,"reference":"Send a message to the remote host data - The string contents of your message","result":"Send messages.","score":[0.0008,0.0365]}
{"code":"# is used to<extra_id_0>\r\ndef post(options)\r\n    uri = new_uri\r\n    params = merge_params(options)\r\n    response = Net::HTTP.post_form(uri, params)\r\n    unless response.is_a?(Net::HTTPSuccess)\r\n      raise \"#{response.code} #{response.message}\\n#{response.body}\"\r\n    end\r\n    response.body\r\n  end","code-length":100,"reference":"== instance methods","result":"Create a new URI.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef delete(options={})\r\n    uri = new_uri\r\n    params = merge_params(options)\r\n    uri.query = URI.encode_www_form(params)\r\n    http = Net::HTTP.new(uri.host, uri.port)\r\n    request = Net::HTTP::Delete.new(uri)\r\n    response = http.request(request)\r\n    unless response.is_a?(Net::HTTPSuccess)\r\n      raise \"#{response.code} #{response.message}\\n#{response.body}\"\r\n    end\r\n    true\r\n  end","code-length":144,"reference":"Make a DELETE API call with the current path value and ","result":"Delete a resource.","score":[0.0284,0.098]}
{"code":"# is used to<extra_id_0>\r\ndef instance_metadata(name)\r\n      instance = instance(name)\r\n      config = {}\r\n      if instance.configured?\r\n        config = instance.configfile_hash\r\n        config[\"ensure\"] = :present\r\n      else\r\n        config[\"ensure\"] = :absent\r\n      end\r\n      config[\"name\"] = name\r\n      config\r\n    end","code-length":96,"reference":"Return a has representing the named instance.","result":"Store instance metadata.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef instances_metadata()\r\n      instance_wildcard = File.join(@vagrant_vm_dir, \"*\", ::Vagrantomatic::Instance::VAGRANTFILE)\r\n      instances = {}\r\n      Dir.glob(instance_wildcard).each { |f|\r\n        elements = f.split(File::SEPARATOR)\r\n        name = elements[elements.size - 2]\r\n        instances[name] = instance_metadata(name)\r\n      }\r\n      instances\r\n    end","code-length":121,"reference":"Return a hash of all instances","result":"Get metadata about instances.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef csv_read(path)\r\n      lines = begin\r\n        if path =~ \/\\.gz$\/\r\n          Zlib::GzipReader.open(path) do |f|\r\n            CSV.new(f).read\r\n          end\r\n        else\r\n          CSV.read(path)\r\n        end\r\n      end\r\n      keys = lines.shift.map(&:to_sym)\r\n      klass = Struct.new(*keys)\r\n      lines.map { |i| klass.new(*i) }\r\n    end","code-length":133,"reference":"Read a csv from +path+.","result":"Read CSV files.","score":[0.2096,0.2083]}
{"code":"# is used to<extra_id_0>\r\ndef csv_write(path, rows, cols: nil)\r\n      atomic_write(path) do |tmp|\r\n        CSV.open(tmp.path, \"wb\") { |f| csv_write0(f, rows, cols: cols) }\r\n      end\r\n    end","code-length":75,"reference":"Write +rows+ to +path+ as csv.","result":"Write to a CSV file.","score":[0.2339,0.1695]}
{"code":"# is used to<extra_id_0>\r\ndef csv_to_s(rows, cols: nil)\r\n      string = \"\"\r\n      f = CSV.new(StringIO.new(string))\r\n      csv_write0(f, rows, cols: cols)\r\n      string\r\n    end","code-length":68,"reference":"Returns a string containing +rows+ as a csv. Similar to csv_write.","result":"Convert CSV to String.","score":[0.0555,0.0485]}
{"code":"# is used to<extra_id_0>\r\ndef add_value(name, type, subtype = nil)\r\n      if type.class == RustyJson::RustStruct || subtype.class == RustyJson::RustStruct\r\n        if type.class == RustyJson::RustStruct\r\n          t = type\r\n          type = type.name\r\n          struct = t\r\n        elsif subtype.class == RustyJson::RustStruct\r\n          s = subtype\r\n          subtype = subtype.name\r\n          struct = s\r\n        end\r\n        @structs << struct\r\n        RustStruct.add_type(struct.name, struct.name)\r\n      end\r\n      @values[name] = [type, subtype]\r\n      true\r\n    end","code-length":180,"reference":"Add Value is how we add keys to the resulting Struct","result":"Add a value to the RustStruct.","score":[0.1313,0.3006]}
{"code":"# is used to<extra_id_0>\r\ndef rotate(hsh)\r\n      current_ec2, new_ec2 = hsh.first\r\n      cur_instances = EC2.by_tags(\"Name\" => current_ec2.to_s)\r\n      new_instances = EC2.by_tags(\"Name\" => new_ec2.to_s)\r\n      register_and_wait new_instances\r\n      deregister        cur_instances\r\n    end","code-length":107,"reference":"Rotate servers given","result":"Rotate instances.","score":[0.3033,0.1724]}
{"code":"# is used to<extra_id_0>\r\ndef wait_for_state(instances, exp_state)\r\n      time = 0\r\n      all_good = false\r\n      loop do\r\n        all_good = instances.all? do |i|\r\n          state = i.elb_health[:state] \r\n          puts \"#{i.id}: #{state}\"\r\n          exp_state == state\r\n        end\r\n        break if all_good || time > timeout\r\n        sleep 1\r\n        time += 1\r\n      end\r\n      unless all_good\r\n        raise \"Instances are out of service\"\r\n      end\r\n    end","code-length":147,"reference":"Wait for all the instances to become InService","result":"Wait for instances to reach the desired state.","score":[0.2733,0.5575]}
{"code":"# is used to<extra_id_0>\r\ndef read(path)\r\n      owconnect do |socket|\r\n        owwrite(socket,:path => path, :function => READ)\r\n        return to_number(owread(socket).data)\r\n      end\r\n    end","code-length":64,"reference":"Read a value from an OW path.","result":"Read a file.","score":[0.1522,0.2841]}
{"code":"# is used to<extra_id_0>\r\ndef write(path, value)\r\n      owconnect do |socket|\r\n        owwrite(socket, :path => path, :value => value.to_s, :function => WRITE)\r\n        return owread(socket).return_value\r\n      end\r\n    end","code-length":72,"reference":"Write a value to an OW path.","result":"Write to a file.","score":[0.1986,0.2239]}
{"code":"# is used to<extra_id_0>\r\ndef dir(path)\r\n      owconnect do |socket|\r\n        owwrite(socket,:path => path, :function => DIR)\r\n                fields = []\r\n        while true\r\n          response = owread(socket)\r\n          if response.data\r\n            fields << response.data\r\n          else\r\n            break\r\n          end\r\n        end\r\n        return fields\r\n      end\r\n    end","code-length":106,"reference":"List the contents of an OW path.","result":"Create a directory.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef sum_totals_by_model\r\n      @sum_totals_by_model ||= begin\r\n        totals = Hash.new { |hash, key| hash[key] = Hash.new(0) }\r\n        @queries_by_model.each do |model, queries|\r\n          totals[model][:query_count] = queries.length\r\n          queries.each do |query|\r\n            query.statistics.each do |stat, value|\r\n              totals[model][stat] += value\r\n            end\r\n          end\r\n          totals[model][:datastore_interaction_time] = totals[model][:datastore_interaction_time]\r\n        end\r\n        totals\r\n      end\r\n    end","code-length":176,"reference":"sums up statistics across all queries, indexed by model","result":"Calculate the totals of queries by model.","score":[0.1214,0.1136]}
{"code":"# is used to<extra_id_0>\r\ndef sum_totals\r\n      @sum_totals ||= begin\r\n        totals = Hash.new(0)\r\n        sum_totals_by_model.each do |_, model_totals|\r\n          model_totals.each do |stat, value|\r\n            totals[stat] += value\r\n          end\r\n        end\r\n        totals\r\n      end\r\n    end","code-length":101,"reference":"sums up statistics across all models and queries","result":"Calculate the totals.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef to_label\r\n      s = '%016x%08x'\r\n      sec = tai_second\r\n      ts = if sec >= 0\r\n        sec + EPOCH\r\n      else\r\n        EPOCH - sec\r\n      end\r\n      Label.new s % [ ts, tai_nanosecond ]\r\n    end","code-length":87,"reference":"Warning, this will probably gain inappropriate accuracy - Ruby does not support the same level of timing accuracy as TAI64N and TA64NA can provide.","result":"Create a label.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef put(name, object)\r\n      raise \"This ObjectContext already has an instance or configuration for '#{name.to_s}'\" if directly_has?(name)\r\n      Conject.install_object_context(object, self)\r\n      object.instance_variable_set(:@_conject_contextual_name, name.to_s)\r\n      @cache[name.to_sym] = object\r\n    end","code-length":107,"reference":"Inject a named object into this context","result":"Store objects.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef configure_objects(confs={})\r\n      confs.each do |key,opts|\r\n        key = key.to_sym\r\n        @object_configs[key] ={} unless has_config?(key)\r\n        @object_configs[key].merge!(opts)\r\n      end\r\n    end","code-length":84,"reference":"Allow configuration options to be set for named objects.","result":"Configure objects.","score":[0.0151,0.1205]}
{"code":"# is used to<extra_id_0>\r\ndef httperf warm_up = false\r\n      httperf_cmd = build_httperf_cmd\r\n      if warm_up\r\n        status \"\\n#{httperf_cmd} (warm up run)\"\r\n        IO.popen(\"#{httperf_cmd} 2>&1\")\r\n      else\r\n        IO.popen(\"#{httperf_cmd} 2>&1\") do |pipe|\r\n          status \"\\n#{httperf_cmd}\"\r\n          @results << (httperf_result = HttperfResult.new({\r\n              :rate         => @current_rate,\r\n              :server       => @current_job.server,\r\n              :port         => @current_job.port,\r\n              :uri          => @current_job.uri,\r\n              :num_conns    => @current_job.num_conns,\r\n              :description  => @current_job.description\r\n            }))\r\n          HttperfResultParser.new(pipe).parse(httperf_result)\r\n        end\r\n      end\r\n    end","code-length":254,"reference":"Runs httperf with a given request rate.","result":"Run the program.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef url(path, params = {})\r\n      params = params.inject({}, &@@stringify)\r\n      path = path.gsub(@@placeholder) { params.delete($1, &@@required) }\r\n      params = params.inject('', &@@parameterize)\r\n      [path, params].reject(&:nil?).reject(&:empty?).join('?')\r\n    end","code-length":102,"reference":"Converts a path and params to a Salesforce-suitable URL.","result":"Generate the url.","score":[0,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef url?(string)\r\n      return false unless string.to_s =~ url_pattern\r\n      return false if     string.to_s =~ @@placeholder\r\n      true\r\n    end","code-length":53,"reference":"Identifies a valid URL for this REST instance","result":"Detect URLs.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef assit_equal(expected, actual, message = \"Object expected to be equal\")\r\n      if(expected != actual)\r\n        message << \" expected #{expected} but was #{actual}\"\r\n        assit(false, message)\r\n      end\r\n    end","code-length":70,"reference":"Assert if two objects are equal","result":"Assert equality.","score":[0.0677,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef assit_kind_of(klass, object, message = \"Object of wrong type\")\r\n      if(!object.kind_of?(klass))\r\n        message << \" (Expected #{klass} but was #{object.class})\"\r\n        assit(false, message)\r\n      end\r\n    end","code-length":80,"reference":"Assert if something is of the right type","result":"Assit objects of wrong type.","score":[0.1319,0.0649]}
{"code":"# is used to<extra_id_0>\r\ndef assit_real_string(object, message = \"Not a non-empty string.\")\r\n      unless(object && object.kind_of?(String) && object.strip != \"\")\r\n        assit(false, message)\r\n      end\r\n    end","code-length":71,"reference":"Asserts that the given element is a string that is not nil and not an empty string, or a string only containing whitspaces","result":"Not a non-empty string.","score":[0.0028,0.0474]}
{"code":"# is used to<extra_id_0>\r\ndef assit_block(&block)\r\n      errors = []\r\n      assit((block.call(errors) && errors.size == 0), errors.join(', '))\r\n    end","code-length":54,"reference":"Executes the given block and asserts if the result is true.","result":"Create a block.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef poll interval: 10, &block\r\n      raise '\r\n      response_id = 0\r\n      loop do\r\n        res = self.sync response_id\r\n        if res\r\n          response_id = res['rid']\r\n                    yield res\r\n        end\r\n        sleep interval\r\n      end\r\n    end","code-length":84,"reference":"Polls the client for incremental changes.","result":"Def poll interval.","score":[0,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef sync response_id = 0\r\n      req = self.class.get '\/sync\/maindata', format: :json,\r\n                           query: { rid: response_id }\r\n      res = req.parsed_response\r\n      if req.success?\r\n        return res\r\n      end\r\n    end","code-length":80,"reference":"Requests partial data from the client.","result":"Sync response_id.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add_trackers torrent_hash, urls\r\n      urls = Array(urls)\r\n      urls = urls.map { |url| url.gsub('&', '%26') }\r\n      urls = urls.join('%0A')\r\n      options = {\r\n        body: \"hash=#{torrent_hash}&urls=#{urls}\"\r\n      }\r\n      self.class.post('\/command\/addTrackers', options)\r\n    end","code-length":112,"reference":"Add one or more trackers to a torrent","result":"Add torrents to the torrent.","score":[0.1568,0.1948]}
{"code":"# is used to<extra_id_0>\r\ndef download urls\r\n      urls = Array(urls)\r\n      urls = urls.join('%0A')\r\n      options = {\r\n        body: \"urls=#{urls}\"\r\n      }\r\n      self.class.post('\/command\/download', options)\r\n    end","code-length":73,"reference":"Begin downloading one or more torrents.","result":"Escape the line.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef delete_torrent_and_data torrent_hashes\r\n      torrent_hashes = Array(torrent_hashes)\r\n      torrent_hashes = torrent_hashes.join('|')\r\n      options = {\r\n        body: \"hashes=#{torrent_hashes}\"\r\n      }\r\n      self.class.post('\/command\/deletePerm', options)\r\n    end","code-length":94,"reference":"Delete one or more torrents AND THEIR DATA","result":"Delete torrents and data.","score":[0.1398,0.3363]}
{"code":"# is used to<extra_id_0>\r\ndef set_location(torrent_hashes, path)\r\n      torrent_hashes = Array(torrent_hashes)\r\n      torrent_hashes = torrent_hashes.join('|')\r\n      options = {\r\n        body: { \"hashes\" => torrent_hashes, \"location\" => path },\r\n      }\r\n      self.class.post('\/command\/setLocation', options)\r\n    end","code-length":101,"reference":"Set location for a torrent","result":"Set the location of a torrent.","score":[0.2541,0.2941]}
{"code":"# is used to<extra_id_0>\r\ndef increase_priority torrent_hashes\r\n      torrent_hashes = Array(torrent_hashes)\r\n      torrent_hashes = torrent_hashes.join('|')\r\n      options = {\r\n        body: \"hashes=#{torrent_hashes}\"\r\n      }\r\n      self.class.post('\/command\/increasePrio', options)\r\n    end","code-length":92,"reference":"Increase the priority of one or more torrents","result":"Increase the priority of a torrent.","score":[0.433,0.5088]}
{"code":"# is used to<extra_id_0>\r\ndef decrease_priority torrent_hashes\r\n      torrent_hashes = Array(torrent_hashes)\r\n      torrent_hashes = torrent_hashes.join('|')\r\n      options = {\r\n        body: \"hashes=#{torrent_hashes}\"\r\n      }\r\n      self.class.post('\/command\/decreasePrio', options)\r\n    end","code-length":92,"reference":"Decrease the priority of one or more torrents","result":"Set the priority of a torrent.","score":[0.2849,0.3775]}
{"code":"# is used to<extra_id_0>\r\ndef maximize_priority torrent_hashes\r\n      torrent_hashes = Array(torrent_hashes)\r\n      torrent_hashes = torrent_hashes.join('|')\r\n      options = {\r\n        body: \"hashes=#{torrent_hashes}\"\r\n      }\r\n      self.class.post('\/command\/topPrio', options)\r\n    end","code-length":92,"reference":"Increase the priority of one or more torrents to the maximum value","result":"Maximize the priority of a torrent.","score":[0.1463,0.2242]}
{"code":"# is used to<extra_id_0>\r\ndef minimize_priority torrent_hashes\r\n      torrent_hashes = Array(torrent_hashes)\r\n      torrent_hashes = torrent_hashes.join('|')\r\n      options = {\r\n        body: \"hashes=#{torrent_hashes}\"\r\n      }\r\n      self.class.post('\/command\/bottomPrio', options)\r\n    end","code-length":91,"reference":"Decrease the priority of one or more torrents to the minimum value","result":"Minimize the priority of a torrent.","score":[0.1463,0.2242]}
{"code":"# is used to<extra_id_0>\r\ndef set_file_priority torrent_hash, file_id, priority\r\n      query = [\"hash=#{torrent_hash}\", \"id=#{file_id}\", \"priority=#{priority}\"]\r\n      options = {\r\n        body: query.join('&')\r\n      }\r\n      self.class.post('\/command\/setFilePrio', options)\r\n    end","code-length":97,"reference":"Set the download priority of a file within a torrent file_id is a 0 based position of the file within the torrent","result":"Set file priority.","score":[0.0009,0.0498]}
{"code":"# is used to<extra_id_0>\r\ndef set_download_limit torrent_hash, limit\r\n      query = [\"hashes=#{torrent_hash}\", \"limit=#{limit}\"]\r\n      options = {\r\n        body: query.join('&')\r\n      }\r\n      self.class.post('\/command\/setTorrentsDlLimit', options)\r\n    end","code-length":87,"reference":"Set a torrent's download limit","result":"Set download limit for torrents.","score":[0.3761,0.5111]}
{"code":"# is used to<extra_id_0>\r\ndef set_upload_limit torrent_hash, limit\r\n      query = [\"hashes=#{torrent_hash}\", \"limit=#{limit}\"]\r\n      options = {\r\n        body: query.join('&')\r\n      }\r\n      self.class.post('\/command\/setTorrentsUpLimit', options)\r\n    end","code-length":86,"reference":"Set a torrent's upload limit","result":"Set upload limit for torrents.","score":[0.3761,0.5111]}
{"code":"# is used to<extra_id_0>\r\ndef md5_file(path)\r\n      File.open(path) do |f|\r\n        digest, buf = Digest::MD5.new, \"\"\r\n        while f.read(4096, buf)\r\n          digest.update(buf)\r\n        end\r\n        digest.hexdigest\r\n      end\r\n    end","code-length":87,"reference":"Return the md5 checksum for the file at +path+.","result":"Calculate the md5 hash of a file.","score":[0.1716,0.1136]}
{"code":"# is used to<extra_id_0>\r\ndef keys(*a)\r\n      if block_given?\r\n        bucket.keys(*a) do |keys|\r\n          if keys.kind_of? Array\r\n            keys.each do |key|\r\n              yield key\r\n            end\r\n          else\r\n            yield keys\r\n          end\r\n        end\r\n      else\r\n        bucket.keys(*a)\r\n      end\r\n    end","code-length":103,"reference":"Iterate over all keys.","result":"Generate the keys.","score":[0.2925,0.1282]}
{"code":"# is used to<extra_id_0>\r\ndef each\r\n      bucket.keys do |keys|\r\n        keys.each do |key|\r\n          if x = self[key]\r\n            yield x\r\n          end\r\n        end\r\n      end\r\n    end","code-length":62,"reference":"Iterate over all items using key streaming.","result":"Iterate over the keys.","score":[0.2134,0.2799]}
{"code":"# is used to<extra_id_0>\r\ndef run(command, args = nil)\r\n      cmd = CommandLine.new(command, args)\r\n      vputs(cmd)\r\n      cmd.run\r\n    end","code-length":49,"reference":"Run an external command.","result":"Run a command.","score":[0.3479,0.2564]}
{"code":"# is used to<extra_id_0>\r\ndef clicks(options = {})\r\n      options = update_by_expire_time options\r\n      if clicks_not_latest?(options)\r\n        @rsqoot_clicks = get('clicks', options, SqootClick)\r\n        @rsqoot_clicks = @rsqoot_clicks.clicks if @rsqoot_clicks\r\n        @rsqoot_clicks = @rsqoot_clicks.clicks.map(&:click) if @rsqoot_clicks.clicks\r\n      end\r\n      logger(uri: sqoot_query_uri, records: @rsqoot_clicks, type: 'clicks', opts: options)\r\n      @rsqoot_clicks\r\n    end","code-length":185,"reference":"Retrieve a list of clicks based on the following parameters","result":"Query the Sqoot API.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef build_instances(template = nil)\r\n      build_args =\r\n        if template == :template\r\n          [build_options.first.merge(count: 1)]\r\n        else\r\n          build_options\r\n        end\r\n      build_args.map do |args|\r\n        instances = create_instance args\r\n        apply_tags(instances)\r\n        instances\r\n      end.flatten\r\n    end","code-length":107,"reference":"Build instances using build options","result":"Build instances.","score":[0.1116,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef scope(scope_name, scope_enum_keys)\r\n      target_enum = @record_class.defined_enums[@enum_name.to_s]\r\n      sub_enum_values = target_enum.values_at(*scope_enum_keys)\r\n      if @record_class.defined_enum_scopes.has_key?(scope_name)\r\n        fail ArgumentError,\r\n             \"Conflicting scope names. A scope named #{scope_name} has already been defined\"\r\n      elsif sub_enum_values.include?(nil)\r\n        unknown_key = scope_enum_keys[sub_enum_values.index(nil)]\r\n        fail ArgumentError, \"Unknown key - #{unknown_key} for enum #{@enum_name}\"\r\n      elsif @record_class.respond_to?(scope_name.to_s.pluralize)\r\n        fail ArgumentError,\r\n             \"Scope name - #{scope_name} conflicts with a class method of the same name\"\r\n      elsif @record_class.instance_methods.include?(\"#{scope_name}?\".to_sym)\r\n        fail ArgumentError,\r\n             \"Scope name - #{scope_name} conflicts with the instance method - #{scope_name}?\"\r\n      end\r\n      sub_enum_entries = target_enum.slice(*scope_enum_keys)\r\n      @record_class.defined_enum_scopes[scope_name] = sub_enum_entries\r\n      @record_class.send(:define_method, \"#{scope_name}?\") { sub_enum_entries.include? self.role }\r\n      @record_class.scope scope_name.to_s.pluralize,\r\n                          -> { @record_class.where(\"#{@enum_name}\" => sub_enum_entries.values) }\r\n      @scope_names << scope_name\r\n    end","code-length":437,"reference":"Initialize a new ScopeCreator object ","result":"Define scope_name.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef configure\r\n      configuration = {\r\n                        :options => {\r\n                          :verbose => false,\r\n                          :coloring => 'AUTO'\r\n                        },\r\n                        :mount => {\r\n                          :source => {\r\n                            :name => nil\r\n                          },\r\n                          :mountpoint => {\r\n                            :name => nil\r\n                          },\r\n                          :passphrasefile => {\r\n                            :name => 'passphrase'\r\n                          },\r\n                          :keyfile => {\r\n                            :name => 'encfs6.xml'\r\n                          },\r\n                          :cmd => nil,\r\n                          :executable => nil\r\n                        },\r\n                        :unmount => {\r\n                          :mountpoint => {\r\n                            :name => nil\r\n                          },\r\n                          :cmd => nil,\r\n                          :executable => nil\r\n                        },\r\n                        :copy => {\r\n                          :source => {\r\n                            :name => nil\r\n                          },\r\n                          :destination => {\r\n                            :name => nil\r\n                          },\r\n                          :cmd => nil,\r\n                          :executable => nil\r\n                        }\r\n                      }\r\n      config = @options[:config]\r\n      unless config\r\n        config = [\r\n                   File.join(@working_dir, \"revenc.conf\"),\r\n                   File.join(@working_dir, \".revenc.conf\"),\r\n                   File.join(@working_dir, \"config\", \"revenc.conf\"),\r\n                   File.expand_path(File.join(\"~\", \".revenc.conf\"))\r\n                 ].detect { |filename| File.exists?(filename) }\r\n      end\r\n      if config && File.exists?(config)\r\n        @options[:config] = config\r\n        config_contents = YAML::load(File.open(config))\r\n        configuration.merge!(config_contents.symbolize_keys!) if config_contents && config_contents.is_a?(Hash)\r\n      else\r\n        raise \"config file not found\" if @options[:config]\r\n      end\r\n      @options = configuration[:options].merge!(@options)\r\n      @options.symbolize_keys!\r\n      @options[:mount] = configuration[:mount].recursively_symbolize_keys! if configuration[:mount]\r\n      @options[:unmount] = configuration[:unmount].recursively_symbolize_keys! if configuration[:unmount]\r\n      @options[:copy] = configuration[:copy].recursively_symbolize_keys! if configuration[:copy]\r\n    end","code-length":599,"reference":"read options from YAML config","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef mark_new_entries(response)\r\n      digests = summary_digests\r\n      response.entries.each do |e|\r\n        seen = digests.include?(digest_for(e))\r\n        e.instance_variable_set(:@_seen, seen)\r\n      end\r\n            response\r\n    end","code-length":86,"reference":"Marks entries as either seen or not seen based on the unique signature of the entry, which is calculated by taking the MD5 of common attributes.","result":"Mark new entries.","score":[0,0.0211]}
{"code":"# is used to<extra_id_0>\r\ndef set_header_options(curl)\r\n      summary = summary_for_feed\r\n            unless summary.nil?\r\n        curl.headers['If-None-Match']     = summary[:etag] unless summary[:etag].nil?\r\n        curl.headers['If-Modified-Since'] = summary[:last_modified] unless summary[:last_modified].nil?\r\n      end\r\n            curl\r\n    end","code-length":103,"reference":"Sets the headers from the backend, if available","result":"Set the header options.","score":[0.1175,0.1974]}
{"code":"# is used to<extra_id_0>\r\ndef store_summary_to_backend(feed, curl)\r\n      headers = HttpHeaders.new(curl.header_str)\r\n            summary = { }\r\n            summary.merge!(:etag => headers.etag) unless headers.etag.nil?\r\n      summary.merge!(:last_modified => headers.last_modified) unless headers.last_modified.nil?\r\n            new_digest_set = feed.entries.map do |e|\r\n        digest_for(e)\r\n      end\r\n            new_digest_set = summary_for_feed[:digests].unshift(new_digest_set)\r\n      new_digest_set = new_digest_set[0..@options[:retained_digest_size]]\r\n            summary.merge!( :digests => new_digest_set )\r\n      set_summary(summary)\r\n    end","code-length":207,"reference":"Stores information about the retrieval, including ETag, Last-Modified, and MD5 digests of all entries to the backend store.","result":"Store the summary for the feed.","score":[0.0311,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef error_manager(uri, response)\r\n      case response\r\n      when Net::HTTPSuccess then\r\n        begin\r\n          data = JSON.parse(response.body)\r\n        rescue\r\n          data = {}\r\n        end\r\n)\r\n        return data\r\n      when Net::HTTPBadRequest\r\n        raise Ropenstack::MalformedRequestError, response.body\r\n      when Net::HTTPNotFound\r\n        raise Ropenstack::NotFoundError, \"URI: #{uri} \\n\" + response.body\t\r\n      when Net::HTTPUnauthorized\r\n        raise Ropenstack::UnauthorisedError, response.body\r\n      else\r\n        raise Ropenstack::RopenstackError, response.body\r\n      end\r\n    end","code-length":177,"reference":"All responses from openstack where any errors need to be caught are passed through this function.","result":"Handle errors.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef do_request(uri, request, manage_errors = true, timeout = 10)\r\n      begin \r\n        http = build_http(uri, timeout)\r\n        if(manage_errors)\r\n          return error_manager(uri, http.request(request))\r\n        else\r\n          http.request(request)\r\n          return { \"Success\" => true }\r\n        end\r\n      rescue Timeout::Error\r\n        raise Ropenstack::TimeoutError, \"It took longer than #{timeout} to connect to #{uri.to_s}\"\t\r\n      rescue Errno::ECONNREFUSED\r\n        raise Ropenstack::TimeoutError, \"It took longer than #{timeout} to connect to #{uri.to_s}\"\t\r\n      end\t\r\n    end","code-length":184,"reference":"The function which you call to perform a http request using the request object given in the parameters.","result":"Send a request to a URI.","score":[0.0344,0.0893]}
{"code":"# is used to<extra_id_0>\r\ndef get_request(uri, token = nil, manage_errors = true)\r\n      request = Net::HTTP::Get.new(uri.request_uri, initheader = build_headers(token))\r\n      return do_request(uri, request, manage_errors)\r\n    end","code-length":75,"reference":"Wrapper function for a get request, just provide a uri and it will return you a hash with the result data.","result":"Make a request to the server.","score":[0.0188,0.0769]}
{"code":"# is used to<extra_id_0>\r\ndef delete_request(uri, token = nil, manage_errors = true)\r\n      request = Net::HTTP::Delete.new(uri.request_uri, initheader = build_headers(token))\r\n      return do_request(uri, request, manage_errors)\r\n    end","code-length":75,"reference":"Wrapper function for delete requests, just provide a uri and it will return you a hash with the result data.","result":"Make sure that the method.","score":[0.012,0.027]}
{"code":"# is used to<extra_id_0>\r\ndef put_request(uri, body, token = nil, manage_errors = true)\r\n      request = Net::HTTP::Put.new(uri.request_uri, initheader = build_headers(token))\r\n      request.body = body.to_json\r\n      return do_request(uri, request, manage_errors)    \r\n    end","code-length":90,"reference":"Wrapper function for a put request, just provide a uri and a hash of the data to send, then it will return you a hash with the result data.","result":"Create a new request.","score":[0.0006,0.0189]}
{"code":"# is used to<extra_id_0>\r\ndef post_request(uri, body, token = nil, manage_errors = true)\r\n      request = Net::HTTP::Post.new(uri.request_uri, initheader = build_headers(token))\r\n      request.body = body.to_json\r\n      return do_request(uri, request, manage_errors)    \r\n    end","code-length":90,"reference":"Wrapper function for a put request, just provide a uri and a hash of the data to send, then it will return you a hash with the result data.","result":"Create a new request.","score":[0.0006,0.0189]}
{"code":"# is used to<extra_id_0>\r\ndef article(id)\r\n      url = index.knowledgeManagement.articles.article\r\n      url = url(url, ArticleID: id)\r\n      decorate(get(url).body) { |o| autodefine(o) }\r\n    end","code-length":69,"reference":"Gets an article by ID","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef upload_image_from_file(name, disk_format, container_format, minDisk, minRam, is_public, file)\r\n      data = {\r\n        \"name\" => name,\r\n        \"disk_format\" => disk_format,\r\n        \"container_format\" => container_format,\r\n        \"minDisk\" => minDisk,\r\n        \"minRam\" => minRam,\r\n        \"public\" => is_public\r\n      }\r\n      imagesBefore = images()\r\n      post_request(address(\"images\"), data, @token, false)\r\n      imagesAfter = images()\r\n      foundNewImage = true\r\n      image = nil\r\n      imagesAfter.each do |imageA|\r\n        imagesBefore.each do |imageB|\r\n          if(imageA == imageB)\r\n            foundNewImage = false\t\t\t\t\r\n          end\r\n        end\r\n        if(foundNewImage)\r\n          image = imageA\r\n          break\r\n        end\r\n      end\r\n      return put_octect(address(image[\"file\"]), file.read, false)\r\n    end","code-length":275,"reference":"BELOW HERE IS OLD CODE THAT MAY OR MAYNOT WORK, THAR BE DRAGONS","result":"Upload an image from a file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef put_octect(uri, data, manage_errors)\r\n      headers = build_headers(@token)\r\n      headers[\"Content-Type\"] = 'application\/octet-stream'\t\r\n      req = Net::HTTP::Put.new(uri.request_uri, initheader = headers)\r\n      req.body = data\r\n      return do_request(uri, req, manage_errors, 0)\r\n    end","code-length":107,"reference":"Special rest call for sending a file stream using an octet-stream main change is just custom headers.","result":"Perform the request.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef relative_path(path)\r\n      path = File.expand_path(path)\r\n      root = full_path(\"\")\r\n      if path.size >= root.size && path[0...root.size] == root\r\n        path[0...root.size] = \"\"\r\n        path = \"\/\" if path.size == 0\r\n        path\r\n      end\r\n    end","code-length":98,"reference":"Returns a path relative to the base path, given the full path.","result":"Resolve relative paths.","score":[0.0203,0.045]}
{"code":"# is used to<extra_id_0>\r\ndef index(path)\r\n      @entries = []\r\n      Dir.entries(path).each do |entry|\r\n        relative_path = relative_path(File.join(path, entry))\r\n        if entry != \".\" && relative_path\r\n          @entries << {:name => entry, :href => relative_path}\r\n        end\r\n      end\r\n      @path = path\r\n      haml :index\r\n    end","code-length":109,"reference":"Renders an index page for the specified directory.","result":"Generate the index page.","score":[0.1398,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef accessors_from_headers!\r\n      raise \"Can't define accessors from headers in a table without headers\" unless @has_headers\r\n      self.accessors = headers.map { |val| (val && !val.empty?) ? val.to_s.downcase.tr('^a-z0-9_', '_').squeeze('_').gsub(\/\\A_|_\\z\/, '').to_sym : nil }\r\n    end","code-length":112,"reference":"Create a new table.","result":"Define accessors from headers.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef <<(row)\r\n      index  = @data.size\r\n      begin\r\n        row = row.to_ary\r\n      rescue NoMethodError\r\n        raise ArgumentError, \"Row must be provided as Array or respond to `to_ary`, but got #{row.class} in row #{index}\" unless row.respond_to?(:to_ary)\r\n        raise\r\n      end\r\n      raise InvalidColumnCount.new(index, row.size, column_count) if @data.first && row.size != @data.first.size\r\n      @data << row\r\n      @rows << Row.new(self, index, row)\r\n      self\r\n    end","code-length":165,"reference":"Append a row to the table.","result":"Store the row in the table.","score":[0.3021,0.4259]}
{"code":"# is used to<extra_id_0>\r\ndef html(id, time)\r\n      inline_footnote_label = Build.tag(\"span\", Build.tag(\"sup\", id.to_s), :class => \"inline-footnote-number\")\r\n      Build.tag(\"a\", inline_footnote_label, :href => \"\r\n    end","code-length":79,"reference":"This is the method that will place the anchor tag and id of the footnote within the paragraph body itself.","result":"Generate the html.","score":[0.0014,0.0273]}
{"code":"# is used to<extra_id_0>\r\ndef footnote_html(id, time)\r\n      footnote_label = Build.tag(\"span\", Build.tag(\"sup\", id.to_s), :class => \"footnote-number\")\r\n      footnote_content = sequence.elements.map { |s| s.html }.join\r\n      Build.tag(\"div\", footnote_label + footnote_content, :id => \"footnote#{id}#{time}\", :class => \"footnote\")\r\n    end","code-length":119,"reference":"This is the method that will actually spit out the div that the footnote's content is in.","result":"Generate the HTML for the footnote.","score":[0.0367,0.0629]}
{"code":"# is used to<extra_id_0>\r\ndef instance_action(id, action, param)\r\n      case action\r\n      when \"RESTART\" \r\n        post_request(address(\"\/instances\/\" + id + \"\/action\"), {:restart => {}}, @token)\r\n      when \"RESIZE\"\r\n        if param.is_a? String\r\n          post_request(address(\"\/instances\/\" + id + \"\/action\"), {:resize => {:flavorRef => param }}, @token)\r\n        elsif param.is_a? Int\r\n          post_request(address(\"\/instances\/\" + id + \"\/action\"), {:resize => {:volume => {:size => param }}}, @token)\r\n        else\r\n          raise Ropenstack::RopenstackError, \"Invalid Parameter Passed\"\r\n        end\r\n      else\r\n        raise Ropenstack::RopenstackError, \"Invalid Action Passed\"\r\n      end\r\n    end","code-length":215,"reference":"Database Instance Actions","result":"Create a new instance.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef add(error_on, message = \"Unknown error\")\r\n       if error_on.is_a?(Symbol)\r\n         error_on_str = error_on.to_s\r\n       else\r\n         error_on_str = underscore(error_on.class.name)\r\n       end\r\n       error_on_str = error_on_str.gsub(\/\\\/\/, '_')\r\n       error_on_str = error_on_str.gsub(\/_\/, ' ')\r\n       error_on_str = error_on_str.gsub(\/^revenc\/, '').strip\r\n       @errors[error_on_str] ||= []\r\n       @errors[error_on_str] << message.to_s\r\n    end","code-length":188,"reference":"add errors, error_on can be a symbol or object instance","result":"Add a new error.","score":[0.0713,0.1064]}
{"code":"# is used to<extra_id_0>\r\ndef coords_of_neighbors(x, y)\r\n        coords_of_neighbors = []\r\n        (x - 1).upto(x + 1).each do |neighbors_x|\r\n          (y - 1).upto(y + 1).each do |neighbors_y|\r\n            next if (x == neighbors_x) && (y == neighbors_y)\r\n            coords_of_neighbors << [neighbors_x, neighbors_y]\r\n          end\r\n        end\r\n        coords_of_neighbors\r\n      end","code-length":132,"reference":"Calculates the co-ordinates of neighbors of a given pair of co-ordinates.","result":"Calculate the coordinates of the neighbors.","score":[0.0998,0.1429]}
{"code":"# is used to<extra_id_0>\r\ndef merchant(id, options = {})\r\n      options = update_by_expire_time options\r\n      if merchant_not_latest?(id)\r\n        @rsqoot_merchant = get(\"merchants\/#{id}\", options, SqootMerchant)\r\n        @rsqoot_merchant = @rsqoot_merchant.merchant if @rsqoot_merchant\r\n      end\r\n      logger(uri: sqoot_query_uri, records: [@rsqoot_merchant], type: 'merchants', opts: options)\r\n      @rsqoot_merchant\r\n    end","code-length":147,"reference":"Retrieve a list of merchants base on the following parameters","result":"Query the Sqoot query.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef encode data, opcode=TEXT_FRAME\r\n      frame = []\r\n      frame << (opcode | 0x80)\r\n      packr = \"CC\"\r\n      if opcode == TEXT_FRAME\r\n        data.force_encoding(\"UTF-8\")\r\n        if !data.valid_encoding?\r\n          raise \"Invalid UTF!\"\r\n        end\r\n      end\r\n      len = data ? data.bytesize : 0\r\n      if len <= 125\r\n        frame << (len | 0x80)\r\n      elsif len < 65536\r\n        frame << (126 | 0x80)\r\n        frame << len\r\n        packr << \"n\"\r\n      else\r\n        frame << (127 | 0x80)\r\n        frame << len\r\n        packr << \"L!>\"\r\n      end\r\n      key = rand(2 ** 31)\r\n      frame << key\r\n      packr << \"N\"\r\n      len.times do |i|\r\n        frame << ((data.getbyte(i) ^ (key >> ((3 - (i % 4)) * 8))) & 0xFF)\r\n      end\r\n      frame.pack(\"#{packr}C*\")\r\n    end","code-length":287,"reference":"Encode a standard payload to a hybi10","result":"Encode data.","score":[0.041,0.0769]}
{"code":"# is used to<extra_id_0>\r\ndef challah_permission\r\n      unless included_modules.include?(InstanceMethods)\r\n        include InstanceMethods\r\n        extend ClassMethods\r\n      end\r\n      class_eval do\r\n        validates_presence_of :name, :key\r\n        validates_uniqueness_of :name, :key\r\n        validates_format_of :key, :with => \/^([a-z0-9_])*$\/, :message => :invalid_key\r\n        has_many :permission_roles, :dependent => :destroy\r\n        has_many :roles, :through => :permission_roles, :order => 'roles.name'\r\n        has_many :permission_users, :dependent => :destroy\r\n        has_many :users, :through => :permission_users, :order => 'users.last_name, users.first_name'\r\n        default_scope order('permissions.name')\r\n        attr_accessible :name, :description, :key, :locked\r\n        after_create :add_to_admin_role\r\n      end\r\n    end","code-length":256,"reference":"This method sets up the +Permission+ class with all baked in methods.","result":"Define the challah_permission module.","score":[0.0432,0.0446]}
{"code":"# is used to<extra_id_0>\r\ndef post hash={}, payload\r\n      raise 'Payload cannot be blank' if payload.nil? || payload.empty?\r\n      hash.symbolize_keys!\r\n      call(:post, hash[:endpoint], (hash[:args]||{}).merge({:method => :post}), payload)\r\n    end","code-length":78,"reference":"makes a POST request","result":"Create a post request.","score":[0.3195,0.4688]}
{"code":"# is used to<extra_id_0>\r\ndef create_network(name, tenant, admin_state_up = true)\r\n      data = {\r\n        'network' => {\r\n          'name' => name,\r\n          'tenant_id' => tenant,\r\n          'admin_state_up' => admin_state_up\r\n        }   \r\n      }\r\n      return post_request(address(\"networks\"), data, @token)\r\n    end","code-length":107,"reference":"Create a new network on Openstack given a name and tenant id.","result":"Create a new network.","score":[0.0891,0.1339]}
{"code":"# is used to<extra_id_0>\r\ndef create_port(network, subnet = nil, device = nil, device_owner = nil)\r\n      data = {\r\n        'port' => {\r\n          'network_id' => network,\r\n        }   \r\n      }\r\n      unless device_owner.nil?\r\n        data['port']['device_owner'] = device_owner\r\n      end\r\n      unless device.nil?\r\n        data['port']['device_id'] = device\r\n      end\r\n      unless subnet.nil?\r\n        data['port']['fixed_ips'] = [{'subnet_id' => subnet}]\r\n      end\r\n        puts data\r\n      return post_request(address(\"ports\"), data, @token)\r\n    end","code-length":178,"reference":"Create a new port given network and device ids, optional parameter subnet id allows for scoping the port to a single subnet.","result":"Create a new port.","score":[0.0073,0.0743]}
{"code":"# is used to<extra_id_0>\r\ndef move_port_to_subnets(port_id, subnet_ids)\r\n      id_list = Array.new()\r\n      subnet_ids.each do |id|\r\n        id_list << { \"subnet_id\" => id }\r\n      end\r\n      return update_port(port_id, id_list)\r\n    end","code-length":90,"reference":"Weird function for adding a port to multiple subnets if nessessary.","result":"Move port to subnets.","score":[0.0785,0.182]}
{"code":"# is used to<extra_id_0>\r\ndef json(data={}, options={})\r\n      response[CONTENT_TYPE] = APPLICATION_JSON\r\n      response.status = options[:status] if options.has_key?(:status)\r\n      response.write self.class.json_serializer.dump(data)\r\n    end","code-length":73,"reference":"This is a convenience method that sets the Content-Type headers and writes the JSON String to the response.","result":"Generate the json.","score":[0.0028,0.0303]}
{"code":"# is used to<extra_id_0>\r\ndef redirect_to(url, options={})\r\n      full_url = absolute_url(url, options)\r\n      response[LOCATION] = full_url\r\n      respond_with 302\r\n      full_url\r\n    end","code-length":62,"reference":"This is a convenience method that forms an absolute URL based on the url parameter, which can be a relative or absolute URL, and then sets the headers and the body appropriately to do a 302 redirect.","result":"Redirect to the same url.","score":[0.0005,0.0296]}
{"code":"# is used to<extra_id_0>\r\ndef servers(id)\r\n      endpoint = \"\/servers\"\r\n      unless id.nil?\r\n        endpoint = endpoint + \"\/\" + id\r\n      end\r\n      return get_request(address(endpoint), @token)\r\n    end","code-length":63,"reference":"Gets a list of servers from OpenStack","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef create_server(name, image, flavor, networks = nil, keypair = nil, security_group = nil, metadata = nil)\r\n      data = { \r\n        \"server\" => { \r\n          \"name\" => name,\r\n          \"imageRef\" => image,\r\n          \"flavorRef\" => flavor,\r\n        }   \r\n      }\r\n      unless networks.nil?\r\n        data[\"server\"][\"networks\"] = networks \r\n      end\r\n      unless keypair.nil?\r\n        data[\"server\"][\"key_name\"] = keypair\r\n      end\r\n      unless security_group.nil?\r\n        data[\"server\"][\"security_group\"] = security_group \r\n      end\r\n      return post_request(address(\"\/servers\"), data, @token)\r\n    end","code-length":197,"reference":"Creates a server on OpenStack.","result":"Create a new server.","score":[0.2488,0.3827]}
{"code":"# is used to<extra_id_0>\r\ndef action(id, act, *args) \r\n      data = case act\r\n        when \"reboot\" then {'reboot' =>{\"type\" => args[0]}}\t\r\n        when \"vnc\" then {'os-getVNCConsole' => { \"type\" => \"novnc\" }} \r\n        when \"stop\" then {'os-stop' => 'null'}\r\n        when \"start\" then {'os-start' => 'null'}\r\n        when \"pause\" then {'pause' => 'null'}\r\n        when \"unpause\" then {'unpause' => 'null'}\r\n        when \"suspend\" then {'suspend' => 'null'}\r\n        when \"resume\" then {'resume' => 'null'}\r\n        when \"create_image\" then {'createImage' => {'name' => args[0], 'metadata' => args[1]}} \r\n        else raise \"Invalid Action\"\r\n        end\r\n      return post_request(address(\"\/servers\/\" + id + \"\/action\"), data, @token)\r\n    end","code-length":257,"reference":"Perform an action on a server on Openstack, by passing an id, and an action, some actions require more data.","result":"Create a new action.","score":[0.0059,0.0272]}
{"code":"# is used to<extra_id_0>\r\ndef delete_image(id)\r\n      uri = URI.parse(\"http:\/\/\" + @location.host + \":\" + @location.port.to_s + \"\/v2\/images\/\" + id)\r\n      return delete_request(uri, @token)\r\n    end","code-length":70,"reference":"Delete an image stored on Openstack through the nova endpoint","result":"Delete an image.","score":[0.056,0.2016]}
{"code":"# is used to<extra_id_0>\r\ndef get(path, opts = {}, wrapper = ::Hashie::Mash)\r\n      uri, headers = url_generator(path, opts)\r\n      begin\r\n        json = JSON.parse uri.open(headers).read\r\n        result = wrapper.new json\r\n        @query_options = result.query\r\n        result\r\n      rescue => e\r\n        logger(error: e)\r\n        nil\r\n      end\r\n    end","code-length":111,"reference":"Get method, use by all other API qeury methods, fetch records from the Sqoot API V2 url, and provide wrapper functionality","result":"Make a GET request.","score":[0,0.0259]}
{"code":"# is used to<extra_id_0>\r\ndef set_basepath\r\n      if self.parent.nil?\r\n        self.basepath = self.basename\r\n        self.basedirpath ||= ''\r\n      else\r\n        self.basepath = self.parent.basepath+'\/'+self.basename\r\n        self.basedirpath ||= self.parent.basepath+'\/'\r\n      end\r\n    end","code-length":92,"reference":"operations with path","result":"Set the basepath.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef commissions(options = {})\r\n      options = update_by_expire_time options\r\n      if commissions_not_latest?(options)\r\n        @rsqoot_commissions = get('commissions', options, SqootCommission)\r\n        @rsqoot_commissions = @rsqoot_commissions.commissions if @rsqoot_commissions\r\n      end\r\n      logger(uri: sqoot_query_uri, records: @rsqoot_commissions, type: 'commissions', opts: options)\r\n      @rsqoot_commissions\r\n    end","code-length":151,"reference":"Retrieve information of commissions based on the following parameters","result":"Fetch the commissions.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef leagues(opts={})\r\n      season = opts.fetch(:season) { Time.now.year }\r\n      json_response get(\"competitions\/?season=#{season}\")\r\n    end","code-length":55,"reference":"List all available leagues.","result":"Generate the code.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef match(*args, &block)\r\n      z = Module.new do \r\n        include Ov\r\n        extend self\r\n        def try(*args, &block)\r\n          let :anon_method, *args, &block\r\n        end\r\n        def otherwise(&block)\r\n          let :otherwise, &block\r\n        end\r\n        instance_eval &block\r\n      end\r\n      begin\r\n        z.anon_method(*args)\r\n      rescue Ov::NotImplementError => e \r\n        z.otherwise\r\n      end  \r\n    end","code-length":144,"reference":"Add `match` method, which work like `case` statement but for types","result":"Match an Ov object.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef fetch(column, *default_value, &default_block)\r\n      raise ArgumentError, \"Must only provide at max one default value or one default block\" if default_value.size > (block_given? ? 0 : 1)\r\n      index = case column\r\n        when Symbol then @table.index_for_accessor(column)\r\n        when String then @table.index_for_header(column)\r\n        when Integer then column\r\n        else raise InvalidColumnSpecifier, \"Invalid index type, expected Symbol, String or Integer, but got #{column.class}\"\r\n      end\r\n      @data.fetch(index, *default_value, &default_block)\r\n    end","code-length":166,"reference":"Tries to return the value of the column identified by index, corresponding accessor or header.","result":"Define the method for the data object.","score":[0.0612,0.0704]}
{"code":"# is used to<extra_id_0>\r\ndef at(column)\r\n      case column\r\n        when Symbol  then at_accessor(column)\r\n        when String  then at_header(column)\r\n        when Integer then at_index(column)\r\n        when Range   then @data[column]\r\n        else raise InvalidColumnSpecifier, \"Invalid index type, expected Symbol, String or Integer, but got #{column.class}\"\r\n      end\r\n    end","code-length":106,"reference":"Access a single cell by either index, index-range, accessor or header-name.","result":"Define the index.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef values_at(*columns)\r\n      result = []\r\n      columns.each do |column|\r\n        data = at(column)\r\n        if column.is_a?(Range)\r\n          result.concat(data) if data\r\n        else\r\n          result << data\r\n        end\r\n      end\r\n      result\r\n    end","code-length":91,"reference":"Access multiple values by either index, index-range, accessor or header-name.","result":"Return the values of the specified columns.","score":[0.1052,0.0515]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(name, *args, &block)\r\n      return super unless @table.accessors?\r\n      name              =~ \/^(\\w+)(=)?$\/\r\n      name_mod, assign  = $1, $2\r\n      index             = @table.index_for_accessor(name_mod)\r\n      arg_count         = assign ? 1 : 0\r\n      return super unless index\r\n      raise ArgumentError, \"Wrong number of arguments (#{args.size} for #{arg_count})\" if args.size > arg_count\r\n      if assign then\r\n        @data[index] = args.first\r\n      else\r\n        @data[index]\r\n      end\r\n    end","code-length":172,"reference":"Allow reading and writing cell values by their accessor name.","result":"Define the method_missing method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef authorize(auth = {})\r\n      @authentication ||= TaskMapper::Authenticator.new(auth)\r\n      auth = @authentication\r\n      if (auth.account.nil? and auth.subdomain.nil?) or auth.username.nil? or auth.password.nil?\r\n        raise \"Please provide at least an account (subdomain), username and password)\"\r\n      end\r\n      UnfuddleAPI.protocol = auth.protocol if auth.protocol?\r\n      UnfuddleAPI.account = auth.account || auth.subdomain\r\n      UnfuddleAPI.authenticate(auth.username, auth.password)\r\n    end","code-length":152,"reference":"Providers must define an authorize method.","result":"Authorize the task.","score":[0,0.0877]}
{"code":"# is used to<extra_id_0>\r\ndef routers(id = nil)\r\n      endpoint = \"routers\"\r\n      unless id.nil?\r\n        endpoint = endpoint + \"\/\" + id\r\n      end\r\n      return get_request(address(endpoint), @token)\r\n    end","code-length":66,"reference":"Get a list of a tenants routers","result":"Define the method.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef create_router(name, admin_state_up = true)\r\n      data = {\r\n        'router' =>{\r\n          'name' => name,\r\n          'admin_state_up' => admin_state_up,\r\n        }   \r\n      }\r\n      return post_request(address(\"routers\"), data, @token)\r\n    end","code-length":96,"reference":"Create a new router with a given name.","result":"Create a new router.","score":[0.2421,0.1974]}
{"code":"# is used to<extra_id_0>\r\ndef delete_router_interface(router, id, type)\r\n      data = case type\r\n        when 'port' then { 'port_id' => id }\r\n        when 'subnet' then { 'subnet_id' => id } \r\n        else raise \"Invalid Interface Type\"  \r\n        end\r\n      return put_request(address(\"routers\/\" + router + \"\/remove_router_interface\"), data, @token)\r\n    end","code-length":111,"reference":"Delete a connection between a subnet and router given either port or subnet ids.","result":"Delete an interface from a router.","score":[0.0605,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef where(method)\r\n      @complete, @result = nil, nil\r\n      z = find_or_next(method) { |method| \r\n        self.find{|m| m.eql?(method) }\r\n      }.find_or_next(method) { |method|\r\n        self.find{|m| m.eql0?(method) }\r\n      }.find_or_next(method) { |method|\r\n        self.find{|m| m.like?(method) }\r\n      }.find_or_next(method) {|method| \r\n        self.find{|m| m.like0?(method) }\r\n      }.get\r\n    end","code-length":180,"reference":"find in selffind in ancestorsfind typesfind any types","result":"Find the first occurrence of a method.","score":[0,0.0633]}
{"code":"# is used to<extra_id_0>\r\ndef load\r\n      config_files.each do |file|\r\n        config = YAML::load(File.open(file))\r\n        @config.merge! config\r\n      end\r\n    end","code-length":55,"reference":"load config from files","result":"Load the config files.","score":[0.3195,0.25]}
{"code":"# is used to<extra_id_0>\r\ndef providers(options = {})\r\n      options = update_by_expire_time options\r\n      query = options.delete(:query)\r\n      if providers_not_latest?(options)\r\n        @rsqoot_providers = get('providers', options, SqootProvider)\r\n        @rsqoot_providers = @rsqoot_providers.providers.map(&:provider) if @rsqoot_providers\r\n      end\r\n      result = query.present? ? query_providers(query) : @rsqoot_providers\r\n      logger(uri: sqoot_query_uri, records: result, type: 'providers', opts: options)\r\n      result\r\n    end","code-length":168,"reference":"Retrieve a list of providers base on the following parameters","result":"Return a list of providers.","score":[0.1821,0.3099]}
{"code":"# is used to<extra_id_0>\r\ndef categories(options = {})\r\n      options = update_by_expire_time options\r\n      query = options.delete(:query)\r\n      if categories_not_latest?(options)\r\n        @rsqoot_categories = get('categories', options, SqootCategory)\r\n        @rsqoot_categories = @rsqoot_categories.categories.map(&:category) if @rsqoot_categories\r\n      end\r\n      result = query.present? ? query_categories(query) : @rsqoot_categories\r\n      logger(uri: sqoot_query_uri, records: result, type: 'categories', opts: options)\r\n      result\r\n    end","code-length":168,"reference":"Retrieve a list of categories base on the following parameters","result":"Query the Sqoot API.","score":[0.0713,0.0532]}
{"code":"# is used to<extra_id_0>\r\ndef challah_role\r\n      unless included_modules.include?(InstanceMethods)\r\n        include InstanceMethods\r\n        extend ClassMethods\r\n      end\r\n      class_eval do\r\n","code-length":54,"reference":"This method sets up the +Role+ class with all baked in methods.","result":"Define the challah role.","score":[0.0432,0.0446]}
{"code":"# is used to<extra_id_0>\r\ndef check_for_upgrade\r\n      if plan_id_changed?\r\n        old_plan = Plan.find(plan_id_was) if plan_id_was.present?\r\n        self.upgraded = true if old_plan.nil? || old_plan.order < plan.order\r\n      end\r\n    end","code-length":85,"reference":"def nil_if_blank   self.trial_end = nil if self.trial_end.blank? end","result":"Check for upgrade.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef method_missing(name, *args, &block)\r\n      obj = __getobj__\r\n      __substitute_self__(obj.__send__(name, *args, &block), obj)\r\n    end","code-length":60,"reference":"if chainable method or returns \"self\" for some other reason, return this proxy instead","result":"Substitute self.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef deals(options = {})\r\n      options = update_by_expire_time options\r\n      if deals_not_latest?(options)\r\n        uniq = !!options.delete(:uniq)\r\n        @rsqoot_deals = get('deals', options, SqootDeal) || []\r\n        @rsqoot_deals = @rsqoot_deals.deals.map(&:deal) unless @rsqoot_deals.empty?\r\n        @rsqoot_deals = uniq_deals(@rsqoot_deals) if uniq\r\n      end\r\n      logger(uri: sqoot_query_uri, records: @rsqoot_deals, type: 'deals', opts: options)\r\n      @rsqoot_deals\r\n    end","code-length":200,"reference":"Retrieve a list of deals based on the following parameters","result":"Query the database.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef deal(id, options = {})\r\n      options = update_by_expire_time options\r\n      if deal_not_latest?(id)\r\n        @rsqoot_deal = get(\"deals\/#{id}\", options, SqootDeal)\r\n        @rsqoot_deal = @rsqoot_deal.deal if @rsqoot_deal\r\n      end\r\n      logger(uri: sqoot_query_uri, records: [@rsqoot_deal], type: 'deal', opts: options)\r\n      @rsqoot_deal\r\n    end","code-length":153,"reference":"Retrieve a deal by id","result":"Query the database.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef total_sqoot_deals(options = {})\r\n      @total_deals  ||= []\r\n      @cached_pages ||= []\r\n      page = options[:page] || 1\r\n      check_query_change options\r\n      unless page_cached? page\r\n        @total_deals += deals(options)\r\n        @total_deals.uniq!\r\n        @cached_pages << page.to_s\r\n        @cached_pages.uniq!\r\n      end\r\n      @total_deals\r\n    end","code-length":135,"reference":"Auto Increment for deals query.","result":"Calculate total total of sqoot deals.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef uniq_deals(deals = [])\r\n      titles = deals.map(&:title).uniq\r\n      titles.map do |title|\r\n        deals.map do |deal|\r\n          deal if deal.try(:title) == title\r\n        end.compact.last\r\n      end.flatten\r\n    end","code-length":88,"reference":"Uniq deals from Sqoot, because there are some many duplicated deals with different ids","result":"Generate a unique deals list.","score":[0.0397,0.0382]}
{"code":"# is used to<extra_id_0>\r\ndef load_cookies(file)\r\n      now = ::Time.now\r\n      io = case file\r\n      when String\r\n        open(file)\r\n      else\r\n        file\r\n      end\r\n      io.each_line do |line|\r\n        line.chomp!\r\n        line.gsub!(\/\r\n        fields = line.split(\"\\t\")\r\n        next if fields.length != 7\r\n        name, value, domain, for_domain, path, secure, version = fields[5], fields[6], \r\n          fields[0], (fields[1] == \"TRUE\"), fields[2], (fields[3] == \"TRUE\"), 0\r\n        expires_seconds = fields[4].to_i\r\n        expires = (expires_seconds == 0) ? nil : ::Time.at(expires_seconds)\r\n        next if expires and (expires < now)\r\n        cookies.add(name, value, domain: domain, path: path, expires: expires, secure: secure)\r\n      end\r\n      io.close if String === file\r\n      self\r\n    end","code-length":264,"reference":"Read cookies from Mozilla cookies.txt-style IO stream\n\n @param file [IO,String]","result":"Load cookies from a file.","score":[0.125,0.1974]}
{"code":"# is used to<extra_id_0>\r\ndef dump_cookies(file)\r\n      io = case file\r\n      when String\r\n        open(file, \"w\")\r\n      else\r\n        file\r\n      end\r\n      cookies.to_a.each do |cookie|\r\n        io.puts([\r\n          cookie[:domain],\r\n          \"FALSE\",\r\n          cookie[:path],\r\n          cookie[:secure] ? \"TRUE\" : \"FALSE\",\r\n          cookie[:expires].to_i.to_s,\r\n          cookie[:name],\r\n          cookie[:value]\r\n        ].join(\"\\t\"))\r\n      end\r\n      io.close if String === file\r\n      self\r\n    end","code-length":167,"reference":"Write cookies to Mozilla cookies.txt-style IO stream\n\n @param file [IO,String]","result":"Dump cookies to a file.","score":[0.125,0.1974]}
{"code":"# is used to<extra_id_0>\r\ndef set2(selector, value=nil)\r\n      elem = element(xpath: selector).to_subtype\r\n      case elem\r\n      when Watir::Radio\r\n        elem.set\r\n      when Watir::Select\r\n        elem.select value\r\n      when Watir::Input\r\n        elem.set value\r\n      when Watir::TextArea\r\n        elem.set value\r\n      else\r\n        elem.click\r\n      end\r\n    end","code-length":120,"reference":"quick set value.","result":"Set the value of a radio or radio radio.","score":[0,0.1389]}
{"code":"# is used to<extra_id_0>\r\ndef update_by_expire_time(options = {})\r\n      @expired_in = options[:expired_in] if options[:expired_in].present?\r\n      time = Time.now.to_i \/ expired_in.to_i\r\n      options.merge(expired_in: time)\r\n    end","code-length":82,"reference":"Add expired time functionality to this gem","result":"Update the expire time.","score":[0,0.0746]}
{"code":"# is used to<extra_id_0>\r\ndef get(options={})\r\n    uri = new_uri\r\n    params = merge_params(options)\r\n    uri.query = URI.encode_www_form(params)\r\n    Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.scheme == 'https') do |http|\r\n      request = Net::HTTP::Get.new(uri)\r\n      response = http.request(request)\r\n      unless response.is_a?(Net::HTTPSuccess)\r\n        raise \"#{response.code} #{response.message}\\n#{response.body}\"\r\n      end\r\n      return response.body\r\n    end\r\n  end","code-length":165,"reference":"Make a GET API call with the current path value and ","result":"Generate the code.","score":[0.0284,0.049]}
{"code":"# is used to<extra_id_0>\r\ndef images(id, tenant_id)\r\n      if id.nil?\r\n        return get_request(address(tenant_id, \"images\/detail\"), @token)\r\n      else\r\n        return get_request(address(tenant_id, \"images\/\" + id), @token)\r\n      end\r\n    end","code-length":84,"reference":"No ID provided - Lists details for available images.","result":"Get the images.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef image_create(name, disk_format, container_format, create_image, tenant_id)\r\n      data = { \r\n        :name => name,\r\n        :disk_format => disk_format,\r\n        :container_format => container_format\r\n      }\r\n      unless create_image.nil?\r\n        data[:create_image] = create_image\r\n      end\r\n      post_request(address(tenant_id, \"images\"), data, @token)\r\n    end","code-length":126,"reference":"Registers a virtual machine image.","result":"Create an image.","score":[0.2096,0.1042]}
{"code":"# is used to<extra_id_0>\r\ndef replace_memberships(id, memberships, tenant_id)\r\n      data = {\r\n        :memberships => memberships\r\n      }\r\n      put_request(address(tenant_id, \"images\/\" + id + \"\/members\"), data, @token)\r\n    end","code-length":75,"reference":"Replaces the membership list for an image.","result":"Replace memberships in images.","score":[0,0.1493]}
{"code":"# is used to<extra_id_0>\r\ndef add_member(id, member_id, can_share, tenant_id)\r\n      if can_share.nil?\r\n        data = {\r\n          :member => {:can_share => false}\r\n        }\r\n      else\r\n        data = {\r\n          :member => {:can_share => can_share}\r\n        }\r\n      end\r\n      put_request(address(tenant_id, \"images\/\" + id + \"\/members\/\" + member_id), data, @token)\r\n    end","code-length":130,"reference":"Adds a member to an image.","result":"Add a member to an image.","score":[0.8034,0.9977]}
{"code":"# is used to<extra_id_0>\r\ndef mkdir(dir, owner: nil, mode: nil)\r\n      FileUtils.mkdir_p(dir, verbose: verbose?)\r\n      chown(dir, owner) if owner\r\n      chmod(dir, mode) if mode\r\n    end","code-length":64,"reference":"Like mkdir -p +dir+.","result":"Create a directory.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef cp(src, dst, mkdir: false, owner: nil, mode: nil)\r\n      mkdir_if_necessary(File.dirname(dst)) if mkdir\r\n      FileUtils.cp_r(src, dst, preserve: true, verbose: verbose?)\r\n      chown(dst, owner) if owner && !File.symlink?(dst)\r\n      chmod(dst, mode) if mode\r\n    end","code-length":103,"reference":"Like cp -pr +src+ +dst.","result":"Copy directories.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef mv(src, dst, mkdir: false)\r\n      mkdir_if_necessary(File.dirname(dst)) if mkdir\r\n      FileUtils.mv(src, dst, verbose: verbose?)\r\n    end","code-length":57,"reference":"Like mv +src+ +dst.","result":"Create a new file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef ln(src, dst)\r\n      FileUtils.ln_sf(src, dst, verbose: verbose?)\r\n    rescue Errno::EEXIST => e\r\n      raise e if !(File.symlink?(dst) && src == File.readlink(dst))\r\n    end","code-length":72,"reference":"Like ln -sf +src+ +dst.","result":"Create a new file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef chmod(file, mode)\r\n      return if File.stat(file).mode == mode\r\n      FileUtils.chmod(mode, file, verbose: verbose?)\r\n    end","code-length":50,"reference":"Like chmod mode file.","result":"Escape the line.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef rm_and_mkdir(dir)\r\n      raise \"don't do this\" if dir == \"\"\r\n      FileUtils.rm_rf(dir, verbose: verbose?)\r\n      mkdir(dir)\r\n    end","code-length":58,"reference":"printed out if verbose?.","result":"Remove and create directories.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef copy_metadata(src, dst)\r\n      stat = File.stat(src)\r\n      File.chmod(stat.mode, dst)\r\n      File.utime(stat.atime, stat.mtime, dst)\r\n    end","code-length":66,"reference":"Copy mode, atime and mtime from +src+ to +dst+.","result":"Copy metadata.","score":[0.0151,0.0602]}
{"code":"# is used to<extra_id_0>\r\ndef atomic_write(path)\r\n      tmp = Tempfile.new(File.basename(path))\r\n      yield(tmp)\r\n      tmp.close\r\n      chmod(tmp.path, 0o644)\r\n      mv(tmp.path, path)\r\n    ensure\r\n      rm_if_necessary(tmp.path)\r\n    end","code-length":91,"reference":"Atomically write to +path+. An open temp file is yielded.","result":"Ensure that the file.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef handle_requests\r\n      until @requestmq.empty?\r\n        request = @requestmq.deq(true)\r\n        begin\r\n          request.response = @app.call(request.env)\r\n        rescue Exception => e\r\n          request.exception = e\r\n        ensure\r\n          body = request.response.try(:last)\r\n          body.close  if body.respond_to? :close\r\n        end\r\n      end\r\n    end","code-length":117,"reference":"Should be run by another thread - respond to all queued requests","result":"Handle exceptions.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef configfile_hash\r\n      config  = {}\r\n      begin\r\n        json    = File.read(configfile)\r\n        config  = JSON.parse(json)\r\n      rescue Errno::ENOENT\r\n        @logger.debug \"#{configfile} does not exist\"\r\n        @force_save = true\r\n      rescue JSON::ParserError\r\n        @logger.debug \"JSON parse error in #{configfile}\"\r\n        @force_save = true\r\n      end\r\n      config\r\n    end","code-length":128,"reference":"return a hash of the configfile or empty hash if error encountered","result":"Generate the hash of config files.","score":[0.1112,0.1316]}
{"code":"# is used to<extra_id_0>\r\ndef email_addresses(text)\r\n      text.gsub(@regex[:mail]) do\r\n        text = $&\r\n        if auto_linked?($`, $')\r\n          text\r\n        else\r\n          display_text = (block_given?) ? yield(text) : text\r\n          \"<a href='mailto:#{text}'>#{display_text}<\/a>\"\r\n        end\r\n      end\r\n    end","code-length":108,"reference":"Turns all email addresses into clickable links.","result":"Match email addresses.","score":[0.1076,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef plural(rule, replacement)\r\n      @uncountables.delete(rule) if rule.is_a?(String)\r\n      @uncountables.delete(replacement)\r\n      @plurals.insert(0, [rule, replacement])\r\n    end","code-length":70,"reference":"Specifies a new pluralization rule and its replacement.","result":"Define the pluralization rules.","score":[0.1175,0.0658]}
{"code":"# is used to<extra_id_0>\r\ndef singular(rule, replacement)\r\n      @uncountables.delete(rule) if rule.is_a?(String)\r\n      @uncountables.delete(replacement)\r\n      @singulars.insert(0, [rule, replacement])\r\n    end","code-length":70,"reference":"Specifies a new singularization rule and its replacement.","result":"Replace singular.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef irregular(singular, plural)\r\n      @uncountables.delete(singular)\r\n      @uncountables.delete(plural)\r\n      if singular[0,1].upcase == plural[0,1].upcase\r\n        plural(Regexp.new(\"(#{singular[0,1]})#{singular[1..-1]}$\", \"i\"), '\\1' + plural[1..-1])\r\n        singular(Regexp.new(\"(#{plural[0,1]})#{plural[1..-1]}$\", \"i\"), '\\1' + singular[1..-1])\r\n      else\r\n        plural(Regexp.new(\"#{singular[0,1].upcase}(?i)#{singular[1..-1]}$\"), plural[0,1].upcase + plural[1..-1])\r\n        plural(Regexp.new(\"#{singular[0,1].downcase}(?i)#{singular[1..-1]}$\"), plural[0,1].downcase + plural[1..-1])\r\n        singular(Regexp.new(\"#{plural[0,1].upcase}(?i)#{plural[1..-1]}$\"), singular[0,1].upcase + singular[1..-1])\r\n        singular(Regexp.new(\"#{plural[0,1].downcase}(?i)#{plural[1..-1]}$\"), singular[0,1].downcase + singular[1..-1])\r\n      end\r\n    end","code-length":352,"reference":"Specifies a new irregular that applies to both pluralization and singularization at the same time.","result":"Define the irregular form of the plural form.","score":[0.0688,0.1049]}
{"code":"# is used to<extra_id_0>\r\ndef execute\r\n      raise errors.to_sentences unless valid?\r\n      result = false\r\n      mutex = Mutagem::Mutex.new('revenc.lck')\r\n      lock_successful = mutex.execute do\r\n        result = system_cmd(cmd)\r\n      end\r\n      raise \"action failed, lock file present\" unless lock_successful\r\n      result\r\n    end","code-length":98,"reference":"run the action if valid and return true if successful","result":"Execute the command.","score":[0.0396,0.0538]}
{"code":"# is used to<extra_id_0>\r\ndef output\r\n      opts = options\r\n      if opts.format\r\n        FileUtils.mkdir_p opts.output_dir\r\n        formatted_output\r\n      end\r\n      @results.clear\r\n    end","code-length":58,"reference":"Output the results based on the requested output format","result":"Generate the output.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef run\r\n      while @jobs.length > 0 do\r\n        @current_job = @jobs.pop\r\n        @current_rate = @current_job.high_rate.to_i\r\n        httperf true\r\n        (@current_job.low_rate.to_i..@current_job.high_rate.to_i).\r\n            step(@current_job.rate_step.to_i) do |rate|\r\n          @current_rate = rate\r\n          httperf\r\n        end\r\n        output\r\n      end\r\n    end","code-length":141,"reference":"Run httperf from low_rate to high_rate, stepping by rate_step","result":"Run the jobs.","score":[0.0553,0.0595]}
{"code":"# is used to<extra_id_0>\r\ndef authenticate(username, password, tenant = nil)\r\n                  data = {\r\n                          \"auth\" => { \r\n                                  \"passwordCredentials\" => { \r\n                                          \"username\" => username, \r\n                                          \"password\" => password \r\n                                  } \r\n                          } \r\n                  }\r\n                  unless tenant.nil?\r\n                          data[\"auth\"][\"tenantName\"] = tenant\r\n                  end\r\n                  @data = post_request(address(\"\/tokens\"), data, @token)\r\n          end","code-length":125,"reference":"Authenticate via keystone, unless a token and tenant are defined then a unscoped token is returned with all associated data and stored in the ","result":"Authenticate the user.","score":[0.0004,0.0457]}
{"code":"# is used to<extra_id_0>\r\ndef add_to_services(name, type, description)\r\n                  data = {\r\n                          'OS-KSADM:service' => {\r\n                                   'name' => name,\r\n                                   'type' => type,\r\n                                   'description' => description\r\n                          }\r\n                  }\r\n                  return post_request(address(\"\/OS-KSADM\/services\"), data, token())\r\n          end","code-length":109,"reference":"Add a service to the keystone services directory","result":"Add services to the KS.","score":[0.2218,0.4099]}
{"code":"# is used to<extra_id_0>\r\ndef add_endpoint(region, service_id, publicurl, adminurl, internalurl)\r\n                  data = {\r\n                          'endpoint' => {\r\n                                  'region' => region,\r\n                                  'service_id' => service_id,\r\n                                  'publicurl' => publicurl,\r\n                                  'adminurl' => adminurl,\r\n                                  'internalurl' => internalurl\r\n                          }\r\n                  }\r\n                  return post_request(address(\"\/endpoints\"), data, token())\r\n          end","code-length":127,"reference":"Add an endpoint list","result":"Add an endpoint to the service.","score":[0.3976,0.7011]}
{"code":"# is used to<extra_id_0>\r\ndef get_endpoints(token = nil)\r\n                  if token.nil?\r\n                          return get_request(address(\"\/endpoints\"), token())\r\n                  else\r\n                          return get_request(address(\"\/tokens\/#{token}\/endpoints\"), token())\r\n                  end\r\n          end","code-length":74,"reference":"Get the endpoint list","result":"Get the endpoints.","score":[0.4137,0.4808]}
{"code":"# is used to<extra_id_0>\r\ndef disable_method(method_name, message = nil)\r\n      disabled_methods[method_name] ||= DisabledMethod.new(self, method_name, message)\r\n      disabled_methods[method_name].disable!\r\n    end","code-length":64,"reference":"Disables an instance method.","result":"Disable a method.","score":[0.2925,0.2564]}
{"code":"# is used to<extra_id_0>\r\ndef to_proc\r\n      disabled_method = self\r\n      Proc.new do |*args, &block|\r\n        disabled_method.execute(self, *args, &block)\r\n      end\r\n    end","code-length":60,"reference":"Returns a Proc that acts as a replacement for the disabled method.","result":"Disable the method.","score":[0.0242,0.1351]}
{"code":"# is used to<extra_id_0>\r\ndef execute(object, *args, &block)\r\n      if disabled?\r\n        raise NoMethodError, message\r\n      else\r\n        object.send(aliased_name, *args, &block)\r\n      end\r\n    end","code-length":65,"reference":"The replacement for the original method.","result":"Execute the method.","score":[0.1786,0.1754]}
{"code":"# is used to<extra_id_0>\r\ndef alias_method!\r\n      klass.send(:define_method, replacement_name, &self)\r\n      klass.send(:alias_method, aliased_name, method_name)\r\n      klass.send(:alias_method, method_name, replacement_name)\r\n    end","code-length":74,"reference":"Replaces the original implementation of the method with an implementation that allows disabling.","result":"Replace the method.","score":[0.0146,0.0833]}
{"code":"# is used to<extra_id_0>\r\ndef secret_to_public(secret, form=:byte)\r\n      publickey = p_secret_to_public( change_argument_format(secret, form) )\r\n      return change_result_format( publickey, form )\r\n    end","code-length":66,"reference":"calculate public key from secret","result":"Generate the publickey.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef point_equal(pa, pb)\r\n      return false if (pa[0] * pb[2] - pb[0] * pa[2]) % @@p != 0\r\n      return false if (pa[1] * pb[2] - pb[1] * pa[2]) % @@p != 0\r\n      return true\r\n    end","code-length":89,"reference":"return point A == point B","result":"Compare two points.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef recover_x(y, sign)\r\n      return nil if y >= @@p\r\n      x2 = (y*y-1) * modp_inv(@@d*y*y+1)\r\n      if x2.equal? 0 then\r\n        unless sign.equal? 0 then\r\n          return nil\r\n        else\r\n          return 0\r\n        end\r\n      end\r\n      x = pow_mod(x2 , ((@@p+3) \/ 8) , @@p)\r\n      x = x * @@modp_sqrt_m1 % @@p unless ((x*x - x2) % @@p).equal? 0\r\n      return nil unless ((x*x - x2) % @@p).equal? 0\r\n      x = @@p - x  unless (x & 1).equal? sign\r\n      return x\r\n    end","code-length":207,"reference":"region point manipulation ","result":"Recover x from y.","score":[0,0.0]}
{"code":"# is used to<extra_id_0>\r\ndef point_decompress(s)\r\n      raise ArgumentError , \"Invalid input length for decompression\" unless s.length.equal? 32\r\n      y = int_form_bytes(s)\r\n      sign = y >> 255\r\n      y &= (1 << 255) - 1\r\n      x = recover_x(y, sign)\r\n      if x.nil? then\r\n        return nil\r\n      else\r\n        return [x, y, 1, x*y % @@p]\r\n      end\r\n    end","code-length":129,"reference":"decompress point that is compressed into 32bytes","result":"Decompress a point.","score":[0,0.0758]}
{"code":"# is used to<extra_id_0>\r\ndef p_secret_to_public(secret)\r\n      expanded = secret_expand(secret)\r\n      a = expanded.first\r\n      return point_compress(point_mul(a, @@G))\r\n    end","code-length":60,"reference":"public_keyKey = aG \"a\" is generated form a secret","result":"Convert secret to public.","score":[0.0915,0.0588]}
{"code":"# is used to<extra_id_0>\r\ndef part(name)\r\n      parts.select {|p| p.name.downcase == name.to_s.downcase }.first\r\n    end","code-length":46,"reference":"get part by its name param ","result":"Define a part.","score":[0,0.0]}
