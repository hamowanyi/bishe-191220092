{"code":"def sina_xml_to_url_list(xml_data):\r\n    rawurl = []\r\n    dom = parseString(xml_data)\r\n    for node in dom.getElementsByTagName('durl'):\r\n        url = node.getElementsByTagName('url')[0]\r\n        rawurl.append(url.childNodes[0].data)\r\n    return rawurl\r\n\r\n\"\"\" This function is used to","code-length":79,"reference":"Convert XML to URL List.","result":"Is used to get the list of all the urls in the database .","score":[0.0756,0.1695]}
{"code":"def dailymotion_download(url, output_dir='.', merge=True, info_only=False, **kwargs):\r\n    html = get_content(rebuilt_url(url))\r\n    info = json.loads(match1(html, r'qualities\":({.+?}),\"'))\r\n    title = match1(html, r'\"video_title\"\\s*:\\s*\"([^\"]+)\"') or \\\r\n            match1(html, r'\"title\"\\s*:\\s*\"([^\"]+)\"')\r\n    title = unicodize(title)\r\n    for quality in ['1080','720','480','380','240','144','auto']:\r\n        try:\r\n            real_url = info[quality][1][\"url\"]\r\n            if real_url:\r\n                break\r\n        except KeyError:\r\n            pass\r\n    mime, ext, size = url_info(real_url)\r\n    print_info(site_info, title, mime, size)\r\n    if not info_only:\r\n        download_urls([real_url], title, ext, size, output_dir=output_dir, merge=merge)\r\n\r\n\"\"\" This function is used to","code-length":235,"reference":"Downloads Dailymotion videos by URL.","result":"Is used to download the videos from the given url .","score":[0.0979,0.1786]}
{"code":"def sina_download(url, output_dir='.', merge=True, info_only=False, **kwargs):\r\n    if 'news.sina.com.cn\/zxt' in url:\r\n        sina_zxt(url, output_dir=output_dir, merge=merge, info_only=info_only, **kwargs)\r\n        return\r\n    vid = match1(url, r'vid=(\\d+)')\r\n    if vid is None:\r\n        video_page = get_content(url)\r\n        vid = hd_vid = match1(video_page, r'hd_vid\\s*:\\s*\\'([^\\']+)\\'')\r\n        if hd_vid == '0':\r\n            vids = match1(video_page, r'[^\\w]vid\\s*:\\s*\\'([^\\']+)\\'').split('|')\r\n            vid = vids[-1]\r\n    if vid is None:\r\n        vid = match1(video_page, r'vid:\"?(\\d+)\"?')\r\n    if vid:\r\n        sina_download_by_vid(vid, output_dir=output_dir, merge=merge, info_only=info_only)\r\n    else:\r\n        vkey = match1(video_page, r'vkey\\s*:\\s*\"([^\"]+)\"')\r\n        if vkey is None:\r\n            vid = match1(url, r'\r\n            sina_download_by_vid(vid, output_dir=output_dir, merge=merge, info_only=info_only)\r\n            return\r\n        title = match1(video_page, r'title\\s*:\\s*\"([^\"]+)\"')\r\n        sina_download_by_vkey(vkey, title=title, output_dir=output_dir, merge=merge, info_only=info_only)\r\n\r\n\"\"\" This function is used to","code-length":396,"reference":"Downloads Sina videos by URL.","result":"Is used to download the content of a video.","score":[0,0.0926]}
{"code":"def sprint(text, *colors):\r\n    return \"\\33[{}m{content}\\33[{}m\".format(\";\".join([str(color) for color in colors]), RESET, content=text) if IS_ANSI_TERMINAL and colors else text\r\n\r\n\"\"\" This function is used to","code-length":66,"reference":"Format text with color or other effects into ANSI escaped string.","result":"Is used to print the text in a terminal.","score":[0.0976,0.0463]}
{"code":"def print_log(text, *colors):\r\n    sys.stderr.write(sprint(\"{}: {}\".format(script_name, text), *colors) + \"\\n\")\r\n\r\n\"\"\" This function is used to","code-length":45,"reference":"Print a log message to standard error.","result":"Is used to print the log file.","score":[0.1921,0.2143]}
{"code":"def e(message, exit_code=None):\r\n    print_log(message, YELLOW, BOLD)\r\n    if exit_code is not None:\r\n        sys.exit(exit_code)\r\n\r\n\"\"\" This function is used to","code-length":50,"reference":"Print an error log message.","result":"The main function.","score":[0,0.0]}
{"code":"def wtf(message, exit_code=1):\r\n    print_log(message, RED, BOLD)\r\n    if exit_code is not None:\r\n        sys.exit(exit_code)\r\n\r\n\"\"\" This function is used to","code-length":50,"reference":"What a Terrible Failure!","result":"Is used to send a message to the user.","score":[0.1219,0.1111]}
{"code":"def detect_os():\r\n    syst = system().lower()\r\n    os = 'unknown'\r\n    if 'cygwin' in syst:\r\n        os = 'cygwin'\r\n    elif 'darwin' in syst:\r\n        os = 'mac'\r\n    elif 'linux' in syst:\r\n        os = 'linux'\r\n        try:\r\n            with open('\/proc\/version', 'r') as f:\r\n                if 'microsoft' in f.read().lower():\r\n                    os = 'wsl'\r\n        except: pass\r\n    elif 'windows' in syst:\r\n        os = 'windows'\r\n    elif 'bsd' in syst:\r\n        os = 'bsd'\r\n    return os\r\n\r\n\"\"\" This function is used to","code-length":145,"reference":"Detect operating system.","result":"Is used to determine the OS version from the system.","score":[0.1086,0.1351]}
{"code":"def vimeo_download_by_channel(url, output_dir='.', merge=False, info_only=False, **kwargs):\r\n    channel_id = match1(url, r'http:\/\/vimeo.com\/channels\/(\\w+)')\r\n    vimeo_download_by_channel_id(channel_id, output_dir, merge, info_only, **kwargs)\r\n\r\n\"\"\" This function is used to","code-length":95,"reference":"str->None","result":"Is used to download the vimeo videos .","score":[0,0.0]}
{"code":"def ckplayer_get_info_by_xml(ckinfo):\r\n    e = ET.XML(ckinfo)\r\n    video_dict = {'title': '',\r\n                  'links': [],\r\n                  'size': 0,\r\n                  'flashvars': '',}\r\n    dictified = dictify(e)['ckplayer']\r\n    if 'info' in dictified:\r\n        if '_text' in dictified['info'][0]['title'][0]:\r\n            video_dict['title'] = dictified['info'][0]['title'][0]['_text'].strip()\r\n_text' in dictified['video'][0]['size'][0]:\r\n        video_dict['size'] = sum([int(i['size'][0]['_text']) for i in dictified['video']])\r\n    if '_text' in dictified['video'][0]['file'][0]:\r\n        video_dict['links'] = [i['file'][0]['_text'].strip() for i in dictified['video']]\r\n    if '_text' in dictified['flashvars'][0]:\r\n        video_dict['flashvars'] = dictified['flashvars'][0]['_text'].strip()\r\n    return video_dict\r\n\r\n\"\"\" This function is used to","code-length":254,"reference":"Information for CKPlayer API content.","result":"Is used to get the video info from the xml file .","score":[0,0.0]}
{"code":"def get_video_url_from_video_id(video_id):\r\n    data = [\"\"] * 256\r\n    for index, _ in enumerate(data):\r\n        t = index\r\n        for i in range(8):\r\n            t = -306674912 ^ unsigned_right_shitf(t, 1) if 1 & t else unsigned_right_shitf(t, 1)\r\n        data[index] = t\r\n    def tmp():\r\n        rand_num = random.random()\r\n        path = \"\/video\/urls\/v\/1\/toutiao\/mp4\/{video_id}?r={random_num}\".format(video_id=video_id,\r\n                                                                              random_num=str(rand_num)[2:])\r\n        e = o = r = -1\r\n        i, a = 0, len(path)\r\n        while i < a:\r\n            e = ord(path[i])\r\n            i += 1\r\n            if e < 128:\r\n                r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ e)]\r\n            else:\r\n                if e < 2048:\r\n                    r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (192 | e >> 6 & 31))]\r\n                    r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | 63 & e))]\r\n                else:\r\n                    if 55296 <= e < 57344:\r\n                        e = (1023 & e) + 64\r\n                        i += 1\r\n                        o = 1023 & t.url(i)\r\n                        r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (240 | e >> 8 & 7))]\r\n                        r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | e >> 2 & 63))]\r\n                        r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | o >> 6 & 15 | (3 & e) << 4))]\r\n                        r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | 63 & o))]\r\n                    else:\r\n                        r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (224 | e >> 12 & 15))]\r\n                        r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | e >> 6 & 63))]\r\n                        r = unsigned_right_shitf(r, 8) ^ data[255 & (r ^ (128 | 63 & e))]\r\n        return \"https:\/\/ib.365yg.com{path}&s={param}\".format(path=path, param=unsigned_right_shitf(r ^ -1, 0))\r\n    while 1:\r\n        url = tmp()\r\n        if url.split(\"=\")[-1][0] != \"-\":\r\n            return url\r\n\r\n\"\"\" This function is used to","code-length":647,"reference":"Splicing URLs according to video ID to get video details","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"def get_mgtv_real_url(url):\r\n        content = loads(get_content(url))\r\n        m3u_url = content['info']\r\n        split = urlsplit(m3u_url)\r\n                base_url = \"{scheme}:\/\/{netloc}{path}\/\".format(scheme = split[0],\r\n                                                      netloc = split[1],\r\n                                                      path = dirname(split[2]))\r\n        content = get_content(content['info'])\r\n        segment_list = []\r\n        segments_size = 0\r\n        for i in content.split():\r\n            if not i.startswith('\r\n            elif i.startswith('\r\n                segments_size += int(i[i.rfind(':')+1:])\r\n        return m3u_url, segments_size, segment_list\r\n\r\n\"\"\" This function is used to","code-length":169,"reference":"Give you the real URLs.","result":"Is used to get the m3u file from the m3u_url .","score":[0.0979,0.0893]}
{"code":"def legitimize(text, os=detect_os()):\r\n    text = text.translate({\r\n        0: None,\r\n        ord('\/'): '-',\r\n        ord('|'): '-',\r\n    })\r\n    if os == 'windows' or os == 'cygwin' or os == 'wsl':\r\n        text = text.translate({\r\n            ord(':'): '-',\r\n            ord('*'): '-',\r\n            ord('?'): '-',\r\n            ord('\\\\'): '-',\r\n            ord('\\\"'): '\\'',\r\n            ord('+'): '-',\r\n            ord('<'): '-',\r\n            ord('>'): '-',\r\n            ord('['): '(',\r\n            ord(']'): ')',\r\n            ord('\\t'): ' ',\r\n        })\r\n    else:\r\n        if os == 'mac':\r\n            text = text.translate({\r\n                ord(':'): '-',\r\n            })\r\n        if text.startswith(\".\"):\r\n            text = text[1:]\r\n    text = text[:80]\r\n    return text\r\n\r\n\"\"\" This function is used to","code-length":186,"reference":"Converts a string to a valid filename.","result":"Is used to convert a text string to a number.","score":[0.2403,0.663]}
{"code":"def cbs_download(url, output_dir='.', merge=True, info_only=False, **kwargs):\r\n    html = get_content(url)\r\n    pid = match1(html, r'video\\.settings\\.pid\\s*=\\s*\\'([^\\']+)\\'')\r\n    title = match1(html, r'video\\.settings\\.title\\s*=\\s*\\\"([^\\\"]+)\\\"')\r\n    theplatform_download_by_pid(pid, title, output_dir=output_dir, merge=merge, info_only=info_only)\r\n\r\n\"\"\" This function is used to","code-length":127,"reference":"Downloads CBS videos by URL.","result":"Is used to download the videos from the page_url .","score":[0.1086,0.1818]}
{"code":"def download(self, **kwargs):\r\n        if 'json_output' in kwargs and kwargs['json_output']:\r\n            json_output.output(self)\r\n        elif 'info_only' in kwargs and kwargs['info_only']:\r\n            if 'stream_id' in kwargs and kwargs['stream_id']:\r\n                stream_id = kwargs['stream_id']\r\n                if 'index' not in kwargs:\r\n                    self.p(stream_id)\r\n                else:\r\n                    self.p_i(stream_id)\r\n            else:\r\n                if 'index' not in kwargs:\r\n                    self.p([])\r\n                else:\r\n                    stream_id = self.streams_sorted[0]['id'] if 'id' in self.streams_sorted[0] else self.streams_sorted[0]['itag']\r\n                    self.p_i(stream_id)\r\n        else:\r\n            if 'stream_id' in kwargs and kwargs['stream_id']:\r\n                stream_id = kwargs['stream_id']\r\n            else:\r\n                stream_id = self.streams_sorted[0]['id'] if 'id' in self.streams_sorted[0] else self.streams_sorted[0]['itag']\r\n            if 'index' not in kwargs:\r\n                self.p(stream_id)\r\n            else:\r\n                self.p_i(stream_id)\r\n            if stream_id in self.streams:\r\n                urls = self.streams[stream_id]['src']\r\n                ext = self.streams[stream_id]['container']\r\n                total_size = self.streams[stream_id]['size']\r\n            else:\r\n                urls = self.dash_streams[stream_id]['src']\r\n                ext = self.dash_streams[stream_id]['container']\r\n                total_size = self.dash_streams[stream_id]['size']\r\n            if not urls:\r\n                log.wtf('[Failed] Cannot extract video source.')\r\n                        download_url_ffmpeg(urls[0], self.title, 'mp4', output_dir=kwargs['output_dir'], merge=kwargs['merge'], stream=False)\r\n            if not kwargs['caption']:\r\n                print('Skipping captions.')\r\n                return\r\n            for lang in self.caption_tracks:\r\n                filename = '%s.%s.srt' % (get_filename(self.title), lang)\r\n                print('Saving %s ... ' % filename, end=\"\", flush=True)\r\n                srt = self.caption_tracks[lang]\r\n                with open(os.path.join(kwargs['output_dir'], filename),\r\n                          'w', encoding='utf-8') as x:\r\n                    x.write(srt)\r\n                print('Done.')\r\n\r\n\"\"\" This function is used to","code-length":571,"reference":"Override the original one","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"def acfun_download_by_vid(vid, title, output_dir='.', merge=True, info_only=False, **kwargs):\r\n    info = json.loads(get_content('http:\/\/www.acfun.cn\/video\/getVideo.aspx?id=' + vid))\r\n    sourceType = info['sourceType']\r\n    if 'sourceId' in info: sourceId = info['sourceId']\r\n    if sourceType == 'sina':\r\n        sina_download_by_vid(sourceId, title, output_dir=output_dir, merge=merge, info_only=info_only)\r\n    elif sourceType == 'youku':\r\n        youku_download_by_vid(sourceId, title=title, output_dir=output_dir, merge=merge, info_only=info_only, **kwargs)\r\n    elif sourceType == 'tudou':\r\n        tudou_download_by_iid(sourceId, title, output_dir=output_dir, merge=merge, info_only=info_only)\r\n    elif sourceType == 'qq':\r\n        qq_download_by_vid(sourceId, title, True, output_dir=output_dir, merge=merge, info_only=info_only)\r\n    elif sourceType == 'letv':\r\n        letvcloud_download_by_vu(sourceId, '2d8c027396', title, output_dir=output_dir, merge=merge, info_only=info_only)\r\n    elif sourceType == 'zhuzhan':\r\n        url = 'http:\/\/www.acfun.cn\/v\/ac' + vid\r\n        yk_streams = youku_acfun_proxy(info['sourceId'], info['encode'], url)\r\n        seq = ['mp4hd3', 'mp4hd2', 'mp4hd', 'flvhd']\r\n        for t in seq:\r\n            if yk_streams.get(t):\r\n                preferred = yk_streams[t]\r\n                break\r\n        size = 0\r\n        for url in preferred[0]:\r\n            _, _, seg_size = url_info(url)\r\n            size += seg_size\r\n        if re.search(r'fid=[0-9A-Z\\-]*.flv', preferred[0][0]):\r\n            ext = 'flv'\r\n        else:\r\n            ext = 'mp4'\r\n        print_info(site_info, title, ext, size)\r\n        if not info_only:\r\n            download_urls(preferred[0], title, ext, size, output_dir=output_dir, merge=merge)\r\n    else:\r\n        raise NotImplementedError(sourceType)\r\n    if not info_only and not dry_run:\r\n        if not kwargs['caption']:\r\n            print('Skipping danmaku.')\r\n            return\r\n        try:\r\n            title = get_filename(title)\r\n            print('Downloading %s ...\\n' % (title + '.cmt.json'))\r\n            cmt = get_srt_json(vid)\r\n            with open(os.path.join(output_dir, title + '.cmt.json'), 'w', encoding='utf-8') as x:\r\n                x.write(cmt)\r\n        except:\r\n            pass\r\n\r\n\"\"\" This function is used to","code-length":699,"reference":"Download Acfun video by vid.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"def matchall(text, patterns):\r\n    ret = []\r\n    for pattern in patterns:\r\n        match = re.findall(pattern, text)\r\n        ret += match\r\n    return ret\r\n\r\n\"\"\" This function is used to","code-length":44,"reference":"Scans through a string for substrings matched some patterns.","result":"Is used to find all the files in a directory andfind all the files in a directory recursively.","score":[0.058,0.0505]}
{"code":"def parse_query_param(url, param):\r\n    try:\r\n        return parse.parse_qs(parse.urlparse(url).query)[param][0]\r\n    except:\r\n        return None\r\n\r\n\"\"\" This function is used to","code-length":48,"reference":"Parses the query string of a URL and returns the value of a parameter.","result":"Is used to parse the query parameters from the URL.","score":[0.1139,0.2757]}
{"code":"def get_content(url, headers={}, decoded=True):\r\n    logging.debug('get_content: %s' % url)\r\n    req = request.Request(url, headers=headers)\r\n    if cookies:\r\n        cookies.add_cookie_header(req)\r\n        req.headers.update(req.unredirected_hdrs)\r\n    response = urlopen_with_retry(req)\r\n    data = response.read()\r\n    content_encoding = response.getheader('Content-Encoding')\r\n    if content_encoding == 'gzip':\r\n        data = ungzip(data)\r\n    elif content_encoding == 'deflate':\r\n        data = undeflate(data)\r\n    if decoded:\r\n        charset = match1(\r\n            response.getheader('Content-Type', ''), r'charset=([\\w-]+)'\r\n        )\r\n        if charset is not None:\r\n            data = data.decode(charset, 'ignore')\r\n        else:\r\n            data = data.decode('utf-8', 'ignore')\r\n    return data\r\n\r\n\"\"\" This function is used to","code-length":213,"reference":"Gets the content of a URL via sending a HTTP GET request.","result":"Is used to get the content of a page.","score":[0.2733,0.3812]}
{"code":"def post_content(url, headers={}, post_data={}, decoded=True, **kwargs):\r\n    if kwargs.get('post_data_raw'):\r\n        logging.debug('post_content: %s\\npost_data_raw: %s' % (url, kwargs['post_data_raw']))\r\n    else:\r\n        logging.debug('post_content: %s\\npost_data: %s' % (url, post_data))\r\n    req = request.Request(url, headers=headers)\r\n    if cookies:\r\n        cookies.add_cookie_header(req)\r\n        req.headers.update(req.unredirected_hdrs)\r\n    if kwargs.get('post_data_raw'):\r\n        post_data_enc = bytes(kwargs['post_data_raw'], 'utf-8')\r\n    else:\r\n        post_data_enc = bytes(parse.urlencode(post_data), 'utf-8')\r\n    response = urlopen_with_retry(req, data=post_data_enc)\r\n    data = response.read()\r\n    content_encoding = response.getheader('Content-Encoding')\r\n    if content_encoding == 'gzip':\r\n        data = ungzip(data)\r\n    elif content_encoding == 'deflate':\r\n        data = undeflate(data)\r\n    if decoded:\r\n        charset = match1(\r\n            response.getheader('Content-Type'), r'charset=([\\w-]+)'\r\n        )\r\n        if charset is not None:\r\n            data = data.decode(charset)\r\n        else:\r\n            data = data.decode('utf-8')\r\n    return data\r\n\r\n\"\"\" This function is used to","code-length":342,"reference":"Post the content of a URL via sending a HTTP POST request.","result":"Is used to parse the response of the web page.","score":[0.1057,0.0847]}
{"code":"def parse_host(host):\r\n    if re.match(r'^(\\d+)$', host) is not None:\r\n        return (\"0.0.0.0\", int(host))\r\n    if re.match(r'^(\\w+):\/\/', host) is None:\r\n        host = \"\/\/\" + host\r\n    o = parse.urlparse(host)\r\n    hostname = o.hostname or \"0.0.0.0\"\r\n    port = o.port or 0\r\n    return (hostname, port)\r\n\r\n\"\"\" This function is used to","code-length":112,"reference":"Parses host name and port number from a string.","result":"Is used to parse the output of the command line.","score":[0,0.0549]}
{"code":"def showroom_get_roomid_by_room_url_key(room_url_key):\r\n    fake_headers_mobile = {\r\n        'Accept': 'text\/html,application\/xhtml+xml,application\/xml;q=0.9,*\/*;q=0.8',\r\n        'Accept-Charset': 'UTF-8,*;q=0.5',\r\n        'Accept-Encoding': 'gzip,deflate,sdch',\r\n        'Accept-Language': 'en-US,en;q=0.8',\r\n        'User-Agent': 'Mozilla\/5.0 (Linux; Android 4.4.2; Nexus 4 Build\/KOT49H) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/34.0.1847.114 Mobile Safari\/537.36'\r\n    }\r\n    webpage_url = 'https:\/\/www.showroom-live.com\/' + room_url_key\r\n    html = get_content(webpage_url, headers = fake_headers_mobile)\r\n    roomid = match1(html, r'room\\?room_id\\=(\\d+)')\r\n    assert roomid\r\n    return roomid\r\n\r\n\"\"\" This function is used to","code-length":262,"reference":"str->str","result":"Is used to get the roomid of a room.","score":[0,0.0]}
{"code":"def _wanmen_get_title_by_json_topic_part(json_content, tIndex, pIndex):\r\n    return '_'.join([json_content[0]['name'],\r\n                    json_content[0]['Topics'][tIndex]['name'],\r\n                    json_content[0]['Topics'][tIndex]['Parts'][pIndex]['name']])\r\n\r\n\"\"\" This function is used to","code-length":84,"reference":"Get a proper title with courseid+topicID+partID.","result":"Is used to get the title of a topic part.","score":[0.1291,0.2344]}
{"code":"def wanmen_download_by_course(json_api_content, output_dir='.', merge=True, info_only=False, **kwargs):\r\n    for tIndex in range(len(json_api_content[0]['Topics'])):\r\n        for pIndex in range(len(json_api_content[0]['Topics'][tIndex]['Parts'])):\r\n            wanmen_download_by_course_topic_part(json_api_content,\r\n                                                 tIndex,\r\n                                                 pIndex,\r\n                                                 output_dir=output_dir,\r\n                                                 merge=merge,\r\n                                                 info_only=info_only,\r\n                                                 **kwargs)\r\n\r\n\"\"\" This function is used to","code-length":150,"reference":"Download a WHOLE course.","result":"Is used to download the data from the Wanmen website.","score":[0,0.1087]}
{"code":"def wanmen_download_by_course_topic_part(json_api_content, tIndex, pIndex, output_dir='.', merge=True, info_only=False, **kwargs):\r\n    html = json_api_content\r\n    title = _wanmen_get_title_by_json_topic_part(html, \r\n                                                  tIndex, \r\n                                                  pIndex)\r\n    bokeccID = _wanmen_get_boke_id_by_json_topic_part(html,\r\n                                                      tIndex, \r\n                                                     pIndex)\r\n    bokecc_download_by_id(vid = bokeccID, title = title, output_dir=output_dir, merge=merge, info_only=info_only, **kwargs)\r\n\r\n\"\"\" This function is used to","code-length":174,"reference":"Download ONE PART of the course.","result":"Is used to download the bokecc dataset from the Wanmen website.","score":[0.0979,0.1538]}
{"code":"def has_task(self, task_instance):\r\n        if task_instance.key in self.queued_tasks or task_instance.key in self.running:\r\n            return True\r\n\r\n\"\"\" This function is used to","code-length":46,"reference":"Checks if a task is either queued or running in this executor","result":"Is used to get the list of tasks that are currently running .","score":[0.0818,0.124]}
{"code":"def get_event_buffer(self, dag_ids=None):\r\n        cleared_events = dict()\r\n        if dag_ids is None:\r\n            cleared_events = self.event_buffer\r\n            self.event_buffer = dict()\r\n        else:\r\n            for key in list(self.event_buffer.keys()):\r\n                dag_id, _, _, _ = key\r\n                if dag_id in dag_ids:\r\n                    cleared_events[key] = self.event_buffer.pop(key)\r\n        return cleared_events\r\n\r\n\"\"\" This function is used to","code-length":117,"reference":"Returns and flush the event buffer.","result":"Is used to send emails about events.","score":[0,0.0]}
{"code":"def get_conn(self):\r\n        conn_config = self._get_conn_params()\r\n        conn = snowflake.connector.connect(**conn_config)\r\n        return conn\r\n\r\n\"\"\" This function is used to","code-length":47,"reference":"Returns a snowflake.connection object","result":"Is used to get the connection to the Snowflake server.","score":[0,0.0]}
{"code":"def _get_aws_credentials(self):\r\n        if self.snowflake_conn_id:\r\n            connection_object = self.get_connection(self.snowflake_conn_id)\r\n            if 'aws_secret_access_key' in connection_object.extra_dejson:\r\n                aws_access_key_id = connection_object.extra_dejson.get(\r\n                    'aws_access_key_id')\r\n                aws_secret_access_key = connection_object.extra_dejson.get(\r\n                    'aws_secret_access_key')\r\n        return aws_access_key_id, aws_secret_access_key\r\n\r\n\"\"\" This function is used to","code-length":149,"reference":"returns aws_access_key_id, aws_secret_access_key        from extra        intended to be used by external import and export statements","result":"Is used to get the AWS credentials from the environment.","score":[0.0867,0.2177]}
{"code":"def _get_field(self, field_name, default=None):\r\n        full_field_name = 'extra__grpc__{}'.format(field_name)\r\n        if full_field_name in self.extras:\r\n            return self.extras[full_field_name]\r\n        else:\r\n            return default\r\n\r\n\"\"\" This function is used to","code-length":73,"reference":"Fetches a field from extras, and returns it.","result":"Is used to create a new proto file.","score":[0.1389,0.0625]}
{"code":"def copy_expert(self, sql, filename, open=open):\r\n        if not os.path.isfile(filename):\r\n            with open(filename, 'w'):\r\n                pass\r\n        with open(filename, 'r+') as f:\r\n            with closing(self.get_conn()) as conn:\r\n                with closing(conn.cursor()) as cur:\r\n                    cur.copy_expert(sql, f)\r\n                    f.truncate(f.tell())\r\n                    conn.commit()\r\n\r\n\"\"\" This function is used to","code-length":108,"reference":"Executes SQL using psycopg2 copy_expert method.","result":"Is used to copy the data from the database to thedatabase.","score":[0,0.0769]}
{"code":"def bulk_dump(self, table, tmp_file):\r\n        self.copy_expert(\"COPY {table} TO STDOUT\".format(table=table), tmp_file)\r\n\r\n\"\"\" This function is used to","code-length":47,"reference":"Dumps a database table into a tab-delimited file","result":"Is used to dump the data in a table .","score":[0.1291,0.1829]}
{"code":"def execute(self, context):\r\n        hook = GoogleCloudStorageHook(\r\n            google_cloud_storage_conn_id=self.google_cloud_storage_conn_id,\r\n            delegate_to=self.delegate_to)\r\n        hook.upload(\r\n            bucket_name=self.bucket,\r\n            object_name=self.dst,\r\n            mime_type=self.mime_type,\r\n            filename=self.src,\r\n            gzip=self.gzip,\r\n        )\r\n\r\n\"\"\" This function is used to","code-length":107,"reference":"Uploads the file to Google cloud storage","result":"Is used to copy a file from one bucket to another.","score":[0.1164,0.1351]}
{"code":"def max_partition(\r\n        table, schema=\"default\", field=None, filter_map=None,\r\n        metastore_conn_id='metastore_default'):\r\n    from airflow.hooks.hive_hooks import HiveMetastoreHook\r\n    if '.' in table:\r\n        schema, table = table.split('.')\r\n    hh = HiveMetastoreHook(metastore_conn_id=metastore_conn_id)\r\n    return hh.max_partition(\r\n        schema=schema, table_name=table, field=field, filter_map=filter_map)\r\n\r\n\"\"\" This function is used to","code-length":127,"reference":"Gets the max partition for a table.","result":" :param sql: SQL query to execute against the MySQL database :type sql.","score":[0.0891,0.0667]}
{"code":"def get_conn(self):\r\n        conn = self.get_connection(self.mysql_conn_id)\r\n        conn_config = {\r\n            \"user\": conn.login,\r\n            \"passwd\": conn.password or '',\r\n            \"host\": conn.host or 'localhost',\r\n            \"db\": self.schema or conn.schema or ''\r\n        }\r\n        if not conn.port:\r\n            conn_config[\"port\"] = 3306\r\n        else:\r\n            conn_config[\"port\"] = int(conn.port)\r\n        if conn.extra_dejson.get('charset', False):\r\n            conn_config[\"charset\"] = conn.extra_dejson[\"charset\"]\r\n            if (conn_config[\"charset\"]).lower() == 'utf8' or\\\r\n                    (conn_config[\"charset\"]).lower() == 'utf-8':\r\n                conn_config[\"use_unicode\"] = True\r\n        if conn.extra_dejson.get('cursor', False):\r\n            if (conn.extra_dejson[\"cursor\"]).lower() == 'sscursor':\r\n                conn_config[\"cursorclass\"] = MySQLdb.cursors.SSCursor\r\n            elif (conn.extra_dejson[\"cursor\"]).lower() == 'dictcursor':\r\n                conn_config[\"cursorclass\"] = MySQLdb.cursors.DictCursor\r\n            elif (conn.extra_dejson[\"cursor\"]).lower() == 'ssdictcursor':\r\n                conn_config[\"cursorclass\"] = MySQLdb.cursors.SSDictCursor\r\n        local_infile = conn.extra_dejson.get('local_infile', False)\r\n        if conn.extra_dejson.get('ssl', False):\r\n            dejson_ssl = conn.extra_dejson['ssl']\r\n            if isinstance(dejson_ssl, six.string_types):\r\n                dejson_ssl = json.loads(dejson_ssl)\r\n            conn_config['ssl'] = dejson_ssl\r\n        if conn.extra_dejson.get('unix_socket'):\r\n            conn_config['unix_socket'] = conn.extra_dejson['unix_socket']\r\n        if local_infile:\r\n            conn_config[\"local_infile\"] = 1\r\n        conn = MySQLdb.connect(**conn_config)\r\n        return conn\r\n\r\n\"\"\" This function is used to","code-length":473,"reference":"Returns a mysql connection object","result":"Is used to connect to a database.","score":[0.1615,0.1923]}
{"code":"def task_state(args):\r\n    dag = get_dag(args)\r\n    task = dag.get_task(task_id=args.task_id)\r\n    ti = TaskInstance(task, args.execution_date)\r\n    print(ti.current_state())\r\n\r\n\"\"\" This function is used to","code-length":66,"reference":"Returns the state of a TaskInstance at the command line.","result":"Is used to create the `update_dag` function .","score":[0.1082,0.051]}
{"code":"def restart_workers(gunicorn_master_proc, num_workers_expected, master_timeout):\r\n    def wait_until_true(fn, timeout=0):\r\n        t = time.time()\r\n        while not fn():\r\n            if 0 < timeout <= time.time() - t:\r\n                raise AirflowWebServerTimeout(\r\n                    \"No response from gunicorn master within {0} seconds\"\r\n                    .format(timeout))\r\n            time.sleep(0.1)\r\n    def start_refresh(gunicorn_master_proc):\r\n        batch_size = conf.getint('webserver', 'worker_refresh_batch_size')\r\n        log.debug('%s doing a refresh of %s workers', state, batch_size)\r\n        sys.stdout.flush()\r\n        sys.stderr.flush()\r\n        excess = 0\r\n        for _ in range(batch_size):\r\n            gunicorn_master_proc.send_signal(signal.SIGTTIN)\r\n            excess += 1\r\n            wait_until_true(lambda: num_workers_expected + excess ==\r\n                            get_num_workers_running(gunicorn_master_proc),\r\n                            master_timeout)\r\n    try:\r\n        wait_until_true(lambda: num_workers_expected ==\r\n                        get_num_workers_running(gunicorn_master_proc),\r\n                        master_timeout)\r\n        while True:\r\n            num_workers_running = get_num_workers_running(gunicorn_master_proc)\r\n            num_ready_workers_running = \\\r\n                get_num_ready_workers_running(gunicorn_master_proc)\r\n            state = '[{0} \/ {1}]'.format(num_ready_workers_running, num_workers_running)\r\n            if num_ready_workers_running < num_workers_running:\r\n                log.debug('%s some workers are starting up, waiting...', state)\r\n                sys.stdout.flush()\r\n                time.sleep(1)\r\n            elif num_workers_running > num_workers_expected:\r\n                excess = num_workers_running - num_workers_expected\r\n                log.debug('%s killing %s workers', state, excess)\r\n                for _ in range(excess):\r\n                    gunicorn_master_proc.send_signal(signal.SIGTTOU)\r\n                    excess -= 1\r\n                    wait_until_true(lambda: num_workers_expected + excess ==\r\n                                    get_num_workers_running(gunicorn_master_proc),\r\n                                    master_timeout)\r\n            elif num_workers_running == num_workers_expected:\r\n                refresh_interval = conf.getint('webserver', 'worker_refresh_interval')\r\n                log.debug(\r\n                    '%s sleeping for %ss starting doing a refresh...',\r\n                    state, refresh_interval\r\n                )\r\n                time.sleep(refresh_interval)\r\n                start_refresh(gunicorn_master_proc)\r\n            else:\r\n                log.error((\r\n                    \"%s some workers seem to have died and gunicorn\"\r\n                    \"did not restart them as expected\"\r\n                ), state)\r\n                time.sleep(10)\r\n                if len(\r\n                    psutil.Process(gunicorn_master_proc.pid).children()\r\n                ) < num_workers_expected:\r\n                    start_refresh(gunicorn_master_proc)\r\n    except (AirflowWebServerTimeout, OSError) as err:\r\n        log.error(err)\r\n        log.error(\"Shutting down webserver\")\r\n        try:\r\n            gunicorn_master_proc.terminate()\r\n            gunicorn_master_proc.wait()\r\n        finally:\r\n            sys.exit(1)\r\n\r\n\"\"\" This function is used to","code-length":763,"reference":"Runs forever, monitoring the child processes of @gunicorn_master_proc and    restarting workers occasionally.","result":"Code too long,keep in 512.","score":[0,0.0]}
{"code":"def get_conn(self):\r\n        if not self._client:\r\n            self._client = Client(credentials=self._get_credentials())\r\n        return self._client\r\n\r\n\"\"\" This function is used to","code-length":42,"reference":"Retrieves connection to Cloud Translate","result":"Is used to get the current user's token.","score":[0.1389,0.0943]}
{"code":"def translate(\r\n        self, values, target_language, format_=None, source_language=None, model=None\r\n    ):\r\n        client = self.get_conn()\r\n        return client.translate(\r\n            values=values,\r\n            target_language=target_language,\r\n            format_=format_,\r\n            source_language=source_language,\r\n            model=model,\r\n        )\r\n\r\n\"\"\" This function is used to","code-length":85,"reference":"Translate a string or list of strings.","result":" The string is expected to be in the form of a list of strings.","score":[0.177,0.5792]}
{"code":"def get_instance(self, instance, project_id=None):\r\n        return self.get_conn().instances().get(\r\n            project=project_id,\r\n            instance=instance\r\n        ).execute(num_retries=self.num_retries)\r\n\r\n\"\"\" This function is used to","code-length":60,"reference":"Retrieves a resource containing information about a Cloud SQL instance.","result":"Is used to create a new Cloud SQL instance.","score":[0.2413,0.3788]}
{"code":"def create_instance(self, body, project_id=None):\r\n        response = self.get_conn().instances().insert(\r\n            project=project_id,\r\n            body=body\r\n        ).execute(num_retries=self.num_retries)\r\n        operation_name = response[\"name\"]\r\n        self._wait_for_operation_to_complete(project_id=project_id,\r\n                                             operation_name=operation_name)\r\n\r\n\"\"\" This function is used to","code-length":101,"reference":"Creates a new Cloud SQL instance.","result":"Is used to create a new instance in the project.","score":[0.1535,0.4601]}
{"code":"def patch_instance(self, body, instance, project_id=None):\r\n        response = self.get_conn().instances().patch(\r\n            project=project_id,\r\n            instance=instance,\r\n            body=body\r\n        ).execute(num_retries=self.num_retries)\r\n        operation_name = response[\"name\"]\r\n        self._wait_for_operation_to_complete(project_id=project_id,\r\n                                             operation_name=operation_name)\r\n\r\n\"\"\" This function is used to","code-length":108,"reference":"Updates settings of a Cloud SQL instance.","result":"Is used to patch a single instance in a project.","score":[0.1086,0.0685]}
{"code":"def delete_instance(self, instance, project_id=None):\r\n        response = self.get_conn().instances().delete(\r\n            project=project_id,\r\n            instance=instance,\r\n        ).execute(num_retries=self.num_retries)\r\n        operation_name = response[\"name\"]\r\n        self._wait_for_operation_to_complete(project_id=project_id,\r\n                                             operation_name=operation_name)\r\n\r\n\"\"\" This function is used to","code-length":102,"reference":"Deletes a Cloud SQL instance.","result":"Is used to delete a project.","score":[0.193,0.3676]}
{"code":"def get_database(self, instance, database, project_id=None):\r\n        return self.get_conn().databases().get(\r\n            project=project_id,\r\n            instance=instance,\r\n            database=database\r\n        ).execute(num_retries=self.num_retries)\r\n\r\n\"\"\" This function is used to","code-length":67,"reference":"Retrieves a database resource from a Cloud SQL instance.","result":"Is used to get the instance of a database.","score":[0.1219,0.0556]}
{"code":"def create_database(self, instance, body, project_id=None):\r\n        response = self.get_conn().databases().insert(\r\n            project=project_id,\r\n            instance=instance,\r\n            body=body\r\n        ).execute(num_retries=self.num_retries)\r\n        operation_name = response[\"name\"]\r\n        self._wait_for_operation_to_complete(project_id=project_id,\r\n                                             operation_name=operation_name)\r\n\r\n\"\"\" This function is used to","code-length":108,"reference":"Creates a new database inside a Cloud SQL instance.","result":"Is used to create a new database.","score":[0.1716,0.1705]}
{"code":"def patch_database(self, instance, database, body, project_id=None):\r\n        response = self.get_conn().databases().patch(\r\n            project=project_id,\r\n            instance=instance,\r\n            database=database,\r\n            body=body\r\n        ).execute(num_retries=self.num_retries)\r\n        operation_name = response[\"name\"]\r\n        self._wait_for_operation_to_complete(project_id=project_id,\r\n                                             operation_name=operation_name)\r\n\r\n\"\"\" This function is used to","code-length":115,"reference":"Updates a database resource inside a Cloud SQL instance.","result":"Is used to patch the Cloud SQL instance to use theCloud SQL API.","score":[0.1157,0.1064]}
{"code":"def delete_database(self, instance, database, project_id=None):\r\n        response = self.get_conn().databases().delete(\r\n            project=project_id,\r\n            instance=instance,\r\n            database=database\r\n        ).execute(num_retries=self.num_retries)\r\n        operation_name = response[\"name\"]\r\n        self._wait_for_operation_to_complete(project_id=project_id,\r\n                                             operation_name=operation_name)\r\n\r\n\"\"\" This function is used to","code-length":108,"reference":"Deletes a database from a Cloud SQL instance.","result":"Is used to delete a database.","score":[0.1383,0.1282]}
{"code":"def export_instance(self, instance, body, project_id=None):\r\n        try:\r\n            response = self.get_conn().instances().export(\r\n                project=project_id,\r\n                instance=instance,\r\n                body=body\r\n            ).execute(num_retries=self.num_retries)\r\n            operation_name = response[\"name\"]\r\n            self._wait_for_operation_to_complete(project_id=project_id,\r\n                                                 operation_name=operation_name)\r\n        except HttpError as ex:\r\n            raise AirflowException(\r\n                'Exporting instance {} failed: {}'.format(instance, ex.content)\r\n            )\r\n\r\n\"\"\" This function is used to","code-length":142,"reference":"Exports data from a Cloud SQL instance to a Cloud Storage bucket as a SQL dump        or CSV file.","result":"Is used to export a single instance .","score":[0.0462,0.1117]}
{"code":"def start_proxy(self):\r\n        self._download_sql_proxy_if_needed()\r\n        if self.sql_proxy_process:\r\n            raise AirflowException(\"The sql proxy is already running: {}\".format(\r\n                self.sql_proxy_process))\r\n        else:\r\n            command_to_run = [self.sql_proxy_path]\r\n            command_to_run.extend(self.command_line_parameters)\r\n            try:\r\n                self.log.info(\"Creating directory %s\",\r\n                              self.cloud_sql_proxy_socket_directory)\r\n                os.makedirs(self.cloud_sql_proxy_socket_directory)\r\n            except OSError:\r\n                pass\r\n            command_to_run.extend(self._get_credential_parameters())\r\n            self.log.info(\"Running the command: `%s`\", \" \".join(command_to_run))\r\n            self.sql_proxy_process = Popen(command_to_run,\r\n                                           stdin=PIPE, stdout=PIPE, stderr=PIPE)\r\n            self.log.info(\"The pid of cloud_sql_proxy: %s\", self.sql_proxy_process.pid)\r\n            while True:\r\n                line = self.sql_proxy_process.stderr.readline().decode('utf-8')\r\n                return_code = self.sql_proxy_process.poll()\r\n                if line == '' and return_code is not None:\r\n                    self.sql_proxy_process = None\r\n                    raise AirflowException(\r\n                        \"The cloud_sql_proxy finished early with return code {}!\".format(\r\n                            return_code))\r\n                if line != '':\r\n                    self.log.info(line)\r\n                if \"googleapi: Error\" in line or \"invalid instance name:\" in line:\r\n                    self.stop_proxy()\r\n                    raise AirflowException(\r\n                        \"Error when starting the cloud_sql_proxy {}!\".format(\r\n                            line))\r\n                if \"Ready for new connections\" in line:\r\n                    return\r\n\r\n\"\"\" This function is used to","code-length":420,"reference":"Starts Cloud SQL Proxy.","result":"If __name__ == \"__main__\": .","score":[0,0.0]}
{"code":"def stop_proxy(self):\r\n        if not self.sql_proxy_process:\r\n            raise AirflowException(\"The sql proxy is not started yet\")\r\n        else:\r\n            self.log.info(\"Stopping the cloud_sql_proxy pid: %s\",\r\n                          self.sql_proxy_process.pid)\r\n            self.sql_proxy_process.kill()\r\n            self.sql_proxy_process = None\r\n        self.log.info(\"Removing the socket directory: %s\",\r\n                      self.cloud_sql_proxy_socket_directory)\r\n        shutil.rmtree(self.cloud_sql_proxy_socket_directory, ignore_errors=True)\r\n        if self.sql_proxy_was_downloaded:\r\n            self.log.info(\"Removing downloaded proxy: %s\", self.sql_proxy_path)\r\n            try:\r\n                os.remove(self.sql_proxy_path)\r\n            except OSError as e:\r\n                if not e.errno == errno.ENOENT:\r\n                    raise\r\n        else:\r\n            self.log.info(\"Skipped removing proxy - it was not downloaded: %s\",\r\n                          self.sql_proxy_path)\r\n        if os.path.isfile(self.credentials_path):\r\n            self.log.info(\"Removing generated credentials file %s\",\r\n                          self.credentials_path)\r\n            os.remove(self.credentials_path)\r\n\r\n\"\"\" This function is used to","code-length":295,"reference":"Stops running proxy.","result":"Is used to setup and run the sql proxy .","score":[0,0.1351]}
