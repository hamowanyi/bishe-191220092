{"code":"def render_body(context, options)\r\n      if options.key?(:partial)\r\n        [render_partial(context, options)]\r\n      else\r\n        StreamingTemplateRenderer.new(@lookup_context).render(context, options)\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":61,"reference":"Render but returns a valid Rack body.","result":"Render a single template object using the given template name.","score":[0.1291,0.2055]}
{"code":"def attribute_missing(match, *args, &block)\r\n      __send__(match.target, match.attr_name, *args, &block)\r\n    end\r\n\r\n# This function is used to","code-length":43,"reference":"+attribute_missing+ is like +method_missing+, but for attributes.","result":"Match blocks of code which are not allowed to be executed.","score":[0,0.0]}
{"code":"def matched_attribute_method(method_name)\r\n        matches = self.class.send(:attribute_method_matchers_matching, method_name)\r\n        matches.detect { |match| attribute_method?(match.attr_name) }\r\n      end\r\n\r\n# This function is used to","code-length":64,"reference":"Returns a struct representing the matching attribute method.","result":"Match attribute methods that are not defined in the class definition.","score":[0.1164,0.3079]}
{"code":"def demodulize(path)\r\n      path = path.to_s\r\n      if i = path.rindex(\"::\")\r\n        path[(i + 2)..-1]\r\n      else\r\n        path\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":52,"reference":"Removes the module part from the expression in the string.","result":"Convert a path to a file name.","score":[0,0.0]}
{"code":"def const_regexp(camel_cased_word)\r\n        parts = camel_cased_word.split(\"::\")\r\n        return Regexp.escape(camel_cased_word) if parts.blank?\r\n        last = parts.pop\r\n        parts.reverse.inject(last) do |acc, part|\r\n          part.empty? ? acc : \"#{part}(::#{acc})?\"\r\n        end\r\n      end\r\n\r\n# This function is used to","code-length":93,"reference":"Mounts a regular expression, returned as a string to ease interpolation,that will match part by part the given constant.","result":"Parse a string into a list of tokens.","score":[0.055,0.0838]}
{"code":"def apply_inflections(word, rules, locale = :en)\r\n        result = word.to_s.dup\r\n        if word.empty? || inflections(locale).uncountables.uncountable?(result)\r\n          result\r\n        else\r\n          rules.each { |(rule, replacement)| break if result.sub!(rule, replacement) }\r\n          result\r\n        end\r\n      end\r\n\r\n# This function is used to","code-length":91,"reference":"Applies inflection rules for +singularize+ and +pluralize+.","result":"Apply rules to the given word.","score":[0.1634,0.1449]}
{"code":"def autoload_module!(into, const_name, qualified_name, path_suffix)\r\n      return nil unless base_path = autoloadable_module?(path_suffix)\r\n      mod = Module.new\r\n      into.const_set const_name, mod\r\n      log(\"constant #{qualified_name} autoloaded (module autovivified from #{File.join(base_path, path_suffix)})\")\r\n      autoloaded_constants << qualified_name unless autoload_once_paths.include?(base_path)\r\n      autoloaded_constants.uniq!\r\n      mod\r\n    end\r\n\r\n# This function is used to","code-length":134,"reference":"Attempt to autoload the provided module name by searching for a directorymatching the expected path suffix.","result":"Load the module from a file.","score":[0.048,0.1]}
{"code":"def parse(data)\r\n      if !data.respond_to?(:read)\r\n        data = StringIO.new(data || \"\")\r\n      end\r\n      if data.eof?\r\n        {}\r\n      else\r\n        silence_warnings { require \"rexml\/document\" } unless defined?(REXML::Document)\r\n        doc = REXML::Document.new(data)\r\n        if doc.root\r\n          merge_element!({}, doc.root, XmlMini.depth)\r\n        else\r\n          raise REXML::ParseException,\r\n            \"The document #{doc.to_s.inspect} does not have a valid root\"\r\n        end\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":142,"reference":"Parse an XML Document string or IO into a simple hash.","result":"Parse a REXML document and return a dictionary ofdef parse.","score":[0.1168,0.1376]}
{"code":"def connects_to(database: {})\r\n      connections = []\r\n      database.each do |role, database_key|\r\n        config_hash = resolve_config_for_connection(database_key)\r\n        handler = lookup_connection_handler(role.to_sym)\r\n        connections << handler.establish_connection(config_hash)\r\n      end\r\n      connections\r\n    end\r\n\r\n# This function is used to","code-length":85,"reference":"Connects a model to the databases specified.","result":"Create a connection to a database.","score":[0.1943,0.2174]}
{"code":"def clear_query_caches_for_current_thread\r\n      ActiveRecord::Base.connection_handlers.each_value do |handler|\r\n        handler.connection_pool_list.each do |pool|\r\n          pool.connection.clear_query_cache if pool.active_connection?\r\n        end\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":74,"reference":"Clears the query cache for all connections associated with the current thread.","result":"Set the thread-local variable to the thread-local variable in the thread-local variable thread-local variable.","score":[0.0899,0.082]}
{"code":"def formatted_version\r\n        stringified = @version.to_s\r\n        return stringified unless stringified.length == 14\r\n        stringified.insert(4, \"_\").insert(7, \"_\").insert(10, \"_\")\r\n      end\r\n\r\n# This function is used to","code-length":57,"reference":"turns 20170404131909 into \"2017_04_04_131909\"","result":"Convert a version string to a version number.","score":[0,0.0]}
{"code":"def indexes(table, stream)\r\n        if (indexes = @connection.indexes(table)).any?\r\n          add_index_statements = indexes.map do |index|\r\n            table_name = remove_prefix_and_suffix(index.table).inspect\r\n            \"  add_index #{([table_name] + index_parts(index)).join(', ')}\"\r\n          end\r\n          stream.puts add_index_statements.sort.join(\"\\n\")\r\n          stream.puts\r\n        end\r\n      end\r\n\r\n# This function is used to","code-length":113,"reference":"Keep it for indexing materialized views","result":"Generate the SQL for the CREATE INDEX statement.","score":[0.1389,0.1613]}
{"code":"def formatted_offset(colon = true, alternate_utc_string = nil)\r\n      utc? && alternate_utc_string || TimeZone.seconds_to_utc_offset(utc_offset, colon)\r\n    end\r\n\r\n# This function is used to","code-length":54,"reference":"Returns a formatted string of the offset from UTC, or an alternativestring if the time zone is already UTC.","result":"Convert a time zone to a string that can be used in a string.","score":[0.089,0.1706]}
{"code":"def advance(options)\r\n.any?\r\n        method_missing(:advance, options)\r\n      else\r\n        utc.advance(options).in_time_zone(time_zone)\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":51,"reference":"Uses Date to provide precise Time calculations for years, months, and daysaccording to the proleptic Gregorian calendar.","result":"Implement the \"next\" method.","score":[0.0124,0.0318]}
{"code":"def process(action, *args)\r\n      @_action_name = action.to_s\r\n      unless action_name = _find_action_name(@_action_name)\r\n        raise ActionNotFound, \"The action '#{action}' could not be found for #{self.class.name}\"\r\n      end\r\n      @_response_body = nil\r\n      process_action(action_name, *args)\r\n    end\r\n\r\n# This function is used to","code-length":93,"reference":"Calls the action going through the entire action dispatch stack.","result":"Create a new action.","score":[0,0.0]}
{"code":"def any?(*candidates)\r\n      if candidates.none?\r\n        super\r\n      else\r\n        candidates.any? do |candidate|\r\n          include?(candidate.to_sym) || include?(candidate.to_s)\r\n        end\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":59,"reference":"Passes each element of +candidates+ collection to ArrayInquirer collection.","result":"Match classes to other classes.","score":[0.108,0.0581]}
{"code":"def cache_key\r\n      if new_record?\r\n        \"#{model_name.cache_key}\/new\"\r\n      else\r\n        if cache_version\r\n          \"#{model_name.cache_key}\/#{id}\"\r\n        else\r\n          timestamp = max_updated_column_timestamp\r\n          if timestamp\r\n            timestamp = timestamp.utc.to_s(cache_timestamp_format)\r\n            \"#{model_name.cache_key}\/#{id}-#{timestamp}\"\r\n          else\r\n            \"#{model_name.cache_key}\/#{id}\"\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":129,"reference":"Returns a stable cache key that can be used to identify this record.","result":"Cache the model data for a given model.","score":[0.0743,0.12]}
{"code":"def format_paragraph(text, len = 72, indent = 2)\r\n      sentences = [[]]\r\n      text.split.each do |word|\r\n        if sentences.first.present? && (sentences.last + [word]).join(\" \").length > len\r\n          sentences << [word]\r\n        else\r\n          sentences.last << word\r\n        end\r\n      end\r\n      indentation = \" \" * indent\r\n      sentences.map! { |sentence|\r\n        \"#{indentation}#{sentence.join(' ')}\"\r\n      }.join \"\\n\"\r\n    end\r\n\r\n# This function is used to","code-length":118,"reference":"Returns +text+ wrapped at +len+ columns and indented +indent+ spaces.","result":"Generate the output of the program.","score":[0,0.0]}
{"code":"def find_in_batches(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil)\r\n      relation = self\r\n      unless block_given?\r\n        return to_enum(:find_in_batches, start: start, finish: finish, batch_size: batch_size, error_on_ignore: error_on_ignore) do\r\n          total = apply_limits(relation, start, finish).size\r\n          (total - 1).div(batch_size) + 1\r\n        end\r\n      end\r\n      in_batches(of: batch_size, start: start, finish: finish, load: true, error_on_ignore: error_on_ignore) do |batch|\r\n        yield batch.to_a\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":171,"reference":"Yields each batch of records that was found by the find options asan array.","result":"Generate the code for the program.","score":[0.0509,0.0379]}
{"code":"def match?(attribute, type = nil, **options)\r\n      if @attribute != attribute || (type && @type != type)\r\n        return false\r\n      end\r\n      options.each do |key, value|\r\n        if @options[key] != value\r\n          return false\r\n        end\r\n      end\r\n      true\r\n    end\r\n\r\n# This function is used to","code-length":71,"reference":"See if error matches provided +attribute+, +type+ and +options+.","result":"Match a string to a regular expression.","score":[0,0.0568]}
{"code":"def fetch_or_cache_partial(cached_partials, template, order_by:)\r\n        order_by.each_with_object({}) do |cache_key, hash|\r\n            hash[cache_key] =\r\n              if content = cached_partials[cache_key]\r\n                build_rendered_template(content, template)\r\n              else\r\n                yield.tap do |rendered_partial|\r\n                  collection_cache.write(cache_key, rendered_partial.body)\r\n                end\r\n              end\r\n          end\r\n      end\r\n\r\n# This function is used to","code-length":117,"reference":"`order_by` is an enumerable object containing keys of the cache,all keys are  passed in whether found already or not.","result":"Cache the rendered template for a given template name.","score":[0.0401,0.0556]}
{"code":"def run_callbacks(kind)\r\n      callbacks = __callbacks[kind.to_sym]\r\n      if callbacks.empty?\r\n        yield if block_given?\r\n      else\r\n        env = Filters::Environment.new(self, false, nil)\r\n        next_sequence = callbacks.compile\r\n        invoke_sequence = Proc.new do\r\n          skipped = nil\r\n          while true\r\n            current = next_sequence\r\n            current.invoke_before(env)\r\n            if current.final?\r\n              env.value = !env.halted && (!block_given? || yield)\r\n            elsif current.skip?(env)\r\n              (skipped ||= []) << current\r\n              next_sequence = next_sequence.nested\r\n              next\r\n            else\r\n              next_sequence = next_sequence.nested\r\n              begin\r\n                target, block, method, *arguments = current.expand_call_template(env, invoke_sequence)\r\n                target.send(method, *arguments, &block)\r\n              ensure\r\n                next_sequence = current\r\n              end\r\n            end\r\n            current.invoke_after(env)\r\n            skipped.pop.invoke_after(env) while skipped && skipped.first\r\n            break env.value\r\n          end\r\n        end\r\n        if next_sequence.final?\r\n          next_sequence.invoke_before(env)\r\n          env.value = !env.halted && (!block_given? || yield)\r\n          next_sequence.invoke_after(env)\r\n          env.value\r\n        else\r\n          invoke_sequence.call\r\n        end\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":317,"reference":"Runs the callbacks for the given event.","result":"Create a new macro with the given name.","score":[0.1964,0.2641]}
{"code":"def extract_annotations_from(file, pattern)\r\n      lineno = 0\r\n      result = File.readlines(file, encoding: Encoding::BINARY).inject([]) do |list, line|\r\n        lineno += 1\r\n        next list unless line =~ pattern\r\n        list << Annotation.new(lineno, $1, $2)\r\n      end\r\n      result.empty? ? {} : { file => result }\r\n    end\r\n\r\n# This function is used to","code-length":90,"reference":"If +file+ is the filename of a file that contains annotations this method returnsa hash with a single entry that maps +file+ to an array of its annotations.","result":"Parse a file and return a list of annotations that are found in the file.","score":[0.0572,0.1796]}
{"code":"def _wrapper_enabled?\r\n        return false unless request.has_content_type?\r\n        ref = request.content_mime_type.ref\r\n        _wrapper_formats.include?(ref) && _wrapper_key && !request.parameters.key?(_wrapper_key)\r\n      end\r\n\r\n# This function is used to","code-length":69,"reference":"Checks if we should perform parameters wrapping.","result":"Create a new request object.","score":[0,0.0]}
{"code":"def new_session\r\n      app = Rails.application\r\n      session = ActionDispatch::Integration::Session.new(app)\r\n      yield session if block_given?\r\n      session.extend(app.routes.url_helpers)\r\n      session.extend(app.routes.mounted_helpers)\r\n      session\r\n    end\r\n\r\n# This function is used to","code-length":72,"reference":"create a new session.","result":"Create a new session.","score":[0.658,0.9922]}
{"code":"def reload!(print = true)\r\n      puts \"Reloading...\" if print\r\n      Rails.application.reloader.reload!\r\n      true\r\n    end\r\n\r\n# This function is used to","code-length":40,"reference":"reloads the environment","result":"Reload the application.","score":[0.4082,0.625]}
{"code":"def dom_id(record, prefix = nil)\r\n      if record_id = record_key_for_dom_id(record)\r\n        \"#{dom_class(record, prefix)}#{JOIN}#{record_id}\"\r\n      else\r\n        dom_class(record, prefix || NEW)\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":75,"reference":"The DOM id convention is to use the singular form of an object or class with the id following an underscore.","result":"Generate the DOM tree for the given record.","score":[0.036,0.0761]}
{"code":"def included(base = nil, &block)\r\n      if base.nil?\r\n        if instance_variable_defined?(:@_included_block)\r\n          if @_included_block.source_location != block.source_location\r\n            raise MultipleIncludedBlocks\r\n          end\r\n        else\r\n          @_included_block = block\r\n        end\r\n      else\r\n        super\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":82,"reference":"Evaluate given block in context of base class,so that you can write class macros here.","result":"Find the first block that is included in the included blocks.","score":[0.0896,0.1027]}
{"code":"def class_methods(&class_methods_module_definition)\r\n      mod = const_defined?(:ClassMethods, false) ?\r\n        const_get(:ClassMethods) :\r\n        const_set(:ClassMethods, Module.new)\r\n      mod.module_eval(&class_methods_module_definition)\r\n    end\r\n\r\n# This function is used to","code-length":76,"reference":"Define class methods from given block.","result":"Create a class method object from a module definition.","score":[0.1449,0.4056]}
{"code":"def cache(key, options = {}, &block)\r\n        if cache_configured?\r\n          cache_store.fetch(ActiveSupport::Cache.expand_cache_key(key, :controller), options, &block)\r\n        else\r\n          yield\r\n        end\r\n      end\r\n\r\n# This function is used to","code-length":61,"reference":"Convenience accessor.","result":"Cache the active support.","score":[0,0.0]}
{"code":"def valid_message?(signed_message)\r\n      return if signed_message.nil? || !signed_message.valid_encoding? || signed_message.blank?\r\n      data, digest = signed_message.split(\"--\")\r\n      data.present? && digest.present? && ActiveSupport::SecurityUtils.secure_compare(digest, generate_digest(data))\r\n    end\r\n\r\n# This function is used to","code-length":87,"reference":"Checks if a signed message could have been generated by signing an objectwith the +MessageVerifier+'s secret.","result":"Generate the message digest.","score":[0.0189,0.1014]}
{"code":"def verified(signed_message, purpose: nil, **)\r\n      if valid_message?(signed_message)\r\n        begin\r\n          data = signed_message.split(\"--\")[0]\r\n          message = Messages::Metadata.verify(decode(data), purpose)\r\n          @serializer.load(message) if message\r\n        rescue ArgumentError => argument_error\r\n          return if argument_error.message.include?(\"invalid base64\")\r\n          raise\r\n        end\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":104,"reference":"Decodes the signed message using the +MessageVerifier+'s secret.","result":"Convert a message to a dictionary.","score":[0.1383,0.0641]}
{"code":"def generate(value, expires_at: nil, expires_in: nil, purpose: nil)\r\n      data = encode(Messages::Metadata.wrap(@serializer.dump(value), expires_at: expires_at, expires_in: expires_in, purpose: purpose))\r\n      \"#{data}--#{generate_digest(data)}\"\r\n    end\r\n\r\n# This function is used to","code-length":84,"reference":"Generates a signed message for the provided value.","result":"Generate a signature for a message.","score":[0.1645,0.1923]}
{"code":"def serialize\r\n      {\r\n        \"job_class\"  => self.class.name,\r\n        \"job_id\"     => job_id,\r\n        \"provider_job_id\" => provider_job_id,\r\n        \"queue_name\" => queue_name,\r\n        \"priority\"   => priority,\r\n        \"arguments\"  => serialize_arguments_if_needed(arguments),\r\n        \"executions\" => executions,\r\n        \"exception_executions\" => exception_executions,\r\n        \"locale\"     => I18n.locale.to_s,\r\n        \"timezone\"   => Time.zone.try(:name),\r\n        \"enqueued_at\" => Time.now.utc.iso8601\r\n      }\r\n    end\r\n\r\n# This function is used to","code-length":161,"reference":"Creates a new job instance.","result":"Serialize the job_id and provider_job_id into a JSON string.","score":[0.1219,0.0926]}
{"code":"def deserialize(job_data)\r\n      self.job_id               = job_data[\"job_id\"]\r\n      self.provider_job_id      = job_data[\"provider_job_id\"]\r\n      self.queue_name           = job_data[\"queue_name\"]\r\n      self.priority             = job_data[\"priority\"]\r\n      self.serialized_arguments = job_data[\"arguments\"]\r\n      self.executions           = job_data[\"executions\"]\r\n      self.exception_executions = job_data[\"exception_executions\"]\r\n      self.locale               = job_data[\"locale\"] || I18n.locale.to_s\r\n      self.timezone             = job_data[\"timezone\"] || Time.zone.try(:name)\r\n      self.enqueued_at          = job_data[\"enqueued_at\"]\r\n    end\r\n\r\n# This function is used to","code-length":187,"reference":"Attaches the stored job data to the current instance.","result":"Convert a job_data dictionary into a Job object.","score":[0,0.0562]}
{"code":"def match?(path)\r\n      path = ::Rack::Utils.unescape_path path\r\n      return false unless ::Rack::Utils.valid_path? path\r\n      path = ::Rack::Utils.clean_path_info path\r\n      paths = [path, \"#{path}#{ext}\", \"#{path}\/#{@index}#{ext}\"]\r\n      if match = paths.detect { |p|\r\n        path = File.join(@root, p.b)\r\n        begin\r\n          File.file?(path) && File.readable?(path)\r\n        rescue SystemCallError\r\n          false\r\n        end\r\n      }\r\n        return ::Rack::Utils.escape_path(match).b\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":159,"reference":"Takes a path to a file.","result":"Find the end of a path.","score":[0.193,0.0833]}
{"code":"def +(other)\r\n      if Duration === other\r\n        parts = @parts.dup\r\n        other.parts.each do |(key, value)|\r\n          parts[key] += value\r\n        end\r\n        Duration.new(value + other.value, parts)\r\n      else\r\n        seconds = @parts[:seconds] + other\r\n        Duration.new(value + other, @parts.merge(seconds: seconds))\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":94,"reference":"Compares one Duration with another or a Numeric to this Duration.","result":"Create a new Duration object.","score":[0.0861,0.0962]}
{"code":"def *(other)\r\n      if Scalar === other || Duration === other\r\n        Duration.new(value * other.value, parts.map { |type, number| [type, number * other.value] })\r\n      elsif Numeric === other\r\n        Duration.new(value * other, parts.map { |type, number| [type, number * other] })\r\n      else\r\n        raise_type_error(other)\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":99,"reference":"Multiplies this Duration by a Numeric and returns a new Duration.","result":"Convert a value to a Duration.","score":[0.1104,0.1429]}
{"code":"def %(other)\r\n      if Duration === other || Scalar === other\r\n        Duration.build(value % other.value)\r\n      elsif Numeric === other\r\n        Duration.build(value % other)\r\n      else\r\n        raise_type_error(other)\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":63,"reference":"Returns the modulo of this Duration by another Duration or Numeric.","result":"Convert a value to a Duration.","score":[0,0.0]}
{"code":"def locale=(value)\r\n      if value\r\n        config = I18n.config.respond_to?(:original_config) ? I18n.config.original_config : I18n.config\r\n        config.locale = value\r\n      end\r\n      super(default_locale)\r\n    end\r\n\r\n# This function is used to","code-length":68,"reference":"to original_config, it means that it has a copy of the original I18n configuration and it'sacting as proxy, which we need to skip.","result":"Set the locale for the current locale.","score":[0.0164,0.0234]}
{"code":"def find_all(name, prefix = nil, partial = false, details = {}, key = nil, locals = [])\r\n      locals = locals.map(&:to_s).sort!.freeze\r\n      cached(key, [name, prefix, partial], details, locals) do\r\n        _find_all(name, prefix, partial, details, key, locals)\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":88,"reference":"Normalizes the arguments and passes it on to find_templates.","result":"Find all the names of all the names of a given object.","score":[0.0891,0.1075]}
{"code":"def cached(key, path_info, details, locals)\r\n      name, prefix, partial = path_info\r\n      if key\r\n        @cache.cache(key, name, prefix, partial, locals) do\r\n          yield\r\n        end\r\n      else\r\n        yield\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":63,"reference":"Handles templates caching.","result":"Cache a function's return values for the default functions if they are not defined in the cache.","score":[0,0.0]}
{"code":"def extract_handler_and_format_and_variant(path)\r\n        pieces = File.basename(path).split(\".\")\r\n        pieces.shift\r\n        extension = pieces.pop\r\n        handler = Template.handler_for_extension(extension)\r\n        format, variant = pieces.last.split(EXTENSIONS[:variants], 2) if pieces.last\r\n        format = if format\r\n          Template::Types[format]&.ref\r\n        else\r\n          if handler.respond_to?(:default_format)\r\n            handler.default_format\r\n          else\r\n            nil\r\n          end\r\n        end\r\n        [handler, format, variant]\r\n      end\r\n\r\n# This function is used to","code-length":133,"reference":"Extract handler, formats and variant from path.","result":"Convert a template to a file.","score":[0,0.0]}
{"code":"def render_template(view, template, layout_name = nil, locals = {})\r\n      return [super.body] unless layout_name && template.supports_streaming?\r\n      locals ||= {}\r\n      layout   = layout_name && find_layout(layout_name, locals.keys, [formats.first])\r\n      Body.new do |buffer|\r\n        delayed_render(buffer, template, layout, view, locals)\r\n      end\r\n    end\r\n\r\n# This function is used to","code-length":101,"reference":"For streaming, instead of rendering a given a template, we return a Bodyobject that responds to each.","result":"Render a single template.","score":[0.0124,0.0637]}
{"code":"def record_changed?(reflection, record, key)\r\n        record.new_record? ||\r\n          association_foreign_key_changed?(reflection, record, key) ||\r\n          record.will_save_change_to_attribute?(reflection.foreign_key)\r\n      end\r\n\r\n# This function is used to","code-length":67,"reference":"If the record is new or it has changed, returns true.","result":"Unpickle Model instances with no foreign keys or relationships.","score":[0.0976,0.0463]}
{"code":"def transliterate(string, replacement = \"?\", locale: nil)\r\n      raise ArgumentError, \"Can only transliterate strings. Received #{string.class.name}\" unless string.is_a?(String)\r\n      I18n.transliterate(\r\n        ActiveSupport::Multibyte::Unicode.tidy_bytes(string).unicode_normalize(:nfc),\r\n        replacement: replacement,\r\n        locale: locale\r\n      )\r\n    end\r\n\r\n# This function is used to","code-length":102,"reference":"Replaces non-ASCII characters with an ASCII approximation, or if noneexists, a replacement character which defaults to \"?\".","result":"Convert a string to a Unicode string.","score":[0.046,0.0625]}
{"code":"def import(error, override_options = {})\r\n      [:attribute, :type].each do |key|\r\n        if override_options.key?(key)\r\n          override_options[key] = override_options[key].to_sym\r\n        end\r\n      end\r\n      @errors.append(NestedError.new(@base, error, override_options))\r\n    end\r\n\r\n# This function is used to","code-length":85,"reference":"Imports one error","result":"Convert a string to a list of strings.","score":[0,0.0]}
{"code":"def slice!(*keys)\r\n      deprecation_removal_warning(:slice!)\r\n      keys = keys.map(&:to_sym)\r\n      results = messages.dup.slice!(*keys)\r\n      @errors.keep_if do |error|\r\n        keys.include?(error.attribute)\r\n      end\r\n      results\r\n    end\r\n\r\n# This function is used to","code-length":75,"reference":"Removes all errors except the given keys.","result":"Convert a message to a message.","score":[0,0.0]}
{"code":"def where(attribute, type = nil, **options)\r\n      attribute, type, options = normalize_arguments(attribute, type, options)\r\n      @errors.select { |error|\r\n        error.match?(attribute, type, options)\r\n      }\r\n    end\r\n\r\n# This function is used to","code-length":62,"reference":"Search for errors matching +attribute+, +type+ or +options+.","result":"Parse the arguments of the command line.","score":[0,0.0]}
{"code":"def delete(attribute, type = nil, **options)\r\n      attribute, type, options = normalize_arguments(attribute, type, options)\r\n      matches = where(attribute, type, options)\r\n      matches.each do |error|\r\n        @errors.delete(error)\r\n      end\r\n      matches.map(&:message)\r\n    end\r\n\r\n# This function is used to","code-length":76,"reference":"Delete messages for +key+.","result":"Convert a value to a string.","score":[0,0.0]}
